diff --git a/drivers/net/ethernet/Kconfig b/drivers/net/ethernet/Kconfig
index 8cc7467..6e217d7 100644
--- a/drivers/net/ethernet/Kconfig
+++ b/drivers/net/ethernet/Kconfig
@@ -179,5 +179,5 @@ source "drivers/net/ethernet/via/Kconfig"
 source "drivers/net/ethernet/wiznet/Kconfig"
 source "drivers/net/ethernet/xilinx/Kconfig"
 source "drivers/net/ethernet/xircom/Kconfig"
-
+source "drivers/net/ethernet/centec/Kconfig"
 endif # ETHERNET
diff --git a/drivers/net/ethernet/Makefile b/drivers/net/ethernet/Makefile
index a09423d..fd67870 100644
--- a/drivers/net/ethernet/Makefile
+++ b/drivers/net/ethernet/Makefile
@@ -89,3 +89,4 @@ obj-$(CONFIG_NET_VENDOR_VIA) += via/
 obj-$(CONFIG_NET_VENDOR_WIZNET) += wiznet/
 obj-$(CONFIG_NET_VENDOR_XILINX) += xilinx/
 obj-$(CONFIG_NET_VENDOR_XIRCOM) += xircom/
+obj-$(CONFIG_NET_VENDOR_CENTEC) += centec/
diff --git a/drivers/net/ethernet/centec/Kconfig b/drivers/net/ethernet/centec/Kconfig
new file mode 100644
index 0000000..e2c5ffc
--- /dev/null
+++ b/drivers/net/ethernet/centec/Kconfig
@@ -0,0 +1,10 @@
+#
+# Centec network device configuration
+#
+
+config NET_VENDOR_CENTEC
+        tristate "centec cpumac"
+        default n
+        ---help---
+          If you have a network (Ethernet) card belonging to this class, say Y.
+
diff --git a/drivers/net/ethernet/centec/Makefile b/drivers/net/ethernet/centec/Makefile
new file mode 100644
index 0000000..4eb5938
--- /dev/null
+++ b/drivers/net/ethernet/centec/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_NET_VENDOR_CENTEC) += ctcmac.o  ctcmac_test.o ctc5236_mdio.o
diff --git a/drivers/net/ethernet/centec/ctc5236_mdio.c b/drivers/net/ethernet/centec/ctc5236_mdio.c
new file mode 100644
index 0000000..8729c0e
--- /dev/null
+++ b/drivers/net/ethernet/centec/ctc5236_mdio.c
@@ -0,0 +1,205 @@
+/*
+ * Centec CpuMac Ethernet Driver -- CpuMac controller implementation
+ * Provides Bus interface for MIIM regs
+ *
+ * Author: liuht <liuht@centecnetworks.com>
+ *
+ * Copyright 2002-2018, Centec Networks (Suzhou) Co., Ltd.
+ *
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/unistd.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/if_vlan.h>
+#include <linux/spinlock.h>
+#include <linux/mm.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_mdio.h>
+#include <linux/of_platform.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+#include <linux/in.h>
+#include <linux/net_tstamp.h>
+#include <linux/mii.h>
+#include <linux/iopoll.h>
+
+#include <asm/io.h>
+
+#include "ctcmac.h"
+#include "ctcmac_reg.h"
+
+
+
+struct ctc_mdio_priv {
+	void __iomem *map;
+	struct MdioSoc_regs *mdio_reg;
+};
+
+static int ctc_mdio_write(struct mii_bus *bus, int mii_id, int reg,
+		u16 value)
+{
+    int ret = 0;
+    u32 cmd = 0;
+    u32 tmp = 0;
+    struct ctc_mdio_priv *priv = (struct ctc_mdio_priv *)bus->priv;
+
+    cmd = CTCMAC_MDIO_CMD_REGAD(reg) | CTCMAC_MDIO_CMD_PHYAD(mii_id) 
+        | CTCMAC_MDIO_CMD_OPCODE(1) | CTCMAC_MDIO_CMD_DATA(value);
+
+    writel(cmd, &priv->mdio_reg->MdioSocCmd0[0]);    
+    writel(1, &priv->mdio_reg->MdioSocCmd0[1]);
+    
+    ret = readl_poll_timeout(&priv->mdio_reg->MdioSocStatus0, 
+        tmp, tmp & CTCMAC_MDIO_STAT(1), 1000, 10000); 
+    
+    if(ret < 0)
+    {
+        return -1;
+    }
+
+    return 0;
+}
+
+static int ctc_mdio_read(struct mii_bus *bus, int mii_id, int reg)
+{
+    int ret = 0;
+    u32 cmd = 0;
+    u32 status;
+    int value = 0;
+    struct ctc_mdio_priv *priv = (struct ctc_mdio_priv *)bus->priv;
+
+
+
+    cmd = CTCMAC_MDIO_CMD_REGAD(reg) | CTCMAC_MDIO_CMD_PHYAD(mii_id) 
+        | CTCMAC_MDIO_CMD_OPCODE(2);
+    
+    writel(cmd, &priv->mdio_reg->MdioSocCmd0[0]);    
+    writel(1, &priv->mdio_reg->MdioSocCmd0[1]);
+    
+    ret = readl_poll_timeout(&priv->mdio_reg->MdioSocStatus0, 
+        status, status & CTCMAC_MDIO_STAT(1), 1000, 10000);
+    if(ret < 0)
+    {
+    	printk(KERN_ERR "ctc_mdio_read1\n");
+        return -1;
+    }
+
+    value = (readl(&priv->mdio_reg->MdioSocStatus0) & 0xffff);
+
+    return value;
+}
+
+static int ctc_mdio_reset(struct mii_bus *bus)
+{
+    struct ctc_mdio_priv *priv = (struct ctc_mdio_priv *)bus->priv;
+    
+    writel(0x91f, &priv->mdio_reg->MdioSocCfg0);
+
+    return 0;
+}
+
+static const struct of_device_id ctc_mdio_match[] = {
+	{
+		.compatible = "ctc,mdio",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, ctc_mdio_match);
+
+static int ctc_mdio_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct resource res;
+	struct ctc_mdio_priv *priv;
+	struct mii_bus *new_bus;
+	int err;
+
+	new_bus = mdiobus_alloc_size(sizeof(*priv));
+	if (!new_bus)
+		return -ENOMEM;
+
+	priv = new_bus->priv;
+	new_bus->name = "CTC MII Bus",
+	new_bus->read = &ctc_mdio_read;
+	new_bus->write = &ctc_mdio_write;
+	new_bus->reset = &ctc_mdio_reset;
+
+	err = of_address_to_resource(np, 0, &res);
+	if (err < 0) {
+		pr_err("Of address to resource fail %d!\n", err);
+		goto error;
+	}
+
+	snprintf(new_bus->id, MII_BUS_ID_SIZE, "%s@%llx", np->name,
+		(unsigned long long)res.start);
+
+	priv->map = of_iomap(np, 0);
+	if (!priv->map) {
+		err = -ENOMEM;
+		pr_err("of iomap fail %d!\n", err);
+		goto error;
+	}
+	priv->mdio_reg = (struct MdioSoc_regs *)priv->map;
+	new_bus->parent = &pdev->dev;
+	platform_set_drvdata(pdev, new_bus);
+
+	err = of_mdiobus_register(new_bus, np);
+	if (err) {
+		pr_err("register mdio bus fail %d!\n", err);
+		goto error;
+	}
+
+	return 0;
+
+error:
+	if (priv->map)
+		iounmap(priv->map);
+
+	kfree(new_bus);
+
+	return err;
+}
+
+
+static int ctc_mdio_remove(struct platform_device *pdev)
+{
+	struct device *device = &pdev->dev;
+	struct mii_bus *bus = dev_get_drvdata(device);
+	struct ctc_mdio_priv *priv = bus->priv;
+
+	mdiobus_unregister(bus);
+
+	iounmap(priv->map);
+	mdiobus_free(bus);
+
+	return 0;
+}
+
+static struct platform_driver ctc_mdio_driver = {
+	.driver = {
+		.name = "ctc_mdio",
+		.of_match_table = ctc_mdio_match,
+	},
+	.probe = ctc_mdio_probe,
+	.remove = ctc_mdio_remove,
+};
+
+module_platform_driver(ctc_mdio_driver);
+
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/ethernet/centec/ctcmac.c b/drivers/net/ethernet/centec/ctcmac.c
new file mode 100644
index 0000000..206a542
--- /dev/null
+++ b/drivers/net/ethernet/centec/ctcmac.c
@@ -0,0 +1,2588 @@
+/*
+ * Centec CpuMac Ethernet Driver -- CpuMac controller implementation
+ * Provides Bus interface for MIIM regs
+ *
+ * Author: liuht <liuht@centecnetworks.com>
+ *
+ * Copyright 2002-2018, Centec Networks (Suzhou) Co., Ltd.
+ *
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/unistd.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/if_vlan.h>
+#include <linux/spinlock.h>
+#include <linux/mm.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_mdio.h>
+#include <linux/of_platform.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+#include <linux/in.h>
+#include <linux/net_tstamp.h>
+#include <asm/io.h>
+#include <dt-bindings/pinctrl/pinctrl-ctc.h>
+#include <soc/ctc/sysctl.h>
+#include <linux/regmap.h>
+#include <linux/mfd/syscon.h>
+#include <linux/iopoll.h>
+#include "ctcmac.h"
+#include "ctcmac_reg.h"
+
+static int ctcmac_alloc_skb_resources(struct net_device *ndev);
+static int ctcmac_free_skb_resources(struct ctcmac_private *priv);
+static void cpumac_start(struct ctcmac_private *priv);
+static void cpumac_halt(struct ctcmac_private *priv);
+static void ctcmac_hw_init(struct ctcmac_private *priv) ;
+static int ctcmac_set_ffe(struct ctcmac_private *priv, u16 coefficient[]);
+static int ctcmac_get_ffe(struct ctcmac_private *priv, u16 coefficient[]);
+static spinlock_t global_reglock __aligned(SMP_CACHE_BYTES);
+static int g_reglock_init_done = 0;
+static int g_mac_unit_init_done=0;
+static struct regmap *regmap_base;
+static struct ctcmac_pkt_stats g_pkt_stats[2];
+
+static const char ctc_stat_gstrings[][ETH_GSTRING_LEN] = {
+	"RX-bytes-good-ucast",
+	"RX-frame-good-ucast",
+	"RX-bytes-good-mcast",
+	"RX-frame-good-mcast",
+	"RX-bytes-good-bcast",
+	"RX-frame-good-bcast",
+	"RX-bytes-good-pause",
+	"RX-frame-good-pause",
+	"RX-bytes-good-pfc",
+	"RX-frame-good-pfc",  
+	"RX-bytes-good-control",
+	"RX-frame-good-control",
+	"RX-bytes-fcs-error",
+	"RX-frame-fcs-error",
+	"RX-bytes-mac-overrun",
+	"RX-frame-mac-overrun",
+	"RX-bytes-good-63B",
+	"RX-frame-good-63B",
+	"RX-bytes-bad-63B", 
+	"RX-frame-bad-63B",
+	"RX-bytes",
+	"RX-frame",
+	"RX-bytes-bad",
+	"RX-frame-bad",
+	"RX-bytes-good-jumbo",
+	"RX-frame-good-jumbo",
+	"RX-bytes-bad-jumbo", 
+	"RX-frame-bad-jumbo", 
+	"RX-bytes-64B",       
+	"RX-frame-64B",       
+	"RX-bytes-127B",      
+	"RX-frame-127B",      
+	"RX-bytes-255B",      
+	"RX-frame-255B",      
+	"RX-bytes-511B",      
+	"RX-frame-511B",      
+	"RX-bytes-1023B",     
+	"RX-frame-1023B",     
+	"RX-bytes",       
+	"RX-frame",
+	"TX-bytes-ucast",    
+	"TX-frame-ucast",    
+	"TX-bytes-mcast",    
+	"TX-frame-mcast",   
+	"TX-bytes-bcast",    
+	"TX-frame-bcast",    
+	"TX-bytes-pause",    
+	"TX-frame-pause",   
+	"TX-bytes-control",  
+	"TX-frame-control",  
+	"TX-bytes-fcs-error",
+	"TX-frame-fcs-error",
+	"TX-bytes-underrun",
+	"TX-frame-underrun",
+	"TX-bytes-63B",      
+	"TX-frame-63B",      
+	"TX-bytes-64B",      
+	"TX-frame-64B",      
+	"TX-bytes-127B",     
+	"TX-frame-127B",     
+	"TX-bytes-255B",     
+	"TX-frame-255B",     
+	"TX-bytes-511B",     
+	"TX-frame-511B",     
+	"TX-bytes-1023B",   
+	"TX-frame-1023B",   
+	"TX-bytes-mtu1",
+	"TX-frame-mtu1",
+	"TX-bytes-mtu2",
+	"TX-frame-mtu2",
+	"TX-bytes-jumbo",   
+	"TX-frame-jumbo",
+	"mtu1",
+	"mtu2",   
+};
+static void clrsetbits(unsigned __iomem *addr, u32 clr, u32 set)
+{
+	writel((readl(addr) & ~(clr)) | (set) , addr);
+}
+
+static inline u32 ctcmac_regr(unsigned __iomem *addr)
+{
+	u32 val;
+	val = readl(addr);
+	return val;
+}
+
+static inline void ctcmac_regw(unsigned __iomem *addr, u32 val)
+{
+	writel(val, addr);
+}
+
+static inline int ctcmac_rxbd_unused(struct ctcmac_priv_rx_q *rxq)
+{
+	/* left one rx desc unused */
+	if (rxq->next_to_clean > rxq->next_to_use)
+		return rxq->next_to_clean - rxq->next_to_use - 1;
+
+	return rxq->rx_ring_size + rxq->next_to_clean - rxq->next_to_use - 1;
+}
+
+static int ctcmac_alloc_tx_queues(struct ctcmac_private *priv)
+{
+	int i;
+
+	for (i = 0; i < priv->num_tx_queues; i++) {
+		priv->tx_queue[i] = kzalloc(sizeof(struct ctcmac_priv_tx_q),
+			GFP_KERNEL);
+		if (!priv->tx_queue[i])
+			return -ENOMEM;
+
+		priv->tx_queue[i]->tx_skbuff = NULL;
+		priv->tx_queue[i]->qindex = i;
+		priv->tx_queue[i]->dev = priv->ndev;
+		spin_lock_init(&(priv->tx_queue[i]->txlock));
+	}
+	return 0;
+}
+
+static int ctcmac_alloc_rx_queues(struct ctcmac_private *priv)
+{
+	int i;
+
+	for (i = 0; i < priv->num_rx_queues; i++) {
+		priv->rx_queue[i] = kzalloc(sizeof(struct ctcmac_priv_rx_q),
+			GFP_KERNEL);
+		if (!priv->rx_queue[i])
+			return -ENOMEM;
+
+		priv->rx_queue[i]->qindex = i;
+		priv->rx_queue[i]->ndev = priv->ndev;
+	}
+	return 0;
+}
+
+static void ctcmac_unmap_io_space(struct ctcmac_private *priv)
+{
+	if(priv->iobase)
+		iounmap(priv->iobase);
+}
+
+static void ctcmac_free_tx_queues(struct ctcmac_private *priv)
+{
+	int i;
+
+	for (i = 0; i < priv->num_tx_queues; i++){
+		if(priv->tx_queue[i])
+			kfree(priv->tx_queue[i]);
+	}   
+}
+
+static void ctcmac_free_rx_queues(struct ctcmac_private *priv)
+{
+	int i;
+
+	for (i = 0; i < priv->num_rx_queues; i++){
+		if(priv->rx_queue[i])
+			kfree(priv->rx_queue[i]);
+	}
+}
+
+static void ctcmac_free_dev(struct ctcmac_private *priv)
+{
+	if(priv->ndev)
+		free_netdev(priv->ndev);
+}
+
+static int ctcmac_fixed_phy_link_update(struct net_device *dev,
+					  struct fixed_phy_status *status)
+{
+	u32 mon=0;
+	struct ctcmac_private *priv;
+
+	if(!dev)
+		return 0;
+	
+	priv = netdev_priv(dev);
+
+	if (priv->interface != PHY_INTERFACE_MODE_SGMII)
+		return 0;
+	
+	mon = readl(&priv->cpumac_reg->CpuMacSgmiiMon[0]);
+	if(priv->autoneg_mode == CTCMAC_AUTONEG_DISABLE){
+		if((mon & 0x100) == 0x100)
+			status->link = 1;
+		else
+			status->link = 0;
+		
+	}else{
+		if((mon & CSM_ANST_MASK) == 6)
+			status->link = 1;
+		else
+			status->link = 0;
+	}
+
+	return 0;
+}
+ 
+static int ctcmac_of_init(struct platform_device *ofdev, struct net_device **pdev)
+{
+	int err = 0, index;
+	const char *ctype, *automode;
+	struct net_device *dev = NULL;
+	struct ctcmac_private *priv = NULL;
+	unsigned int num_tx_qs, num_rx_qs;
+	struct device_node *np = ofdev->dev.of_node;
+
+	num_tx_qs = CTCMAC_TX_QUEUE_MAX;
+	num_rx_qs = CTCMAC_RX_QUEUE_MAX;
+
+	*pdev = alloc_etherdev_mq(sizeof(*priv), num_tx_qs);
+	dev = *pdev;
+	if (NULL == dev)
+		return -ENOMEM;
+
+	priv = netdev_priv(dev);
+	priv->ndev = dev;
+	priv->ofdev = ofdev;
+	priv->dev = &ofdev->dev;
+	priv->dev->coherent_dma_mask = DMA_BIT_MASK(64);
+	priv->num_tx_queues = num_tx_qs;
+	netif_set_real_num_rx_queues(dev, num_rx_qs);
+	priv->num_rx_queues = num_rx_qs;
+
+	if(ctcmac_alloc_tx_queues(priv))
+		goto fail;
+
+	if(ctcmac_alloc_rx_queues(priv))
+		goto fail;
+
+	/* init cpumac_reg/cpumac_mem/cpumac_unit address */
+	priv->iobase = of_iomap(np, 0);
+	priv->cpumac_reg = priv->iobase + CPUMAC_REG_BASE;
+	priv->cpumac_mem = priv->iobase + CPUMAC_MEM_BASE;
+	priv->cpumacu_reg = of_iomap(np, 1) + CPUMACUNIT_REG_BASE;
+
+	/* Get CpuMac index */
+	err = of_property_read_u32(np, "index", &index);
+	if((err == 0))
+		priv->index = index;
+	else
+		priv->index = 0;
+
+	/* Get interface type, CTC5236 only support PHY_INTERFACE_MODE_SGMII */
+	err = of_property_read_string(np, "phy-connection-type", &ctype);
+	if((err == 0) && !strncmp(ctype, "mii", 3)){
+		priv->interface = PHY_INTERFACE_MODE_MII;
+		priv->supported = SUPPORTED_10baseT_Full;
+	}else{
+		priv->interface = PHY_INTERFACE_MODE_SGMII;
+		priv->supported = CTCMAC_SUPPORTED;
+	}
+
+	err = of_property_read_string(np, "auto-nego-mode", &automode);
+	if((err == 0) && !strncmp(automode, "disable", 7)){
+		priv->autoneg_mode = CTCMAC_AUTONEG_DISABLE;
+	}else if((err == 0) && !strncmp(automode, "sgmii-mac", 9)){
+		priv->autoneg_mode = CTCMAC_AUTONEG_MAC_M;
+	}else if((err == 0) && !strncmp(automode, "sgmii-phy", 9)){
+		priv->autoneg_mode = CTCMAC_AUTONEG_PHY_M;
+	}else if((err == 0) && !strncmp(automode, "1000base-x", 10)){
+		priv->autoneg_mode = CTCMAC_AUTONEG_1000BASEX_M;
+	}else{
+		priv->autoneg_mode = CTCMAC_AUTONEG_MAC_M;
+	}
+	
+	priv->phy_node = of_parse_phandle(np, "phy-handle", 0);
+	/* In the case of a fixed PHY, the DT node associated
+	 * to the PHY is the Ethernet MAC DT node.
+	 */
+	if (!priv->phy_node && of_phy_is_fixed_link(np)) {
+		err = of_phy_register_fixed_link(np);
+		if (err)
+			return -1;
+
+		priv->phy_node = of_node_get(np);
+	}
+	/* mapping from hw irq to sw irq */
+	priv->irqinfo[CTCMAC_NORMAL].irq = irq_of_parse_and_map(np, 0);
+	priv->irqinfo[CTCMAC_FUNC].irq = irq_of_parse_and_map(np, 1);
+
+	return 0;
+    
+fail:
+	ctcmac_unmap_io_space(priv);
+	ctcmac_free_tx_queues(priv);
+	ctcmac_free_rx_queues(priv);
+	ctcmac_free_dev(priv);
+
+	return -1;
+}
+
+int startup_ctcmac(struct net_device *ndev)
+{
+	struct ctcmac_private *priv = netdev_priv(ndev);
+	int err;
+
+	ctcmac_hw_init(priv);
+
+	err = ctcmac_alloc_skb_resources(ndev);
+	if (err)
+		return err;
+
+	smp_mb__before_atomic();
+	clear_bit(CTCMAC_DOWN, &priv->state);
+	smp_mb__after_atomic();
+
+	cpumac_start(priv);
+	/* force link state update after mac reset */
+	priv->oldlink = 0;
+	priv->oldspeed = 0;
+	priv->oldduplex = -1;
+
+	phy_start(ndev->phydev);
+
+	napi_enable(&priv->napi_rx);
+	napi_enable(&priv->napi_tx);
+	    
+	netif_tx_wake_all_queues(ndev);
+
+	return 0;
+}
+
+void stop_ctcmac(struct net_device *ndev)
+{
+	struct ctcmac_private *priv = netdev_priv(ndev);
+
+	/* disable ints and gracefully shut down Rx/Tx DMA */
+	cpumac_halt(priv);	
+
+	netif_tx_stop_all_queues(ndev);
+
+	smp_mb__before_atomic();
+	set_bit(CTCMAC_DOWN, &priv->state);
+	smp_mb__after_atomic();
+	napi_disable(&priv->napi_rx);
+	napi_disable(&priv->napi_tx);
+	phy_stop(ndev->phydev);
+	ctcmac_free_skb_resources(priv);
+}
+
+static void ctcmac_reset(struct net_device *ndev)
+{    
+	struct ctcmac_private *priv = netdev_priv(ndev);
+	while (test_and_set_bit_lock(CTCMAC_RESETTING, &priv->state))
+		cpu_relax();
+
+	stop_ctcmac(ndev);    
+	startup_ctcmac(ndev);    
+	clear_bit_unlock(CTCMAC_RESETTING, &priv->state);
+}
+
+/* ctcmac_reset_task gets scheduled when a packet has not been
+ * transmitted after a set amount of time.
+ * For now, assume that clearing out all the structures, and
+ * starting over will fix the problem.
+ */
+static void ctcmac_reset_task(struct work_struct *work)
+{
+	struct ctcmac_private *priv = container_of(work, struct ctcmac_private,
+						 reset_task);
+	ctcmac_reset(priv->ndev);
+}
+
+/* get the rxdesc number that was used by CpuMac but has not been handled by CPU */
+static int ctcmac_rxbd_recycle(struct ctcmac_private *priv, int qidx)
+{
+	u32 count;
+
+	if(qidx){
+		count = readl(&priv->cpumac_reg->CpuMacDescMon[2]);
+		return count & 0xffff;
+	}
+
+	count = readl(&priv->cpumac_reg->CpuMacDescMon[1]);
+
+	return (count >> 16 ) & 0xffff;
+}
+
+static int ctcmac_rxbd_usable(struct ctcmac_private *priv, int qidx)
+{
+	return (readl(&priv->cpumac_reg->CpuMacDescMon[0])>>(qidx*16)) & 0xffff;
+}
+
+/* get the txdesc number that was used by CpuMac but has not been handled by CPU */
+static int ctcmac_txbd_used_untreated(struct ctcmac_private *priv)
+{
+	u32 count;
+
+	count = readl(&priv->cpumac_reg->CpuMacDescMon[2]);
+
+	return (count >> 16 ) & 0xffff;
+}
+
+/* Add rx buffer data to skb fragment */
+static bool ctcmac_add_rx_frag(struct ctcmac_rx_buff *rxb, u32 lstatus,
+			     struct sk_buff *skb, bool first)
+{
+	struct page *page = rxb->page;
+	unsigned int size = (lstatus & CPU_MAC_DESC_INTF_W1_DESC_SIZE_MASK)>>8;
+
+	/* Remove the CRC from the packet length */
+	if (lstatus & CPU_MAC_DESC_INTF_W1_DESC_EOP)
+		size -= 4;
+	
+	if (likely(first)) {
+		skb_put(skb, size);
+	} else {
+		skb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page,
+			rxb->page_offset, size, CTCMAC_RXB_TRUESIZE);
+	}
+
+	/* try reuse page */
+	if (unlikely(page_count(page) != 1))
+	return false;
+
+	/* change offset to the other half */
+	rxb->page_offset ^= CTCMAC_RXB_TRUESIZE;
+
+	page_ref_inc(page);
+
+	return true;
+}
+
+/* Reused page that has been release by CPU */
+static void ctcmac_reuse_rx_page(struct ctcmac_priv_rx_q *rxq,
+			       struct ctcmac_rx_buff *old_rxb)
+{
+	struct ctcmac_rx_buff *new_rxb;
+	u16 nta = rxq->next_to_alloc;
+
+	new_rxb = &rxq->rx_buff[nta];
+
+	/* find next buf that can reuse a page */
+	nta++;
+	rxq->next_to_alloc = (nta < rxq->rx_ring_size) ? nta : 0;
+
+	/* copy page reference */
+	*new_rxb = *old_rxb;
+
+	/* sync for use by the device */
+	dma_sync_single_range_for_device(rxq->dev, old_rxb->dma,
+					 old_rxb->page_offset,
+					 CTCMAC_RXB_TRUESIZE, DMA_FROM_DEVICE);
+}
+
+/* Handle the rx buffer that has been used by CpuMac */
+static struct sk_buff *ctcmac_get_next_rxbuff(struct ctcmac_priv_rx_q *rx_queue,
+					    u32 lstatus, struct sk_buff *skb)
+{
+	struct ctcmac_rx_buff *rxb = &rx_queue->rx_buff[rx_queue->next_to_clean];
+	struct page *page = rxb->page;
+	bool first = false;
+
+	if (likely(!skb)) {
+		void *buff_addr = page_address(page) + rxb->page_offset;
+		skb = build_skb(buff_addr, CTCMAC_SKBFRAG_SIZE);
+		if (unlikely(!skb)) {
+			return NULL;
+		}
+		first = true;
+	}
+
+	dma_sync_single_range_for_cpu(rx_queue->dev, rxb->dma, rxb->page_offset,
+	CTCMAC_RXB_TRUESIZE, DMA_FROM_DEVICE);
+
+	if (ctcmac_add_rx_frag(rxb, lstatus, skb, first)) {
+	/* reuse the free half of the page */
+		ctcmac_reuse_rx_page(rx_queue, rxb);
+	} else {
+		/* page cannot be reused, unmap it */
+		dma_unmap_page(rx_queue->dev, rxb->dma,
+		PAGE_SIZE, DMA_FROM_DEVICE);
+	}
+
+	/* clear rxb content */
+	rxb->page = NULL;
+
+	return skb;
+}
+
+static void ctcmac_process_frame(struct net_device *ndev, struct sk_buff *skb)
+{
+	skb->protocol = eth_type_trans(skb, ndev);
+}
+
+/* serdes init flow */
+static int ctc_mac_serdes_init(struct ctcmac_private *priv)
+{
+	int ret=0;
+	u32 status;
+	int delay_ms = 10;
+	
+	/* reset serdes */
+	writel(0x83806000, &priv->cpumacu_reg->CpuMacUnitHssCfg[0]);
+	writel(0x28061800, &priv->cpumacu_reg->CpuMacUnitHssCfg[2]);
+	writel(0x0026c03a, &priv->cpumacu_reg->CpuMacUnitHssCfg[6]);
+	writel(0x28061810, &priv->cpumacu_reg->CpuMacUnitHssCfg[8]);
+	writel(0x0026c03a, &priv->cpumacu_reg->CpuMacUnitHssCfg[12]);
+
+	/* offset0 bit1 BlkRstN */
+	writel(0x83806002, &priv->cpumacu_reg->CpuMacUnitHssCfg[0]);
+	mdelay(delay_ms);
+
+	writel(0x80002309, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x80000842, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x8000ea45, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+
+	/* serdes 0 init */
+	writel(0x83000a05, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x83002008, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x8300640f, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x83000214, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x83008015, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x83000116, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x83001817, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x83003018, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x83000e24, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x83008226, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x83001f27, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x83002028, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x83002829, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x8300302a, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x83002038, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x8300223a, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x8300523b, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x83002040, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x8300f141, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x8300014a, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x8300e693, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+
+	/* serdes 1 init */
+	writel(0x84000a05, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x84002008, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x8400640f, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x84000214, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x84008015, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x84000116, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x84001817, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x84003018, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x84000e24, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x84008226, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x84001f27, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x84002028, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x84002829, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x8400302a, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x84002038, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x8400223a, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x8400523b, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x84002040, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x8400f141, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x8400014a, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x8400e693, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+
+	/* serdes post release */
+	writel(0x83806003, &priv->cpumacu_reg->CpuMacUnitHssCfg[0]);
+	writel(0x83826003, &priv->cpumacu_reg->CpuMacUnitHssCfg[0]);
+	
+	writel(0x28061801, &priv->cpumacu_reg->CpuMacUnitHssCfg[2]);
+	writel(0x28061c01, &priv->cpumacu_reg->CpuMacUnitHssCfg[2]);
+	writel(0x28071c01, &priv->cpumacu_reg->CpuMacUnitHssCfg[2]);
+	
+	writel(0x28061811, &priv->cpumacu_reg->CpuMacUnitHssCfg[8]);
+	writel(0x28061c11, &priv->cpumacu_reg->CpuMacUnitHssCfg[8]);
+	writel(0x28071c11, &priv->cpumacu_reg->CpuMacUnitHssCfg[8]);
+
+	ret = readl_poll_timeout(&priv->cpumacu_reg->CpuMacUnitHssMon[1], status, 
+		status & CPU_MAC_UNIT_HSS_MON_W1_MON_HSS_L0_DFE_RST_DONE, 1000, 2000000);
+	if(ret){
+		netdev_dbg(priv->ndev,"%s:wait for hss reset done fail with CpuMacUnitHssMon[1]:0x%x\n", 
+			priv->ndev->name, readl(&priv->cpumacu_reg->CpuMacUnitHssMon[1]));
+	}
+	mdelay(delay_ms);
+
+	return 0;
+}
+
+#if 0
+static int ctcmac_init_mac_filter(struct ctcmac_private *priv)
+{
+	/* broadcast mac address match */
+	writel(0xffffffff, &priv->cpumacu_reg->CpuMacUnitMacCamCfg[0]);
+	writel(0x0000ffff, &priv->cpumacu_reg->CpuMacUnitMacCamCfg[1]);
+	writel(0x00000000, &priv->cpumacu_reg->CpuMacUnitMacCamCfg[16]);
+	writel(0x00000000, &priv->cpumacu_reg->CpuMacUnitMacCamCfg[17]);
+	/* reserved for unicast */
+	writel(0x00000000, &priv->cpumacu_reg->CpuMacUnitMacCamCfg[2]);
+	writel(0x00000000, &priv->cpumacu_reg->CpuMacUnitMacCamCfg[3]);
+	writel(0x00000000, &priv->cpumacu_reg->CpuMacUnitMacCamCfg[18]);
+	writel(0x00000000, &priv->cpumacu_reg->CpuMacUnitMacCamCfg[19]);
+	
+	/* enable mac filter */
+	clrsetbits(&priv->cpumacu_reg->CpuMacUnitFilterCfg[0], 
+		CPU_MAC_UNIT_FILTER_CFG_W0_CFG_MAC_ADDR_IS_SA0, 0);
+	clrsetbits(&priv->cpumacu_reg->CpuMacUnitFilterCfg[0], 
+		CPU_MAC_UNIT_FILTER_CFG_W0_CFG_MAC_ADDR_IS_SA1, 0);
+	clrsetbits(&priv->cpumacu_reg->CpuMacUnitFilterCfg[0], 
+		CPU_MAC_UNIT_FILTER_CFG_W0_CFG_MAC_CAM_IS_BLACK_LIST, 0);
+	clrsetbits(&priv->cpumacu_reg->CpuMacUnitFilterCfg[0], 0, 
+		CPU_MAC_UNIT_FILTER_CFG_W0_CFG_MAC_FILTER_EN);
+
+	return 0;
+}
+#endif
+
+/* Hardware init flow */
+static void ctcmac_hw_init(struct ctcmac_private *priv)
+{
+	int i;
+	u32 val;
+	int use_extram = 0;
+
+	/* two cpumac access the same cpumac unit register */
+	spin_lock_irq(&global_reglock);   
+	if(priv->index == 0){
+		/* release CpuMac0 */
+		clrsetbits(&priv->cpumacu_reg->CpuMacUnitResetCtl, 
+		    CPU_MAC_UNIT_RESET_CTL_W0_RESET_CORE_BASE, CPU_MAC_UNIT_RESET_CTL_W0_RESET_CORE_CPU_MAC0);
+		clrsetbits(&priv->cpumacu_reg->CpuMacUnitResetCtl, 
+		    CPU_MAC_UNIT_RESET_CTL_W0_RESET_CORE_CPU_MAC0, 0);
+	}else{
+		/* release CpuMac0 */
+		clrsetbits(&priv->cpumacu_reg->CpuMacUnitResetCtl, 
+		    CPU_MAC_UNIT_RESET_CTL_W0_RESET_CORE_BASE, CPU_MAC_UNIT_RESET_CTL_W0_RESET_CORE_CPU_MAC1);
+		clrsetbits(&priv->cpumacu_reg->CpuMacUnitResetCtl, 
+		    CPU_MAC_UNIT_RESET_CTL_W0_RESET_CORE_CPU_MAC1, 0);
+	}
+
+	clrsetbits(&priv->cpumacu_reg->CpuMacUnitTsCfg, 
+	            0, CPU_MAC_UNIT_TS_CFG_W0_CFG_FORCE_S_AND_NS_EN);
+
+	spin_unlock_irq(&global_reglock);
+	mdelay(10);
+
+	/* init CpuMac */
+	clrsetbits(&priv->cpumac_reg->CpuMacInit, 0, CPU_MAC_INIT_DONE_W0_INIT_DONE);
+	udelay(1);
+	
+	if (priv->interface == PHY_INTERFACE_MODE_SGMII){
+		/* switch to sgmii and enable auto nego */
+		val = readl(&priv->cpumac_reg->CpuMacSgmiiAutoNegCfg);
+		val &= ~(CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_AN_ENABLE_MASK
+		              | CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_AN_MODE_MASK);
+		val |= (CSA_SGMII_MD_MASK | CSA_EN);
+		writel(val, &priv->cpumac_reg->CpuMacSgmiiAutoNegCfg);
+	}
+
+	if(priv->autoneg_mode == CTCMAC_AUTONEG_DISABLE){
+		clrsetbits(&priv->cpumac_reg->CpuMacSgmiiAutoNegCfg, 
+			CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_AN_ENABLE, 0);
+		
+	}else{
+		val = readl(&priv->cpumac_reg->CpuMacSgmiiAutoNegCfg);
+		val &= ~CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_AN_MODE_MASK;
+		val |= (priv->autoneg_mode<<2 | CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_AN_ENABLE);
+		writel(val, &priv->cpumac_reg->CpuMacSgmiiAutoNegCfg);
+	}
+	/* disable rx link filter */
+	clrsetbits(&priv->cpumac_reg->CpuMacSgmiiCfg[0], 
+	    CPU_MAC_SGMII_CFG_W0_CFG_MII_RX_LINK_FILTER_EN, 0);
+	/* ignore tx event */
+	clrsetbits(&priv->cpumac_reg->CpuMacSgmiiCfg[0], 
+	    0, CPU_MAC_SGMII_CFG_W0_CFG_TX_EVEN_IGNORE);
+
+	clrsetbits(&priv->cpumac_reg->CpuMacAxiCfg, 
+	    0, CPU_MAC_AXI_CFG_W0_CFG_AXI_RD_D_WORD_SWAP_EN);
+	clrsetbits(&priv->cpumac_reg->CpuMacAxiCfg, 
+	    0, CPU_MAC_AXI_CFG_W0_CFG_AXI_WR_D_WORD_SWAP_EN);
+
+	/* drop over size packet */
+	clrsetbits(&priv->cpumac_reg->CpuMacGmacCfg[0], 
+	    0, CPU_MAC_GMAC_CFG_W0_CFG_RX_OVERRUN_DROP_EN
+	        |CPU_MAC_GMAC_CFG_W0_CFG_RX_OVERSIZE_DROP_EN);
+
+	/* not strip 4B crc when send packet  */
+	clrsetbits(&priv->cpumac_reg->CpuMacGmacCfg[2], 
+	    CPU_MAC_GMAC_CFG_W2_CFG_TX_STRIP_CRC_EN, 0);
+
+	/* enable cut-through mode */
+	clrsetbits(&priv->cpumac_reg->CpuMacGmacCfg[2], 
+	    0, CPU_MAC_GMAC_CFG_W2_CFG_TX_CUT_THROUGH_EN);
+    
+	for (i = 0; i < priv->num_tx_queues; i++) {
+		if(priv->tx_queue[i]->tx_ring_size > CTCMAC_INTERNAL_RING_SIZE){
+			use_extram = 1;
+			break;
+		}
+	}
+
+	for (i = 0; i < priv->num_rx_queues; i++) {
+		if(priv->rx_queue[i]->rx_ring_size > CTCMAC_INTERNAL_RING_SIZE){
+			use_extram = 1;
+			break;
+		}
+	}
+        
+	if(use_extram){
+		spin_lock_irq(&global_reglock); 
+		/* enable external SRAM to store rx/tx desc, support max 1023*3 desc */
+		regmap_read(regmap_base, offsetof(struct SysCtl_regs, SysMemCtl), &val);
+		val |= SYS_MEM_CTL_W0_CFG_RAM_MUX_EN;
+		regmap_write(regmap_base, offsetof(struct SysCtl_regs, SysMemCtl), val);
+		spin_unlock_irq(&global_reglock); 
+		
+		if(priv->index == 0){
+			ctcmac_regw(&priv->cpumac_reg->CpuMacExtRamCfg[1], CTCMAC0_EXSRAM_BASE);
+		}else{
+			ctcmac_regw(&priv->cpumac_reg->CpuMacExtRamCfg[1], CTCMAC1_EXSRAM_BASE);
+		}
+		ctcmac_regw(&priv->cpumac_reg->CpuMacExtRamCfg[0], CTCMAC_TX_RING_SIZE);
+		clrsetbits(&priv->cpumac_reg->CpuMacExtRamCfg[0], 
+			0, CPU_MAC_EXT_RAM_CFG_W0_CFG_EXT_RAM_EN);
+	}else{
+		/* disable external SRAM to store rx/tx desc, support max 64*3 desc */
+		clrsetbits(&priv->cpumac_reg->CpuMacExtRamCfg[0], 
+		    CPU_MAC_EXT_RAM_CFG_W0_CFG_EXT_RAM_EN, 0);
+		spin_lock_irq(&global_reglock); 
+		
+		regmap_read(regmap_base, offsetof(struct SysCtl_regs, SysMemCtl), &val);
+		val &= ~SYS_MEM_CTL_W0_CFG_RAM_MUX_EN;
+		regmap_write(regmap_base, offsetof(struct SysCtl_regs, SysMemCtl), val);
+		spin_unlock_irq(&global_reglock); 
+	}
+
+	if(priv->int_type == CTCMAC_INT_DESC){
+			val = CPU_MAC_DESC_CFG_W0_CFG_TX_DESC_ACK_EN			
+			|(CTCMAC_DESC_INT_NUM<<16)
+			|(CTCMAC_DESC_INT_NUM<<8)
+			|(CTCMAC_DESC_INT_NUM<<0);
+		ctcmac_regw(&priv->cpumac_reg->CpuMacDescCfg[0], val);
+	}else{
+		val = CPU_MAC_DESC_CFG_W0_CFG_TX_DESC_DONE_INTR_EOP_EN
+			|CPU_MAC_DESC_CFG_W0_CFG_RX_DESC_DONE_INTR_EOP_EN
+			|CPU_MAC_DESC_CFG_W0_CFG_TX_DESC_ACK_EN;
+		ctcmac_regw(&priv->cpumac_reg->CpuMacDescCfg[0], val);
+	}
+	
+	/* clear all interrupt */
+	ctcmac_regw(&priv->cpumac_reg->CpuMacInterruptFunc[1], 0xffffffff);
+	ctcmac_regw(&priv->cpumac_reg->CpuMacInterruptNormal[1], 0xffffffff);
+	/* mask all interrupt */
+	ctcmac_regw(&priv->cpumac_reg->CpuMacInterruptFunc[2], 0xffffffff);
+	ctcmac_regw(&priv->cpumac_reg->CpuMacInterruptNormal[2], 0xffffffff);
+
+#if 0
+	if (!(priv->ndev->flags & IFF_PROMISC)){
+		ctcmac_init_mac_filter(priv);
+	}
+#endif
+    
+}
+
+static int ctcmac_wait_for_linkup(struct ctcmac_private *priv)
+{
+	int timeout=3000;
+	u32 mon=0;
+	
+	if(priv->autoneg_mode == CTCMAC_AUTONEG_DISABLE){
+		/* wait for linkup */
+		while(timeout--){
+			mon = readl(&priv->cpumac_reg->CpuMacSgmiiMon[0]);
+			if((mon & 0x100) == 0x100){
+				break;
+			}
+
+			mdelay(1);
+		}
+		if((mon & 0x100) != 0x100)
+		{
+			printk("Error! when phy link up, link status %d is not right.\n", mon);
+			return -1;
+		}
+		
+	}else{
+		/* wait for sgmii auto nego complete */
+		while(timeout--){
+			mon = readl(&priv->cpumac_reg->CpuMacSgmiiMon[0]);
+			if((mon & CSM_ANST_MASK) == 6){
+				break;
+			}
+
+			mdelay(1);
+		}
+		
+		if((mon & CSM_ANST_MASK) != 6)
+		{
+			printk("Error! when phy link up, auto-neg status %d is not right.\n", mon);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+/* update cpumac speed when phy linkup speed changed */
+static noinline void ctcmac_update_link_state(struct ctcmac_private *priv, struct phy_device *phydev)
+{
+	u32 cfg_rep, cfg_smp;
+	int speed = phydev->speed;
+
+
+	if (priv->interface != PHY_INTERFACE_MODE_SGMII)
+		return ;
+
+	if(netif_msg_link(priv)){
+		netdev_dbg(priv->ndev,"link up speed is %d\n", speed);
+	}
+
+	if (phydev->link) {
+		cfg_rep = readl(&priv->cpumac_reg->CpuMacSgmiiCfg[0]);
+		cfg_smp = readl(&priv->cpumac_reg->CpuMacSgmiiCfg[1]);
+		cfg_rep &= ~CSC_REP_MASK;
+		cfg_smp &= ~CSC_SMP_MASK;
+		if(speed == 1000){        
+			cfg_rep |= CSC_1000M;
+			cfg_smp |= CSC_1000M;
+		}
+		else if(speed == 100){
+			cfg_rep |= CSC_100M;
+			cfg_smp |= CSC_100M;
+		}
+		else if(speed == 10){
+			cfg_rep |= CSC_10M;
+			cfg_smp |= CSC_10M;
+		}
+		else{
+			return;
+		}
+		writel(cfg_rep, &priv->cpumac_reg->CpuMacSgmiiCfg[0]);
+		writel(cfg_smp, &priv->cpumac_reg->CpuMacSgmiiCfg[1]);
+
+		ctcmac_wait_for_linkup(priv);
+		
+		if (!priv->oldlink)
+			priv->oldlink = 1;
+		
+	}else{
+		priv->oldlink = 0;
+		priv->oldspeed = 0;
+		priv->oldduplex = -1;
+	}
+
+	
+	return;
+}
+
+static void adjust_link(struct net_device *dev)
+{
+	struct ctcmac_private *priv = netdev_priv(dev);
+	struct phy_device *phydev = dev->phydev;
+
+	if (unlikely(phydev->link != priv->oldlink ||
+		     (phydev->link && (phydev->duplex != priv->oldduplex ||
+				       phydev->speed != priv->oldspeed))))
+	ctcmac_update_link_state(priv, phydev);
+}
+
+/* Initializes driver's PHY state, and attaches to the PHY.
+ * Returns 0 on success.
+ */
+static int ctcmac_init_phy(struct net_device *dev)
+{
+	int err;
+	struct ctcmac_private *priv = netdev_priv(dev);
+	phy_interface_t interface;
+	struct phy_device *phydev;
+
+	priv->oldlink = 0;
+	priv->oldspeed = 0;
+	priv->oldduplex = -1;
+
+	interface = priv->interface;
+
+	phydev = of_phy_connect(dev, priv->phy_node, &adjust_link, 0,
+				interface);
+	if (!phydev) {
+		dev_err(&dev->dev, "could not attach to PHY\n");
+		return -ENODEV;
+	}
+	if (of_phy_is_fixed_link(priv->phy_node)) {
+		err = fixed_phy_set_link_update(dev->phydev,
+					  ctcmac_fixed_phy_link_update);
+		if(err)
+			dev_err(&priv->ndev->dev, "Set link update fail!\n");
+	}
+
+	/* Remove any features not supported by the controller */
+	phydev->supported &= priv->supported;
+	phydev->advertising = phydev->supported;
+
+	return 0;
+}
+
+static irqreturn_t ctcmac_receive(int irq, struct ctcmac_private *priv)
+{
+	unsigned long flags;
+
+	if (likely(napi_schedule_prep(&priv->napi_rx))) {
+		/* disable interrupt */
+		spin_lock_irqsave(&priv->reglock, flags);
+		writel(CTCMAC_NOR_RX0_D|CTCMAC_NOR_RX1_D, &priv->cpumac_reg->CpuMacInterruptFunc[2]);
+		spin_unlock_irqrestore(&priv->reglock, flags);
+		__napi_schedule(&priv->napi_rx);
+	} else {
+		/* clear interrupt */
+		writel(CTCMAC_NOR_RX0_D|CTCMAC_NOR_RX1_D, &priv->cpumac_reg->CpuMacInterruptFunc[1]);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t ctcmac_transmit(int irq, struct ctcmac_private *priv)
+{
+	unsigned long flags;
+
+	if (likely(napi_schedule_prep(&priv->napi_tx))) {
+		/* disable interrupt */
+		spin_lock_irqsave(&priv->reglock, flags);
+		writel(CTCMAC_NOR_TX_D, &priv->cpumac_reg->CpuMacInterruptFunc[2]);
+		spin_unlock_irqrestore(&priv->reglock, flags);
+		__napi_schedule(&priv->napi_tx);
+
+	} else {
+		/* clear interrupt */
+		writel(CTCMAC_NOR_TX_D, &priv->cpumac_reg->CpuMacInterruptFunc[1]);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t ctcmac_func(int irq, void *data)
+{
+	u32 event, stat, mask;
+	struct ctcmac_private *priv = (struct ctcmac_private *)data;
+
+	stat = ctcmac_regr(&priv->cpumac_reg->CpuMacInterruptFunc[0]);
+	mask = ctcmac_regr(&priv->cpumac_reg->CpuMacInterruptFunc[2]);
+	event = stat & ~mask;
+
+	if(netif_msg_intr(priv)){
+		netdev_dbg(priv->ndev,"function interrupt stat 0x%x mask 0x%x\n", stat, mask);
+	}
+	if((event & CTCMAC_NOR_RX0_D) || (event & CTCMAC_NOR_RX1_D)){
+		ctcmac_receive(irq, priv);
+	}
+
+	if(event & CTCMAC_NOR_TX_D){
+		ctcmac_transmit(irq, priv);
+	}
+
+	return IRQ_HANDLED;
+}
+
+/* not used */
+static irqreturn_t ctcmac_normal(int irq, void *data) //TODO by liuht
+{
+	u32 stat, mask;
+	struct ctcmac_private *priv = (struct ctcmac_private *)data;
+
+	stat = ctcmac_regr(&priv->cpumac_reg->CpuMacInterruptFunc[0]);
+	mask = ctcmac_regr(&priv->cpumac_reg->CpuMacInterruptFunc[2]);
+	
+	if(netif_msg_intr(priv)){
+		netdev_dbg(priv->ndev,"normal interrupt stat 0x%x mask 0x%x\n", stat, mask);
+	}
+	
+	return IRQ_HANDLED;
+}
+
+static int ctcmac_request_irq(struct ctcmac_private *priv)
+{
+	int err = 0;
+
+	err = request_irq(priv->irqinfo[CTCMAC_NORMAL].irq, ctcmac_normal, 0,
+			  priv->irqinfo[CTCMAC_NORMAL].name, priv);
+	if (err < 0) {
+		free_irq(priv->irqinfo[CTCMAC_NORMAL].irq, priv);
+	}
+	enable_irq_wake(priv->irqinfo[CTCMAC_NORMAL].irq);
+
+	err = request_irq(priv->irqinfo[CTCMAC_FUNC].irq, ctcmac_func, 0,
+			  priv->irqinfo[CTCMAC_FUNC].name, priv);
+	if (err < 0) {
+		free_irq(priv->irqinfo[CTCMAC_FUNC].irq, priv);
+	}
+	enable_irq_wake(priv->irqinfo[CTCMAC_FUNC].irq);
+
+	return err;
+}
+
+static void ctcmac_free_irq(struct ctcmac_private *priv)
+{   
+	free_irq(priv->irqinfo[CTCMAC_NORMAL].irq, priv);
+	free_irq(priv->irqinfo[CTCMAC_FUNC].irq, priv);
+}
+
+static bool ctcmac_new_page(struct ctcmac_priv_rx_q *rxq, struct ctcmac_rx_buff *rxb)
+{
+	struct page *page;
+	dma_addr_t addr;
+
+	page = dev_alloc_page();
+	if (unlikely(!page))
+		return false;
+
+	addr = dma_map_page(rxq->dev, page, 0, PAGE_SIZE, DMA_FROM_DEVICE);
+	if (unlikely(dma_mapping_error(rxq->dev, addr))) {
+		__free_page(page);
+
+		return false;
+	}
+
+	rxb->dma = addr;
+	rxb->page = page;
+	rxb->page_offset = 0;
+
+	return true;
+}
+
+static void ctcmac_fill_rxbd(struct ctcmac_private *priv, struct ctcmac_rx_buff *rxb, int qidx)
+{
+	u32 desc_cfg_low, desc_cfg_high;
+	dma_addr_t bufaddr = rxb->dma + rxb->page_offset;
+
+	/* DDR base address is 0 for CpuMac, but is 0x80000000 for CPU */
+	desc_cfg_low = (bufaddr - CTC_DDR_BASE)& CPU_MAC_DESC_INTF_W0_DESC_ADDR_31_0_MASK;
+	/* CPU_MAC_DESC_INTF_W1_DESC_SIZE:bit(8) */
+	desc_cfg_high = (CTCMAC_RXB_SIZE<<8) | 
+	    (((bufaddr- CTC_DDR_BASE) >> 32) & CPU_MAC_DESC_INTF_W1_DESC_ADDR_39_32_MASK);
+
+	spin_lock_irq(&priv->reglock);
+	if(qidx){
+		ctcmac_regw(&priv->cpumac_mem->CpuMacDescIntf1[0], desc_cfg_low);
+		smp_mb__before_atomic();
+		ctcmac_regw(&priv->cpumac_mem->CpuMacDescIntf1[1], desc_cfg_high);
+
+	}else{
+		ctcmac_regw(&priv->cpumac_mem->CpuMacDescIntf0[0], desc_cfg_low);
+		smp_mb__before_atomic();
+		ctcmac_regw(&priv->cpumac_mem->CpuMacDescIntf0[1], desc_cfg_high);
+	}
+
+	spin_unlock_irq(&priv->reglock);
+}
+
+static void ctcmac_fill_txbd(struct ctcmac_private *priv, struct ctcmac_desc_cfg *txdesc)
+{
+	u32 desc_cfg_low, desc_cfg_high;
+
+	desc_cfg_low = txdesc->addr_low;
+	/* CPU_MAC_DESC_INTF_W1_DESC_SIZE:bit(8) */
+	/* CPU_MAC_DESC_INTF_W1_DESC_SOP:bit(22) */
+	/* CPU_MAC_DESC_INTF_W1_DESC_EOP:bit(23) */
+	desc_cfg_high = txdesc->addr_high | 
+	    (txdesc->size << 8) |
+	    (txdesc->sop << 22) | 
+	    (txdesc->eop << 23);
+
+	spin_lock_irq(&priv->reglock);
+	ctcmac_regw(&priv->cpumac_mem->CpuMacDescIntf2[0], desc_cfg_low);
+	smp_mb__before_atomic();
+	ctcmac_regw(&priv->cpumac_mem->CpuMacDescIntf2[1], desc_cfg_high);
+
+	spin_unlock_irq(&priv->reglock);
+}
+
+/* reclaim tx desc */
+static void ctcmac_get_txbd(struct ctcmac_private *priv)
+{
+	u32 lstatus;
+
+	spin_lock_irq(&priv->reglock);
+	lstatus = ctcmac_regr(&priv->cpumac_mem->CpuMacDescIntf2[0]);
+	smp_mb__before_atomic();
+	lstatus = ctcmac_regr(&priv->cpumac_mem->CpuMacDescIntf2[1]);
+	spin_unlock_irq(&priv->reglock);
+}
+
+/* reclaim rx desc */
+static void ctcmac_get_rxbd(struct ctcmac_private *priv, u32 *lstatus, int qidx)
+{    
+	spin_lock_irq(&priv->reglock);
+	if(qidx){
+		ctcmac_regr(&priv->cpumac_mem->CpuMacDescIntf1[0]);
+		*lstatus = ctcmac_regr(&priv->cpumac_mem->CpuMacDescIntf1[1]);
+	}else{
+		ctcmac_regr(&priv->cpumac_mem->CpuMacDescIntf0[0]);
+		*lstatus = ctcmac_regr(&priv->cpumac_mem->CpuMacDescIntf0[1]);
+	}
+	smp_mb__before_atomic();
+	
+	spin_unlock_irq(&priv->reglock);
+}
+
+/* alloc rx buffer for rx desc */
+static void ctcmac_alloc_rx_buffs(struct ctcmac_priv_rx_q *rx_queue,
+				int alloc_cnt)
+{
+    int i, j;
+    int qidx = rx_queue->qindex;
+    struct ctcmac_rx_buff *rxb;
+    struct net_device *ndev = rx_queue->ndev;
+    struct ctcmac_private *priv = netdev_priv(ndev);
+
+	i = rx_queue->next_to_use;
+	j = rx_queue->next_to_alloc;
+	rxb = &rx_queue->rx_buff[i];
+
+	while (alloc_cnt--) {
+		/* if rx buffer is unmapped,  alloc new pages */
+		if (unlikely(!rxb->page)) {
+			if (unlikely(!ctcmac_new_page(rx_queue, rxb))) {
+				break;
+			}
+			if (unlikely(++j == rx_queue->rx_ring_size)) {
+				j = 0;
+			}
+		}
+
+		/* fill rx desc */
+		ctcmac_fill_rxbd(priv, rxb, qidx);
+		rxb++;
+
+		if (unlikely(++i == rx_queue->rx_ring_size)) {
+			i = 0;
+			rxb = rx_queue->rx_buff;
+		}
+	}
+
+	rx_queue->next_to_use = i;
+	rx_queue->next_to_alloc = j;
+}
+
+static void ctcmac_alloc_one_rx_buffs(struct ctcmac_priv_rx_q *rx_queue)
+{
+	int i, j;
+	int qidx = rx_queue->qindex;
+	struct ctcmac_rx_buff *rxb;
+	struct net_device *ndev = rx_queue->ndev;
+	struct ctcmac_private *priv = netdev_priv(ndev);
+
+	i = rx_queue->next_to_use;
+	j = rx_queue->next_to_alloc;
+	rxb = &rx_queue->rx_buff[i];
+	
+	if (unlikely(!rxb->page)) {
+		if (unlikely(!ctcmac_new_page(rx_queue, rxb))) {
+			return;
+		}
+		if (unlikely(++j == rx_queue->rx_ring_size)) {
+			j = 0;
+		}
+	}
+
+	if (unlikely(++i == rx_queue->rx_ring_size)) {
+		i = 0;
+	}
+
+	rx_queue->next_to_use = i;
+	rx_queue->next_to_alloc = j;
+
+	/* fill rx desc */
+	ctcmac_fill_rxbd(priv, rxb, qidx);
+}
+
+#if 0
+static noinline int ctcmac_filter(struct ctcmac_private *priv, struct sk_buff *skb)
+{
+	char b_mac[6]={0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+	
+	ctcmac_dump_mac_addr(skb->head);
+	//ctcmac_dump_mac_addr(priv->ndev->dev_addr);
+	if(strncmp(skb->head, priv->ndev->dev_addr, 6) 
+		&& strncmp(skb->head, b_mac, 6)){
+		printk(KERN_ERR "ctcmac_filter\n");
+		return 1;
+	}
+
+	return 0;
+}
+#endif
+
+static noinline int ctcmac_clean_rx_ring(struct ctcmac_priv_rx_q *rx_queue, int rx_work_limit)
+{
+	struct net_device *ndev = rx_queue->ndev;
+	struct ctcmac_private *priv = netdev_priv(ndev);
+	int i, howmany = 0;
+	struct sk_buff *skb = rx_queue->skb;
+	int cleaned_cnt = ctcmac_rxbd_unused(rx_queue);
+	unsigned int total_bytes = 0, total_pkts = 0;
+	int qidx = rx_queue->qindex;
+	u32 alloc_new;
+	int budget = rx_work_limit;
+
+	/* Get the first full descriptor */
+	i = rx_queue->next_to_clean;
+
+	while (rx_work_limit--) {
+		u32 lstatus;
+
+		if(!rx_queue->pps_limit){
+			if (cleaned_cnt >= CTCMAC_RX_BUFF_ALLOC) {
+				ctcmac_alloc_rx_buffs(rx_queue, cleaned_cnt);
+				cleaned_cnt = 0;
+			}
+		}else{
+			alloc_new = rx_queue->token/CTCMAC_TOKEN_PER_PKT;
+			if ((cleaned_cnt >= CTCMAC_RX_BUFF_ALLOC) && alloc_new) {
+				alloc_new = min(cleaned_cnt, (int)alloc_new);
+				ctcmac_alloc_rx_buffs(rx_queue, alloc_new);
+				rx_queue->token -= CTCMAC_TOKEN_PER_PKT*alloc_new;
+				cleaned_cnt -= alloc_new;
+			}
+		}
+
+		if(ctcmac_rxbd_recycle(priv, qidx)<=0)
+			break;
+
+		ctcmac_get_rxbd(priv, &lstatus, qidx);
+
+		/* fetch next to clean buffer from the ring */
+		skb = ctcmac_get_next_rxbuff(rx_queue, lstatus, skb);       
+		if (unlikely(!skb))
+			break;
+
+		cleaned_cnt++;
+		howmany++;
+
+		if (unlikely(++i == rx_queue->rx_ring_size))
+			i = 0;
+
+		rx_queue->next_to_clean = i;
+
+		if (netif_msg_rx_status(priv)){
+			netdev_dbg(priv->ndev,"%s rxbuf allocted %d used %d clean %d\n", 
+				ndev->name, rx_queue->next_to_alloc, rx_queue->next_to_use,
+				rx_queue->next_to_clean);
+		}
+
+		/* fetch next buffer if not the last in frame */
+		if (!(lstatus & CPU_MAC_DESC_INTF_W1_DESC_EOP)){
+			if(rx_queue->pps_limit)
+				rx_queue->token += CTCMAC_TOKEN_PER_PKT;
+			continue;
+		}
+
+		if (unlikely(lstatus & CPU_MAC_DESC_INTF_W1_DESC_ERR)) {
+			/* discard faulty buffer */
+			dev_kfree_skb(skb);
+			skb = NULL;
+			rx_queue->stats.rx_dropped++;
+			if (netif_msg_rx_err(priv)){
+				netdev_dbg(priv->ndev,"%s: Error with rx desc status 0x%x\n", ndev->name, lstatus);
+			}
+			continue;
+		}
+		
+		/* Increment the number of packets */
+		total_pkts++;
+		total_bytes += skb->len;
+
+		skb_record_rx_queue(skb, rx_queue->qindex);    
+		ctcmac_process_frame(ndev, skb);
+		/* Send the packet up the stack */
+		napi_gro_receive(&rx_queue->napi_rx, skb);
+
+		skb = NULL;
+	}
+
+	/* Store incomplete frames for completion */
+	rx_queue->skb = skb;
+
+	rx_queue->stats.rx_packets += total_pkts;
+	rx_queue->stats.rx_bytes += total_bytes;
+
+	if(!rx_queue->pps_limit && cleaned_cnt){
+		ctcmac_alloc_rx_buffs(rx_queue, cleaned_cnt);
+	}
+
+	if(rx_queue->pps_limit && rx_queue->skb){
+		return budget;
+	}
+	
+	return howmany;
+}
+
+static void ctcmac_clean_tx_ring(struct ctcmac_priv_tx_q *tx_queue)
+{
+	u16 next_to_clean;
+	int tqi = tx_queue->qindex;
+	struct sk_buff *skb;
+	struct netdev_queue *txq;
+	struct	ctcmac_tx_buff *tx_buff;
+	struct net_device *dev = tx_queue->dev;
+	struct ctcmac_private *priv = netdev_priv(dev);
+
+	txq = netdev_get_tx_queue(dev, tqi);
+	next_to_clean = tx_queue->next_to_clean;
+	while (ctcmac_txbd_used_untreated(priv)) {
+		ctcmac_get_txbd(priv);
+		skb = tx_queue->tx_skbuff[next_to_clean];
+		dev_kfree_skb_any(skb);
+		tx_queue->tx_skbuff[next_to_clean] = NULL;
+		tx_buff = &tx_queue->tx_buff[next_to_clean];        
+		dma_unmap_single(priv->dev, tx_buff->dma,
+		    				 tx_buff->len, DMA_TO_DEVICE);
+		if(tx_buff->alloc){
+			kfree(tx_buff->vaddr);
+		}
+		if(netif_msg_tx_queued(priv)){
+			netdev_dbg(priv->ndev,"%s: clean skbuff id %d\n", 
+				priv->ndev->name, tx_queue->next_to_clean);
+		}
+		if((next_to_clean + 1) >=tx_queue->tx_ring_size){
+			next_to_clean = 0;
+		}else{
+			next_to_clean++; 
+		}
+
+		spin_lock(&tx_queue->txlock);
+		tx_queue->num_txbdfree++;
+		spin_unlock(&tx_queue->txlock);
+	}
+
+	/* If we freed a buffer, we can restart transmission, if necessary */
+	if (tx_queue->num_txbdfree && 
+		netif_tx_queue_stopped(txq) &&
+	!(test_bit(CTCMAC_DOWN, &priv->state))){
+		netif_wake_subqueue(priv->ndev, tqi);
+	}
+
+	tx_queue->next_to_clean = next_to_clean;
+}
+
+static int ctcmac_poll_rx_sq(struct napi_struct *napi, int budget)
+{
+	int work_done = 0;
+	int rx_work_limit;
+	struct ctcmac_private *priv =
+		container_of(napi, struct ctcmac_private, napi_rx);
+	struct ctcmac_priv_rx_q *rxq0 = NULL, *rxq1 = NULL;
+
+	/* clear interrupt */
+	writel(CTCMAC_NOR_RX0_D|CTCMAC_NOR_RX1_D, 
+		&priv->cpumac_reg->CpuMacInterruptFunc[1]);
+
+	rx_work_limit = budget;
+	rxq0 = priv->rx_queue[0];
+	rxq1 = priv->rx_queue[1];
+
+	work_done += ctcmac_clean_rx_ring(rxq1, rx_work_limit);
+	rx_work_limit -= work_done;
+	work_done += ctcmac_clean_rx_ring(rxq0, rx_work_limit);
+	rx_work_limit -= work_done;
+
+	rxq0->rx_trigger = 0;
+	rxq1->rx_trigger = 0;
+	if (work_done < budget) {
+		napi_complete(napi);
+		if(!ctcmac_rxbd_usable(priv, 0) && !ctcmac_rxbd_recycle(priv, 0))
+			rxq0->rx_trigger = 1;
+		
+		if(!ctcmac_rxbd_usable(priv, 1) && !ctcmac_rxbd_recycle(priv, 1))
+			rxq1->rx_trigger = 1;
+
+		spin_lock_irq(&priv->reglock);
+		/* enable interrupt */
+		writel(CTCMAC_NOR_RX0_D|CTCMAC_NOR_RX1_D, 
+			&priv->cpumac_reg->CpuMacInterruptFunc[3]);
+		spin_unlock_irq(&priv->reglock);
+	}
+
+	return work_done;
+}
+
+static int ctcmac_poll_tx_sq(struct napi_struct *napi, int budget) //TODO by liuht
+{
+	struct ctcmac_private *priv =
+		container_of(napi, struct ctcmac_private, napi_tx);
+	struct ctcmac_priv_tx_q *tx_queue = priv->tx_queue[0];
+
+	/* clear interrupt */
+	writel(CTCMAC_NOR_TX_D, &priv->cpumac_reg->CpuMacInterruptFunc[1]);
+
+	ctcmac_clean_tx_ring(tx_queue);
+
+	napi_complete(napi);
+	/* enable interrupt */
+	spin_lock_irq(&priv->reglock);
+	writel(CTCMAC_NOR_TX_D, 
+	    &priv->cpumac_reg->CpuMacInterruptFunc[3]);
+	spin_unlock_irq(&priv->reglock);
+	
+	return 0;
+}
+
+static void ctcmac_free_rx_resources(struct ctcmac_private *priv)
+{
+    int i, j;
+    struct ctcmac_priv_rx_q *rx_queue = NULL;
+
+	for (i = 0; i < priv->num_rx_queues; i++) {
+		rx_queue = priv->rx_queue[i]; 
+		if (rx_queue->skb)
+			dev_kfree_skb(rx_queue->skb);
+
+		for (j = 0; j < rx_queue->rx_ring_size; j++){
+			struct	ctcmac_rx_buff *rxb = &rx_queue->rx_buff[j];
+			if(!rxb->page)
+				continue;
+			dma_unmap_single(rx_queue->dev, rxb->dma,
+				 PAGE_SIZE, DMA_TO_DEVICE);
+			__free_page(rxb->page);
+		}
+		if(rx_queue->rx_buff){
+			kfree(rx_queue->rx_buff);
+			rx_queue->rx_buff = NULL;
+		}
+	}
+}
+
+static int ctcmac_init_rx_resources(struct net_device *ndev)
+{
+	int i;
+	struct ctcmac_private *priv = netdev_priv(ndev);
+	struct device *dev = priv->dev;
+	struct ctcmac_priv_rx_q *rx_queue = NULL;
+
+	for (i = 0; i < priv->num_rx_queues; i++) {
+		rx_queue = priv->rx_queue[i]; 
+		rx_queue->ndev = ndev;
+		rx_queue->dev = dev;
+		rx_queue->next_to_clean = 0;
+		rx_queue->next_to_use = 0;
+		rx_queue->next_to_alloc = 0;
+		rx_queue->skb = NULL;
+		rx_queue->rx_trigger = 0;
+		rx_queue->rx_buff = kcalloc(rx_queue->rx_ring_size,
+					    sizeof(*rx_queue->rx_buff),
+					    GFP_KERNEL);
+		if (!rx_queue->rx_buff)
+			goto cleanup;
+
+		ctcmac_alloc_rx_buffs(rx_queue, ctcmac_rxbd_unused(rx_queue));
+	}
+
+	return 0;
+
+	cleanup:
+	ctcmac_free_rx_resources(priv);
+
+	return -1;
+}
+
+static void ctcmac_free_tx_resources(struct ctcmac_private *priv)
+{
+	int i;
+	struct ctcmac_priv_tx_q *tx_queue = NULL;
+
+	for (i = 0; i < priv->num_tx_queues; i++) {
+		struct netdev_queue *txq;
+
+		tx_queue = priv->tx_queue[i];
+		txq = netdev_get_tx_queue(tx_queue->dev, tx_queue->qindex);
+
+		if(tx_queue->tx_skbuff){
+			kfree(tx_queue->tx_skbuff);
+			tx_queue->tx_skbuff = NULL;
+		}        
+	}
+}
+
+static int ctcmac_init_tx_resources(struct net_device *ndev)
+{
+	int i;
+	struct ctcmac_private *priv = netdev_priv(ndev);
+	struct ctcmac_priv_tx_q *tx_queue = NULL;
+
+	for (i = 0; i < priv->num_tx_queues; i++) {
+		tx_queue = priv->tx_queue[i];
+		tx_queue->num_txbdfree = tx_queue->tx_ring_size;
+		tx_queue->next_to_clean = 0;
+		tx_queue->next_to_alloc = 0;
+		tx_queue->dev = ndev;
+		tx_queue->tx_skbuff =
+		kmalloc_array(tx_queue->tx_ring_size,
+		      sizeof(*tx_queue->tx_skbuff),
+		      GFP_KERNEL);
+
+		if (!tx_queue->tx_skbuff)
+			goto cleanup;
+	}
+
+	return 0;
+
+	cleanup:
+	ctcmac_free_tx_resources(priv);
+
+	return -1;
+}
+
+static int ctcmac_alloc_skb_resources(struct net_device *ndev)
+{
+	if(ctcmac_init_rx_resources(ndev))
+		return -1;
+	if(ctcmac_init_tx_resources(ndev))
+		return -1;
+
+	return 0;
+}
+
+static int ctcmac_free_skb_resources(struct ctcmac_private *priv)
+{
+	ctcmac_free_rx_resources(priv);
+	ctcmac_free_tx_resources(priv);
+
+	return 0;
+}
+
+static void cpumac_start(struct ctcmac_private *priv)
+{    
+	/* 1. enable rx/tx interrupt */
+	writel(CTCMAC_NOR_TX_D|CTCMAC_NOR_RX0_D|CTCMAC_NOR_RX1_D, 
+	    &priv->cpumac_reg->CpuMacInterruptFunc[3]);
+	/* 2. enable rx/tx */
+	clrsetbits(&priv->cpumac_reg->CpuMacReset, CPU_MAC_RESET_W0_SOFT_RST_TX, 0);
+	clrsetbits(&priv->cpumac_reg->CpuMacReset, CPU_MAC_RESET_W0_SOFT_RST_RX, 0);
+	
+	netif_trans_update(priv->ndev); /* prevent tx timeout */
+}
+
+static void cpumac_halt(struct ctcmac_private *priv)
+{    
+	/* 1. disable rx/tx interrupt */
+	ctcmac_regw(&priv->cpumac_reg->CpuMacInterruptFunc[2], 0xffffffff);
+	ctcmac_regw(&priv->cpumac_reg->CpuMacInterruptNormal[2], 0xffffffff);
+	/* 2. disable rx/tx */
+	clrsetbits(&priv->cpumac_reg->CpuMacReset, 0, CPU_MAC_RESET_W0_SOFT_RST_TX);
+	clrsetbits(&priv->cpumac_reg->CpuMacReset, 0, CPU_MAC_RESET_W0_SOFT_RST_RX);
+}
+
+static void ctcmac_token_timer(unsigned long arg)
+{
+	struct ctcmac_private *priv = (struct ctcmac_private *)arg;
+	struct ctcmac_priv_rx_q *rxq0, *rxq1;
+
+	mod_timer(&priv->token_timer, jiffies + HZ/10 - 1);
+	rxq0 = priv->rx_queue[0];
+	rxq1 = priv->rx_queue[1];
+	rxq0->token = min(rxq0->token + rxq0->pps_limit, rxq0->token_max);
+	rxq1->token = min(rxq1->token + rxq1->pps_limit, rxq1->token_max);
+
+	if((rxq0->rx_trigger == 1) && (rxq0->token/CTCMAC_TOKEN_PER_PKT)){
+		rxq0->rx_trigger = 0;
+		rxq0->token -= CTCMAC_TOKEN_PER_PKT;
+		ctcmac_alloc_one_rx_buffs(rxq0);
+	}
+
+	if((rxq1->rx_trigger == 1) && (rxq1->token/CTCMAC_TOKEN_PER_PKT)){
+		rxq1->rx_trigger = 0;
+		rxq1->token -= CTCMAC_TOKEN_PER_PKT;
+		ctcmac_alloc_one_rx_buffs(rxq1);
+	}
+}
+
+static ssize_t ctcmac_get_rxq0_pps(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct ctcmac_private *priv = (struct ctcmac_private *)dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", priv->rx_queue[0]->pps_limit);;
+}
+
+static ssize_t ctcmac_set_rxq0_pps(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	u32 rq0_pps;
+	struct ctcmac_private *priv = (struct ctcmac_private *)dev_get_drvdata(dev);
+
+	if (kstrtou32(buf, 0, &rq0_pps)){
+		dev_err(&priv->ndev->dev, "Invalid rx queue0 pps!\n");
+		return -1;
+	}
+	priv->rx_queue[0]->pps_limit = rq0_pps;
+
+	return count;
+}
+
+static ssize_t ctcmac_get_rxq1_pps(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct ctcmac_private *priv = (struct ctcmac_private *)dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", priv->rx_queue[1]->pps_limit);;
+}
+
+static ssize_t ctcmac_set_rxq1_pps(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	u32 rq1_pps;
+	struct ctcmac_private *priv = (struct ctcmac_private *)dev_get_drvdata(dev);
+
+	if (kstrtou32(buf, 0, &rq1_pps)){
+		dev_err(&priv->ndev->dev, "Invalid rx queue0 pps!\n");
+		return -1;
+	}
+	priv->rx_queue[1]->pps_limit = rq1_pps;
+
+	return count;
+}
+
+static DEVICE_ATTR(rxq0_pps, S_IRUGO|S_IWUSR, ctcmac_get_rxq0_pps, ctcmac_set_rxq0_pps);
+static DEVICE_ATTR(rxq1_pps, S_IRUGO|S_IWUSR, ctcmac_get_rxq1_pps, ctcmac_set_rxq1_pps);
+
+static void ctcmac_pps_init(struct ctcmac_private *priv)
+{
+	struct ctcmac_priv_rx_q *rxq0, *rxq1;
+
+	rxq0 = priv->rx_queue[0];
+	rxq1 = priv->rx_queue[1];
+
+	if(device_create_file(&priv->ndev->dev, &dev_attr_rxq0_pps) < 0){
+		dev_err(&priv->ndev->dev, "create pps limit node fail\n");
+		return;
+	}
+	if(device_create_file(&priv->ndev->dev, &dev_attr_rxq1_pps) < 0){
+		dev_err(&priv->ndev->dev, "create pps limit node fail\n");
+		return;
+	}
+	
+	rxq0->pps_limit = 0;
+	rxq1->pps_limit = 0;
+}
+
+static void ctcmac_pps_disable(struct ctcmac_private *priv)
+{
+	priv->rx_queue[0]->pps_limit = 0;
+	priv->rx_queue[1]->pps_limit = 0;
+	del_timer(&priv->token_timer);
+}
+
+
+static void ctcmac_pps_cfg(struct ctcmac_private *priv)
+{
+	struct ctcmac_priv_rx_q *rxq0, *rxq1;
+
+	rxq0 = priv->rx_queue[0];
+	rxq1 = priv->rx_queue[1];
+	
+	rxq0->token = 0;
+	rxq0->token_max = rxq0->pps_limit * CTCMAC_TOKEN_PER_PKT;
+	rxq1->token = 0;
+	rxq1->token_max = rxq1->pps_limit * CTCMAC_TOKEN_PER_PKT;
+	if(rxq0->pps_limit || rxq1->pps_limit){
+		setup_timer(&priv->token_timer, ctcmac_token_timer, (unsigned long) priv);
+		priv->token_timer.expires = jiffies + HZ/10;
+		add_timer(&priv->token_timer);
+		/* when enable pps ratelimit, must use desc done interrupt */
+		priv->int_type = CTCMAC_INT_DESC;
+	}else{
+		priv->int_type = CTCMAC_INT_PACKET;
+	}
+}
+
+static int ctcmac_enet_open(struct net_device *dev)
+{
+	struct ctcmac_private *priv = netdev_priv(dev);
+	int err;
+
+	ctcmac_pps_cfg(priv);
+	
+	err = ctcmac_init_phy(dev);
+	if(err){
+		return err;
+	}
+
+	err = ctcmac_request_irq(priv);
+	if (err){
+		return err;
+	}
+
+	err = startup_ctcmac(dev);
+	if (err){
+		return err;
+	}
+
+	return 0;
+}
+
+static struct	ctcmac_tx_buff * skb_to_txbuff(struct ctcmac_private *priv, struct sk_buff *skb)
+{
+	u64 addr, offset;
+	int frag_index, nr_frags, rq;
+	skb_frag_t *frag;
+	struct	ctcmac_tx_buff *tx_buff;
+	struct ctcmac_priv_tx_q *tx_queue = NULL;
+
+	nr_frags = skb_shinfo(skb)->nr_frags;
+	rq = skb->queue_mapping;
+	tx_queue = priv->tx_queue[rq];
+
+	tx_buff = &tx_queue->tx_buff[tx_queue->next_to_alloc];
+	addr = (u64)skb->data;
+	if((!nr_frags) && 
+	((addr & PAGE_MASK) == ((addr+skb_headlen(skb)) & PAGE_MASK))){
+		tx_buff->alloc = 0;
+		tx_buff->vaddr = skb->data;
+		tx_buff->len = skb_headlen(skb);
+		tx_buff->dma = dma_map_single(priv->dev, skb->data, skb_headlen(skb),
+				 DMA_TO_DEVICE);
+		tx_buff->offset = 0;
+
+	}else{
+		int alloc_size;
+		alloc_size = ALIGN(skb->len, BUF_ALIGNMENT);        
+		tx_buff->alloc = 1;
+		tx_buff->len = skb->len;
+		tx_buff->vaddr = kmalloc(alloc_size, GFP_KERNEL);        
+		offset = (BUF_ALIGNMENT - (((u64)tx_buff->vaddr)&(BUF_ALIGNMENT - 1)));
+		if(offset == BUF_ALIGNMENT){
+			offset = 0;
+		}
+		tx_buff->offset = offset;
+		memcpy(tx_buff->vaddr + offset, skb->data, skb_headlen(skb));
+		offset += skb_headlen(skb);
+		for(frag_index = 0; frag_index <  nr_frags; frag_index++){
+			frag = &skb_shinfo(skb)->frags[frag_index];
+			memcpy(tx_buff->vaddr + offset, frag, skb_frag_size(frag));
+			offset += skb_frag_size(frag);
+		}
+
+		tx_buff->dma = dma_map_single(priv->dev, tx_buff->vaddr, tx_buff->len,
+				 DMA_TO_DEVICE);
+	}
+	return tx_buff;
+}
+
+static int ctcmac_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	int rq = 0;
+	unsigned int  bytes_sent;
+	struct netdev_queue *txq;
+	struct ctcmac_desc_cfg tx_desc;
+	struct	ctcmac_tx_buff *tx_buff;
+	struct ctcmac_priv_tx_q *tx_queue = NULL;
+	struct ctcmac_private *priv = netdev_priv(dev);
+
+	rq = skb->queue_mapping;
+	tx_queue = priv->tx_queue[rq];
+	txq = netdev_get_tx_queue(dev, rq);
+	
+	/* check if there is space to queue this packet */
+	if (tx_queue->num_txbdfree <= 0) {
+		if(netif_msg_tx_err(priv)){
+			netdev_dbg(priv->ndev,"%s: no space left before send pkt!\n", priv->ndev->name);
+		}
+		/* no space, stop the queue */
+		netif_tx_stop_queue(txq);
+		dev->stats.tx_fifo_errors++;
+		return NETDEV_TX_BUSY;
+	}
+
+	/* Update transmit stats */
+	bytes_sent = skb->len;
+	tx_queue->stats.tx_bytes += bytes_sent;
+	tx_queue->stats.tx_packets++;
+
+	tx_buff = skb_to_txbuff(priv, skb);
+	tx_queue->tx_skbuff[tx_queue->next_to_alloc] = skb;
+	tx_desc.sop = 1;
+	tx_desc.eop = 1;
+	tx_desc.size = tx_buff->len;
+	tx_desc.addr_low = (tx_buff->dma+tx_buff->offset - CTC_DDR_BASE) 
+		& CPU_MAC_DESC_INTF_W0_DESC_ADDR_31_0_MASK;
+	tx_desc.addr_high = ((tx_buff->dma+tx_buff->offset - CTC_DDR_BASE) >> 32) 
+		& CPU_MAC_DESC_INTF_W1_DESC_ADDR_39_32_MASK;
+	ctcmac_fill_txbd(priv, &tx_desc);
+
+	if(netif_msg_tx_queued(priv)){
+		netdev_dbg(priv->ndev,"%s: alloc skbuff id %d\n", 
+			priv->ndev->name, tx_queue->next_to_alloc);
+	}
+
+	if(tx_queue->next_to_alloc >= tx_queue->tx_ring_size - 1){
+		tx_queue->next_to_alloc = 0;
+	}else{
+		tx_queue->next_to_alloc++;
+	}
+
+	/* We can work in parallel with 872(), except
+	 * when modifying num_txbdfree. Note that we didn't grab the lock
+	 * when we were reading the num_txbdfree and checking for available
+	 * space, that's because outside of this function it can only grow.
+	 */
+	spin_lock_bh(&tx_queue->txlock);
+	/* reduce TxBD free count */
+	tx_queue->num_txbdfree--;
+	spin_unlock_bh(&tx_queue->txlock);
+
+	/* If the next BD still needs to be cleaned up, then the bds
+	 * are full.  We need to tell the kernel to stop sending us stuff.
+	 */
+	if (!tx_queue->num_txbdfree) {
+		netif_tx_stop_queue(txq);
+		if(netif_msg_tx_err(priv)){
+			netdev_dbg(dev,"%s: no space left before send pkt!\n", priv->ndev->name);
+		}
+		dev->stats.tx_fifo_errors++;
+	}
+
+	return NETDEV_TX_OK;
+}
+
+static int ctcmac_change_mtu(struct net_device *dev, int new_mtu)
+{
+	struct ctcmac_private *priv = netdev_priv(dev);
+	int frame_size = new_mtu + ETH_HLEN;
+
+	if ((frame_size < 64) || (frame_size > CTCMAC_JUMBO_FRAME_SIZE)) {
+		return -EINVAL;
+	}
+
+	while (test_and_set_bit_lock(CTCMAC_RESETTING, &priv->state))
+		cpu_relax();
+
+	if (dev->flags & IFF_UP)
+		stop_ctcmac(dev);
+
+	dev->mtu = new_mtu;
+
+	if (dev->flags & IFF_UP)
+		startup_ctcmac(dev);
+
+	clear_bit_unlock(CTCMAC_RESETTING, &priv->state);
+
+	return 0;
+}
+
+static int ctcmac_set_features(struct net_device *dev, netdev_features_t features)
+{
+	return 0;
+}
+
+/* Stops the kernel queue, and halts the controller */
+static int ctcmac_close(struct net_device *dev)
+{
+	struct ctcmac_private *priv = netdev_priv(dev);
+
+	ctcmac_pps_disable(priv);
+	cancel_work_sync(&priv->reset_task);
+	stop_ctcmac(dev);
+
+	/* Disconnect from the PHY */
+	phy_disconnect(dev->phydev);
+
+	ctcmac_free_irq(priv);
+
+	return 0;
+}
+
+static void ctcmac_set_multi(struct net_device *dev)
+{
+}
+
+static void ctcmac_timeout(struct net_device *dev)
+{
+	struct ctcmac_private *priv = netdev_priv(dev);
+
+	dev->stats.tx_errors++;
+	schedule_work(&priv->reset_task);
+}
+
+static int ctcmac_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	struct phy_device *phydev = dev->phydev;
+
+	if (!netif_running(dev))
+		return -EINVAL;
+
+	if (!phydev)
+		return -ENODEV;
+
+	return phy_mii_ioctl(phydev, rq, cmd);
+}
+
+static struct net_device_stats *ctcmac_get_stats(struct net_device *dev)
+{
+	int qidx;
+	unsigned long rx_packets = 0, rx_bytes = 0, rx_dropped = 0;
+	unsigned long tx_packets = 0, tx_bytes = 0;
+	struct ctcmac_private *priv = netdev_priv(dev);
+
+	for(qidx = 0; qidx < priv->num_rx_queues; qidx++){
+		if(!priv->rx_queue[qidx]){
+			return &dev->stats; 
+		}
+		rx_packets += priv->rx_queue[qidx]->stats.rx_packets;
+		rx_bytes += priv->rx_queue[qidx]->stats.rx_bytes;
+		rx_dropped += priv->rx_queue[qidx]->stats.rx_dropped;
+	}
+
+	if(!priv->tx_queue[0]){
+	    return &dev->stats; 
+	}
+
+	tx_packets = priv->tx_queue[0]->stats.tx_packets;
+	tx_bytes = priv->tx_queue[0]->stats.tx_bytes;
+
+	dev->stats.rx_packets = rx_packets;
+	dev->stats.rx_bytes   = rx_bytes;
+	dev->stats.rx_dropped = rx_dropped;
+	dev->stats.tx_bytes   = tx_bytes;
+	dev->stats.tx_packets = tx_packets;
+
+	return &dev->stats;
+}
+
+#if 0
+static void ctcmac_set_mac_for_addr(struct net_device *dev,
+				  const u8 *addr)
+{
+	u32 addr_h=0, addr_l=0;
+	struct ctcmac_private *priv = netdev_priv(dev);
+
+	addr_h = addr[0]<<8 | addr[1]; 
+	addr_l = addr[2]<<24 | addr[3]<<16 | addr[4]<<8 | addr[5];
+	writel(addr_l, &priv->cpumacu_reg->CpuMacUnitMacCamCfg[2]);
+	writel(addr_h, &priv->cpumacu_reg->CpuMacUnitMacCamCfg[3]);
+}
+#endif
+
+static int ctcmac_set_mac_addr(struct net_device *dev, void *p)
+{
+	eth_mac_addr(dev, p);
+#if 0
+	ctcmac_set_mac_for_addr(dev, dev->dev_addr);
+#endif
+	return 0;
+}
+
+static void ctcmac_gdrvinfo(struct net_device *dev,
+			  struct ethtool_drvinfo *drvinfo)
+{
+	strlcpy(drvinfo->driver, "ctcmac", sizeof(drvinfo->driver));
+	strlcpy(drvinfo->version, "v1.0",	sizeof(drvinfo->version));
+	strlcpy(drvinfo->fw_version, "N/A", sizeof(drvinfo->fw_version));
+	strlcpy(drvinfo->bus_info, "N/A", sizeof(drvinfo->bus_info));
+}
+
+/* Return the length of the register structure */
+static int ctcmac_reglen(struct net_device *dev)
+{
+	return sizeof (struct CpuMac_regs);
+}
+
+/* Return a dump of the GFAR register space */
+static void ctcmac_get_regs(struct net_device *dev, struct ethtool_regs *regs,
+			  void *regbuf)
+{
+	int i;
+	struct ctcmac_private *priv = netdev_priv(dev);
+	u32 __iomem *theregs = (u32 __iomem *) priv->cpumac_reg;
+	u32 *buf = (u32 *) regbuf;
+
+	for (i = 0; i < sizeof (struct CpuMac_regs) / sizeof (u32); i++)
+		buf[i] = ctcmac_regr(&theregs[i]);
+}
+
+/* Fills in rvals with the current ring parameters.  Currently,
+ * rx, rx_mini, and rx_jumbo rings are the same size, as mini and
+ * jumbo are ignored by the driver */
+static void ctcmac_gringparam(struct net_device *dev,
+			    struct ethtool_ringparam *rvals)
+{
+	struct ctcmac_private *priv = netdev_priv(dev);
+	struct ctcmac_priv_tx_q *tx_queue = NULL;
+	struct ctcmac_priv_rx_q *rx_queue = NULL;
+
+	tx_queue = priv->tx_queue[0];
+	rx_queue = priv->rx_queue[0];
+
+	rvals->rx_max_pending = CTCMAC_MAX_RING_SIZE;
+	rvals->rx_mini_max_pending = CTCMAC_MAX_RING_SIZE;
+	rvals->rx_jumbo_max_pending = CTCMAC_MAX_RING_SIZE;
+	rvals->tx_max_pending = CTCMAC_MAX_RING_SIZE;
+
+	/* Values changeable by the user.  The valid values are
+	 * in the range 1 to the "*_max_pending" counterpart above.
+	 */
+	rvals->rx_pending = rx_queue->rx_ring_size;
+	rvals->rx_mini_pending = rx_queue->rx_ring_size;
+	rvals->rx_jumbo_pending = rx_queue->rx_ring_size;
+	rvals->tx_pending = tx_queue->tx_ring_size;
+}
+
+/* Change the current ring parameters, stopping the controller if
+ * necessary so that we don't mess things up while we're in motion.
+ */
+static int ctcmac_sringparam(struct net_device *dev,
+			   struct ethtool_ringparam *rvals)
+{
+	struct ctcmac_private *priv = netdev_priv(dev);
+	int err = 0, i;
+
+	if (rvals->rx_pending > CTCMAC_MAX_RING_SIZE)
+		return -EINVAL;
+
+	if (rvals->tx_pending > CTCMAC_MAX_RING_SIZE)
+		return -EINVAL;
+
+	while (test_and_set_bit_lock(CTCMAC_RESETTING, &priv->state))
+		cpu_relax();
+
+	if (dev->flags & IFF_UP)
+		stop_ctcmac(dev);
+
+	/* Change the sizes */
+	for (i = 0; i < priv->num_rx_queues; i++)
+		priv->rx_queue[i]->rx_ring_size = rvals->rx_pending;
+
+	for (i = 0; i < priv->num_tx_queues; i++)
+		priv->tx_queue[i]->tx_ring_size = rvals->tx_pending;
+
+	/* Rebuild the rings with the new size */
+	if (dev->flags & IFF_UP)
+		err = startup_ctcmac(dev);
+
+	clear_bit_unlock(CTCMAC_RESETTING, &priv->state);
+
+	return err;
+}
+
+static void ctcmac_gpauseparam(struct net_device *dev,
+			     struct ethtool_pauseparam *epause)
+{
+#if 0
+	struct ctcmac_private *priv = netdev_priv(dev);
+
+	epause->autoneg = !!priv->pause_aneg_en;
+	epause->rx_pause = !!priv->rx_pause_en;
+	epause->tx_pause = !!priv->tx_pause_en;
+#endif
+}
+
+static int ctcmac_spauseparam(struct net_device *dev,
+			    struct ethtool_pauseparam *epause)
+{
+#if 0
+	struct gfar_private *priv = netdev_priv(dev);
+	struct phy_device *phydev = dev->phydev;
+	struct gfar __iomem *regs = priv->gfargrp[0].regs;
+	u32 oldadv, newadv;
+
+	if (!phydev)
+		return -ENODEV;
+
+	if (!(phydev->supported & SUPPORTED_Pause) ||
+	    (!(phydev->supported & SUPPORTED_Asym_Pause) &&
+	     (epause->rx_pause != epause->tx_pause)))
+		return -EINVAL;
+
+	priv->rx_pause_en = priv->tx_pause_en = 0;
+	if (epause->rx_pause) {
+		priv->rx_pause_en = 1;
+
+		if (epause->tx_pause) {
+			priv->tx_pause_en = 1;
+			/* FLOW_CTRL_RX & TX */
+			newadv = ADVERTISED_Pause;
+		} else  /* FLOW_CTLR_RX */
+			newadv = ADVERTISED_Pause | ADVERTISED_Asym_Pause;
+	} else if (epause->tx_pause) {
+		priv->tx_pause_en = 1;
+		/* FLOW_CTLR_TX */
+		newadv = ADVERTISED_Asym_Pause;
+	} else
+		newadv = 0;
+
+	if (epause->autoneg)
+		priv->pause_aneg_en = 1;
+	else
+		priv->pause_aneg_en = 0;
+
+	oldadv = phydev->advertising &
+		(ADVERTISED_Pause | ADVERTISED_Asym_Pause);
+	if (oldadv != newadv) {
+		phydev->advertising &=
+			~(ADVERTISED_Pause | ADVERTISED_Asym_Pause);
+		phydev->advertising |= newadv;
+		if (phydev->autoneg)
+			/* inform link partner of our
+			 * new flow ctrl settings
+			 */
+			return phy_start_aneg(phydev);
+
+		if (!epause->autoneg) {
+			u32 tempval;
+			tempval = gfar_read(&regs->maccfg1);
+			tempval &= ~(MACCFG1_TX_FLOW | MACCFG1_RX_FLOW);
+
+			priv->tx_actual_en = 0;
+			if (priv->tx_pause_en) {
+				priv->tx_actual_en = 1;
+				tempval |= MACCFG1_TX_FLOW;
+			}
+
+			if (priv->rx_pause_en)
+				tempval |= MACCFG1_RX_FLOW;
+			gfar_write(&regs->maccfg1, tempval);
+		}
+	}
+#endif
+	return 0;
+}
+
+static void ctcmac_gstrings(struct net_device *dev, u32 stringset, u8 * buf)
+{
+	memcpy(buf, ctc_stat_gstrings, CTCMAC_STATS_LEN * ETH_GSTRING_LEN);
+}
+
+static int ctcmac_sset_count(struct net_device *dev, int sset)
+{
+	return CTCMAC_STATS_LEN;
+}
+
+static void ctcmac_fill_stats(struct net_device *netdev, struct ethtool_stats *dummy,
+			    u64 *buf)
+{
+	u32 mtu;
+	unsigned long flags;
+	struct ctcmac_pkt_stats *stats;
+	struct ctcmac_private *priv =  netdev_priv(netdev);
+
+	spin_lock_irqsave(&priv->reglock, flags);
+	stats = &g_pkt_stats[priv->index];
+	stats->rx_good_ucast_bytes      +=   readq(&priv->cpumac_mem->CpuMacStatsRam0[0]);
+	stats->rx_good_ucast_pkt        +=   readq(&priv->cpumac_mem->CpuMacStatsRam0[2]);
+	stats->rx_good_mcast_bytes      +=   readq(&priv->cpumac_mem->CpuMacStatsRam1[0]);
+	stats->rx_good_mcast_pkt        +=   readq(&priv->cpumac_mem->CpuMacStatsRam1[2]);
+	stats->rx_good_bcast_bytes      +=   readq(&priv->cpumac_mem->CpuMacStatsRam2[0]);
+	stats->rx_good_bcast_pkt        +=   readq(&priv->cpumac_mem->CpuMacStatsRam2[2]);
+	stats->rx_good_pause_bytes      +=   readq(&priv->cpumac_mem->CpuMacStatsRam3[0]) ;
+	stats->rx_good_pause_pkt        +=   readq(&priv->cpumac_mem->CpuMacStatsRam3[2]) ;
+	stats->rx_good_pfc_bytes        +=   readq(&priv->cpumac_mem->CpuMacStatsRam4[0]) ;
+	stats->rx_good_pfc_pkt          +=   readq(&priv->cpumac_mem->CpuMacStatsRam4[2]) ;
+	stats->rx_good_control_bytes    +=   readq(&priv->cpumac_mem->CpuMacStatsRam5[0]) ;
+	stats->rx_good_control_pkt      +=   readq(&priv->cpumac_mem->CpuMacStatsRam5[2]) ;
+	stats->rx_fcs_error_bytes       +=   readq(&priv->cpumac_mem->CpuMacStatsRam6[0]) ;
+	stats->rx_fcs_error_pkt         +=   readq(&priv->cpumac_mem->CpuMacStatsRam6[2]) ;
+	stats->rx_mac_overrun_bytes     +=   readq(&priv->cpumac_mem->CpuMacStatsRam7[0]) ;
+	stats->rx_mac_overrun_pkt       +=   readq(&priv->cpumac_mem->CpuMacStatsRam7[2]) ;
+	stats->rx_good_63B_bytes        +=   readq(&priv->cpumac_mem->CpuMacStatsRam8[0]) ;
+	stats->rx_good_63B_pkt          +=   readq(&priv->cpumac_mem->CpuMacStatsRam8[2]) ;
+	stats->rx_bad_63B_bytes         +=   readq(&priv->cpumac_mem->CpuMacStatsRam9[0]) ;
+	stats->rx_bad_63B_pkt           +=   readq(&priv->cpumac_mem->CpuMacStatsRam9[2]) ;
+	stats->rx_good_mtu2B_bytes      +=   readq(&priv->cpumac_mem->CpuMacStatsRam10[0]);
+	stats->rx_good_mtu2B_pkt        +=   readq(&priv->cpumac_mem->CpuMacStatsRam10[2]);
+	stats->rx_bad_mtu2B_bytes       +=   readq(&priv->cpumac_mem->CpuMacStatsRam11[0]);
+	stats->rx_bad_mtu2B_pkt         +=   readq(&priv->cpumac_mem->CpuMacStatsRam11[2]);
+	stats->rx_good_jumbo_bytes      +=   readq(&priv->cpumac_mem->CpuMacStatsRam12[0]);
+	stats->rx_good_jumbo_pkt        +=   readq(&priv->cpumac_mem->CpuMacStatsRam12[2]);
+	stats->rx_bad_jumbo_bytes       +=   readq(&priv->cpumac_mem->CpuMacStatsRam13[0]);
+	stats->rx_bad_jumbo_pkt         +=   readq(&priv->cpumac_mem->CpuMacStatsRam13[2]);
+	stats->rx_64B_bytes             +=   readq(&priv->cpumac_mem->CpuMacStatsRam14[0]);
+	stats->rx_64B_pkt               +=   readq(&priv->cpumac_mem->CpuMacStatsRam14[2]);
+	stats->rx_127B_bytes            +=   readq(&priv->cpumac_mem->CpuMacStatsRam15[0]);
+	stats->rx_127B_pkt              +=   readq(&priv->cpumac_mem->CpuMacStatsRam15[2]);
+	stats->rx_255B_bytes            +=   readq(&priv->cpumac_mem->CpuMacStatsRam16[0]);
+	stats->rx_255B_pkt              +=   readq(&priv->cpumac_mem->CpuMacStatsRam16[2]);
+	stats->rx_511B_bytes            +=   readq(&priv->cpumac_mem->CpuMacStatsRam17[0]);
+	stats->rx_511B_pkt              +=   readq(&priv->cpumac_mem->CpuMacStatsRam17[2]);
+	stats->rx_1023B_bytes           +=   readq(&priv->cpumac_mem->CpuMacStatsRam18[0]);
+	stats->rx_1023B_pkt             +=   readq(&priv->cpumac_mem->CpuMacStatsRam18[2]);
+	stats->rx_mtu1B_bytes           +=   readq(&priv->cpumac_mem->CpuMacStatsRam19[0]);
+	stats->rx_mtu1B_pkt             +=   readq(&priv->cpumac_mem->CpuMacStatsRam19[2]);
+	stats->tx_ucast_bytes           +=   readq(&priv->cpumac_mem->CpuMacStatsRam20[0]);
+	stats->tx_ucast_pkt             +=   readq(&priv->cpumac_mem->CpuMacStatsRam20[2]);
+	stats->tx_mcast_bytes           +=   readq(&priv->cpumac_mem->CpuMacStatsRam21[0]);
+	stats->tx_mcast_pkt             +=   readq(&priv->cpumac_mem->CpuMacStatsRam21[2]);
+	stats->tx_bcast_bytes           +=   readq(&priv->cpumac_mem->CpuMacStatsRam22[0]);
+	stats->tx_bcast_pkt             +=   readq(&priv->cpumac_mem->CpuMacStatsRam22[2]);
+	stats->tx_pause_bytes           +=   readq(&priv->cpumac_mem->CpuMacStatsRam23[0]);
+	stats->tx_pause_pkt             +=   readq(&priv->cpumac_mem->CpuMacStatsRam23[2]);
+	stats->tx_control_bytes         +=   readq(&priv->cpumac_mem->CpuMacStatsRam24[0]);
+	stats->tx_control_pkt           +=   readq(&priv->cpumac_mem->CpuMacStatsRam24[2]);
+	stats->tx_fcs_error_bytes       +=   readq(&priv->cpumac_mem->CpuMacStatsRam25[0]);
+	stats->tx_fcs_error_pkt         +=   readq(&priv->cpumac_mem->CpuMacStatsRam25[2]);
+	stats->tx_underrun_bytes        +=   readq(&priv->cpumac_mem->CpuMacStatsRam26[0]);
+	stats->tx_underrun_pkt          +=   readq(&priv->cpumac_mem->CpuMacStatsRam26[2]);
+	stats->tx_63B_bytes             +=   readq(&priv->cpumac_mem->CpuMacStatsRam27[0]);
+	stats->tx_63B_pkt               +=   readq(&priv->cpumac_mem->CpuMacStatsRam27[2]);
+	stats->tx_64B_bytes             +=   readq(&priv->cpumac_mem->CpuMacStatsRam28[0]);
+	stats->tx_64B_pkt               +=   readq(&priv->cpumac_mem->CpuMacStatsRam28[2]);
+	stats->tx_127B_bytes            +=   readq(&priv->cpumac_mem->CpuMacStatsRam29[0]);
+	stats->tx_127B_pkt              +=   readq(&priv->cpumac_mem->CpuMacStatsRam29[2]);
+	stats->tx_255B_bytes            +=   readq(&priv->cpumac_mem->CpuMacStatsRam30[0]);
+	stats->tx_255B_pkt              +=   readq(&priv->cpumac_mem->CpuMacStatsRam30[2]);
+	stats->tx_511B_bytes            +=   readq(&priv->cpumac_mem->CpuMacStatsRam31[0]);
+	stats->tx_511B_pkt              +=   readq(&priv->cpumac_mem->CpuMacStatsRam31[2]);
+	stats->tx_1023B_bytes           +=   readq(&priv->cpumac_mem->CpuMacStatsRam32[0]);
+	stats->tx_1023B_pkt             +=   readq(&priv->cpumac_mem->CpuMacStatsRam32[2]);
+	stats->tx_mtu1_bytes           +=   readq(&priv->cpumac_mem->CpuMacStatsRam33[0]);
+	stats->tx_mtu1_pkt             +=   readq(&priv->cpumac_mem->CpuMacStatsRam33[2]);
+	stats->tx_mtu2_bytes           +=   readq(&priv->cpumac_mem->CpuMacStatsRam34[0]);
+	stats->tx_mtu2_pkt             +=   readq(&priv->cpumac_mem->CpuMacStatsRam34[2]);
+	stats->tx_jumbo_bytes           +=   readq(&priv->cpumac_mem->CpuMacStatsRam35[0]);
+	stats->tx_jumbo_pkt             +=   readq(&priv->cpumac_mem->CpuMacStatsRam35[2]);
+	mtu                                      =   readl(&priv->cpumac_reg->CpuMacStatsCfg[1]);
+	stats->mtu1                         =  mtu & 0x3fff;
+	stats->mtu2                         =  (mtu>>16) & 0x3fff;
+	spin_unlock_irqrestore(&priv->reglock, flags);
+	
+	memcpy(buf, (void *)stats, sizeof(struct ctcmac_pkt_stats));
+}
+
+static uint32_t ctcmac_get_msglevel(struct net_device *dev)
+{
+	struct ctcmac_private *priv = netdev_priv(dev);
+
+	return priv->msg_enable;
+}
+
+static void ctcmac_set_msglevel(struct net_device *dev, uint32_t data)
+{
+	struct ctcmac_private *priv = netdev_priv(dev);
+
+	priv->msg_enable = data;
+}
+
+static int ctcmac_get_ts_info(struct net_device *dev,
+			    struct ethtool_ts_info *info)
+{
+#if 0
+	struct gfar_private *priv = netdev_priv(dev);
+
+	if (!(priv->device_flags & FSL_GIANFAR_DEV_HAS_TIMER)) {
+		info->so_timestamping = SOF_TIMESTAMPING_RX_SOFTWARE |
+					SOF_TIMESTAMPING_SOFTWARE;
+		info->phc_index = -1;
+		return 0;
+	}
+	info->so_timestamping = SOF_TIMESTAMPING_TX_HARDWARE |
+				SOF_TIMESTAMPING_RX_HARDWARE |
+				SOF_TIMESTAMPING_RAW_HARDWARE;
+	info->phc_index = gfar_phc_index;
+	info->tx_types = (1 << HWTSTAMP_TX_OFF) |
+			 (1 << HWTSTAMP_TX_ON);
+	info->rx_filters = (1 << HWTSTAMP_FILTER_NONE) |
+			   (1 << HWTSTAMP_FILTER_ALL);
+#endif
+	return 0;
+}
+
+const struct ethtool_ops ctcmac_ethtool_ops = {
+	.get_drvinfo = ctcmac_gdrvinfo,
+	.get_regs_len = ctcmac_reglen,
+	.get_regs = ctcmac_get_regs,
+	.get_link = ethtool_op_get_link,
+	.get_ringparam = ctcmac_gringparam,
+	.set_ringparam = ctcmac_sringparam,
+	.get_pauseparam = ctcmac_gpauseparam,
+	.set_pauseparam = ctcmac_spauseparam,
+	.get_strings = ctcmac_gstrings,
+	.get_sset_count = ctcmac_sset_count,
+	.get_ethtool_stats = ctcmac_fill_stats,
+	.get_msglevel = ctcmac_get_msglevel,
+	.set_msglevel = ctcmac_set_msglevel,
+	.get_link_ksettings = phy_ethtool_get_link_ksettings,
+	.set_link_ksettings = phy_ethtool_set_link_ksettings,
+	.get_ts_info = ctcmac_get_ts_info,
+};
+
+static const struct net_device_ops ctcmac_netdev_ops = {
+	.ndo_open = ctcmac_enet_open,
+	.ndo_start_xmit = ctcmac_start_xmit,
+	.ndo_stop = ctcmac_close,
+	.ndo_change_mtu = ctcmac_change_mtu,
+	.ndo_set_features = ctcmac_set_features,
+	.ndo_set_rx_mode = ctcmac_set_multi,
+	.ndo_tx_timeout = ctcmac_timeout,
+	.ndo_do_ioctl = ctcmac_ioctl,
+	.ndo_get_stats = ctcmac_get_stats,
+	.ndo_set_mac_address = ctcmac_set_mac_addr,
+	.ndo_validate_addr = eth_validate_addr,
+};
+
+static int ctcmac_probe(struct platform_device *ofdev)
+{
+	struct net_device *dev = NULL;
+	struct ctcmac_private *priv = NULL;
+	int err = 0, i;
+
+	regmap_base = syscon_regmap_lookup_by_phandle(ofdev->dev.of_node,"ctc,sysctrl");
+	if (IS_ERR(regmap_base))
+		return PTR_ERR(regmap_base);
+	
+	err = ctcmac_of_init(ofdev, &dev);
+	if(err){
+		return err;
+	}
+
+
+	priv = netdev_priv(dev);
+	SET_NETDEV_DEV(dev, &ofdev->dev);
+	INIT_WORK(&priv->reset_task, ctcmac_reset_task);
+	platform_set_drvdata(ofdev, priv);
+	dev_set_drvdata(&dev->dev, priv);
+
+	dev->base_addr = (unsigned long)priv->iobase;
+	dev->watchdog_timeo = TX_TIMEOUT;
+	dev->mtu = CTCMAC_DEFAULT_MTU;
+	dev->netdev_ops = &ctcmac_netdev_ops;
+	dev->ethtool_ops = &ctcmac_ethtool_ops;
+
+	netif_napi_add(dev, &priv->napi_rx, ctcmac_poll_rx_sq, CTCMAC_NAIP_RX_WEIGHT);
+	netif_napi_add(dev, &priv->napi_tx, ctcmac_poll_tx_sq, CTCMAC_NAIP_TX_WEIGHT);
+
+	/* Initializing some of the rx/tx queue level parameters */
+	for (i = 0; i < priv->num_tx_queues; i++) {
+		priv->tx_queue[i]->tx_ring_size = CTCMAC_TX_RING_SIZE;
+		priv->tx_queue[i]->num_txbdfree = CTCMAC_TX_RING_SIZE;
+	}
+
+	for (i = 0; i < priv->num_rx_queues; i++) {
+		priv->rx_queue[i]->rx_ring_size = CTCMAC_RX_RING_SIZE;
+	}
+
+	set_bit(CTCMAC_DOWN, &priv->state);
+
+	if(!g_reglock_init_done)
+		spin_lock_init(&global_reglock);
+
+	g_reglock_init_done = 1;
+
+	spin_lock_init(&priv->reglock);
+	/* Carrier starts down, phylib will bring it up */
+	netif_carrier_off(dev);
+	err = register_netdev(dev);
+	if (err) {
+		goto register_fail;
+	}
+
+	if(!g_mac_unit_init_done){
+		writel(0x07, &priv->cpumacu_reg->CpuMacUnitResetCtl);
+		writel(0x00, &priv->cpumacu_reg->CpuMacUnitResetCtl);
+		
+		clrsetbits(&priv->cpumacu_reg->CpuMacUnitTsCfg, 
+		            0, CPU_MAC_UNIT_TS_CFG_W0_CFG_FORCE_S_AND_NS_EN);
+		if (priv->interface == PHY_INTERFACE_MODE_SGMII){
+			clrsetbits(&priv->cpumacu_reg->CpuMacUnitRefPulseCfg[1], 
+			                        CPU_MAC_UNIT_REF_PULSE_CFG_W1_REF_LINK_PULSE_RST,0);
+
+			ctc_mac_serdes_init(priv);
+		}
+		g_mac_unit_init_done = 1;
+	}
+
+	ctcmac_pps_init(priv);
+	
+	mdelay(10);
+	
+	sprintf(priv->irqinfo[CTCMAC_NORMAL].name, "%s%s",
+				dev->name, "_normal");
+	sprintf(priv->irqinfo[CTCMAC_FUNC].name, "%s%s",
+				dev->name, "_func");
+
+	return 0;
+
+	register_fail:
+	ctcmac_unmap_io_space(priv);
+	ctcmac_free_rx_queues(priv);
+	ctcmac_free_tx_queues(priv);
+	of_node_put(priv->phy_node);
+	ctcmac_free_dev(priv);
+
+	return err;
+}
+
+static int ctcmac_remove(struct platform_device *ofdev)
+{
+	struct ctcmac_private *priv = platform_get_drvdata(ofdev);
+	
+	device_remove_file(&priv->ndev->dev, &dev_attr_rxq0_pps);
+	device_remove_file(&priv->ndev->dev, &dev_attr_rxq1_pps);
+	
+	of_node_put(priv->phy_node);
+
+	unregister_netdev(priv->ndev);
+
+	ctcmac_unmap_io_space(priv);
+	ctcmac_free_rx_queues(priv);
+	ctcmac_free_tx_queues(priv);
+	ctcmac_free_dev(priv);
+
+	return 0;
+}
+
+static const struct of_device_id ctcmac_match[] =
+{
+	{
+		.type = "network",
+		.compatible = "ctc,mac",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, ctcmac_match);
+
+/* Structure for a device driver */
+static struct platform_driver ctcmac_driver = {
+	.driver = {
+		.name = "ctc-cpumac",
+		.of_match_table = ctcmac_match,
+	},
+	.probe = ctcmac_probe,
+	.remove = ctcmac_remove,
+};
+
+module_platform_driver(ctcmac_driver);
+MODULE_LICENSE("GPL");
+
+static int ctcmac_set_ffe(struct ctcmac_private *priv, u16 coefficient[])
+{
+	u32 val;
+	
+
+	if(priv->index == 0){
+		val = readl(&priv->cpumacu_reg->CpuMacUnitHssCfg[3]);
+		val |= BIT(CPU_MAC_UNIT_HSS_CFG_W3_CFG_HSS_L0_PCS_EN_ADV_BIT)
+			| BIT(CPU_MAC_UNIT_HSS_CFG_W3_CFG_HSS_L0_PCS_EN_DLY_BIT);
+		val &= ~CPU_MAC_UNIT_HSS_CFG_W3_CFG_HSS_L0_PCS_TAP_ADV_MASK;
+		val |= (coefficient[0]<<CPU_MAC_UNIT_HSS_CFG_W3_CFG_HSS_L0_PCS_TAP_ADV_BIT);
+		val &= ~CPU_MAC_UNIT_HSS_CFG_W3_CFG_HSS_L0_PCS_TAP_DLY_MASK;
+		val |= (coefficient[2]<<CPU_MAC_UNIT_HSS_CFG_W3_CFG_HSS_L0_PCS_TAP_DLY_BIT);
+		writel(val, &priv->cpumacu_reg->CpuMacUnitHssCfg[3]);
+		val = readl(&priv->cpumacu_reg->CpuMacUnitHssCfg[6]);
+		val &= ~CPU_MAC_UNIT_HSS_CFG_W6_CFG_HSS_L0_PCS2_PMA_TX_MARGIN_MASK;
+		val |= (coefficient[1]<<CPU_MAC_UNIT_HSS_CFG_W6_CFG_HSS_L0_PCS2_PMA_TX_MARGIN_BIT);
+		writel(val, &priv->cpumacu_reg->CpuMacUnitHssCfg[6]);
+	}else{
+		val = readl(&priv->cpumacu_reg->CpuMacUnitHssCfg[9]);
+		val |= BIT(CPU_MAC_UNIT_HSS_CFG_W9_CFG_HSS_L1_PCS_EN_ADV_BIT)
+			| BIT(CPU_MAC_UNIT_HSS_CFG_W9_CFG_HSS_L1_PCS_EN_DLY_BIT);
+		val &= ~CPU_MAC_UNIT_HSS_CFG_W9_CFG_HSS_L1_PCS_TAP_ADV_MASK;
+		val |= (coefficient[0]<<CPU_MAC_UNIT_HSS_CFG_W9_CFG_HSS_L1_PCS_TAP_ADV_BIT);
+		val &= ~CPU_MAC_UNIT_HSS_CFG_W9_CFG_HSS_L1_PCS_TAP_DLY_MASK;
+		val |= (coefficient[2]<<CPU_MAC_UNIT_HSS_CFG_W9_CFG_HSS_L1_PCS_TAP_DLY_BIT);
+		writel(val, &priv->cpumacu_reg->CpuMacUnitHssCfg[9]);
+		val = readl(&priv->cpumacu_reg->CpuMacUnitHssCfg[12]);
+		val &= ~CPU_MAC_UNIT_HSS_CFG_W12_CFG_HSS_L1_PCS2_PMA_TX_MARGIN_MASK;
+		val |= (coefficient[1]<<CPU_MAC_UNIT_HSS_CFG_W12_CFG_HSS_L1_PCS2_PMA_TX_MARGIN_BIT);
+		writel(val, &priv->cpumacu_reg->CpuMacUnitHssCfg[12]);
+	}
+
+	return 0;
+}
+
+static int ctcmac_get_ffe(struct ctcmac_private *priv, u16 coefficient[])
+{
+	u32 val;
+	
+	if(priv->index == 0){
+		val = readl(&priv->cpumacu_reg->CpuMacUnitHssCfg[3]);
+		coefficient[0] = (val&CPU_MAC_UNIT_HSS_CFG_W3_CFG_HSS_L0_PCS_TAP_ADV_MASK) 
+			>> CPU_MAC_UNIT_HSS_CFG_W3_CFG_HSS_L0_PCS_TAP_ADV_BIT;
+		coefficient[2] = (val &  CPU_MAC_UNIT_HSS_CFG_W3_CFG_HSS_L0_PCS_TAP_DLY_MASK) 
+			>>CPU_MAC_UNIT_HSS_CFG_W3_CFG_HSS_L0_PCS_TAP_DLY_BIT;
+		val = readl(&priv->cpumacu_reg->CpuMacUnitHssCfg[6]);
+		coefficient[1] = (val &  CPU_MAC_UNIT_HSS_CFG_W6_CFG_HSS_L0_PCS2_PMA_TX_MARGIN_MASK) 
+			>>CPU_MAC_UNIT_HSS_CFG_W6_CFG_HSS_L0_PCS2_PMA_TX_MARGIN_BIT;
+
+	}else{
+		val = readl(&priv->cpumacu_reg->CpuMacUnitHssCfg[9]);
+		coefficient[0] = (val&CPU_MAC_UNIT_HSS_CFG_W9_CFG_HSS_L1_PCS_TAP_ADV_MASK) 
+			>> CPU_MAC_UNIT_HSS_CFG_W9_CFG_HSS_L1_PCS_TAP_ADV_BIT;
+		coefficient[2] = (val &  CPU_MAC_UNIT_HSS_CFG_W9_CFG_HSS_L1_PCS_TAP_DLY_MASK) 
+			>>CPU_MAC_UNIT_HSS_CFG_W9_CFG_HSS_L1_PCS_TAP_DLY_BIT;
+		val = readl(&priv->cpumacu_reg->CpuMacUnitHssCfg[12]);
+		coefficient[1] = (val &  CPU_MAC_UNIT_HSS_CFG_W12_CFG_HSS_L1_PCS2_PMA_TX_MARGIN_MASK)
+			>>CPU_MAC_UNIT_HSS_CFG_W12_CFG_HSS_L1_PCS2_PMA_TX_MARGIN_BIT;
+	}
+	
+	return 0;
+}
+
diff --git a/drivers/net/ethernet/centec/ctcmac.h b/drivers/net/ethernet/centec/ctcmac.h
new file mode 100644
index 0000000..be49d8a
--- /dev/null
+++ b/drivers/net/ethernet/centec/ctcmac.h
@@ -0,0 +1,315 @@
+/*
+ * Centec CpuMac Ethernet Driver -- CpuMac controller implementation
+ * Provides Bus interface for MIIM regs
+ *
+ * Author: liuht <liuht@centecnetworks.com>
+ *
+ * Copyright 2002-2017, Centec Networks (Suzhou) Co., Ltd.
+ *
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#ifndef __CTCMAC_H
+#define __CTCMAC_H
+
+#define TX_TIMEOUT      (5*HZ)
+
+#define CTCMAC_DEFAULT_MTU 1500
+#define CTCMAC_MIN_PKT_LEN   64
+
+#define CTCMAC_TX_QUEUE_MAX   1
+#define CTCMAC_RX_QUEUE_MAX   2
+
+#define CTCMAC0_EXSRAM_BASE         0x0
+#define CTCMAC1_EXSRAM_BASE         0x1800
+#define CTCMAC_MAX_RING_SIZE        1023
+#define CTCMAC_TX_RING_SIZE   1023
+#define CTCMAC_RX_RING_SIZE   1023
+#define CTCMAC_RX_BUFF_ALLOC  16
+#define CTCMAC_INTERNAL_RING_SIZE 64
+
+/* The maximum number of packets to be handled in one call of gfar_poll */
+#define CTCMAC_NAIP_RX_WEIGHT 16
+#define CTCMAC_NAIP_TX_WEIGHT 16
+
+#define CTCMAC_RXB_SIZE 1024
+#define CTCMAC_SKBFRAG_SIZE (CTCMAC_RXB_SIZE \
+			  + SKB_DATA_ALIGN(sizeof(struct skb_shared_info)))
+#define CTCMAC_RXB_TRUESIZE 2048
+#define BUF_ALIGNMENT 256
+#define CTCMAC_JUMBO_FRAME_SIZE 9600
+
+#define CTCMAC_TOKEN_PER_PKT  10
+#define CTCMAC_TIMER_COMPENSATE 1
+
+#define CTCMAC_NOR_RX1_R    (1<<7)
+#define CTCMAC_NOR_RX0_R    (1<<6)
+#define CTCMAC_NOR_RX1_D    (1<<5)
+#define CTCMAC_NOR_RX0_D    (1<<4)
+#define CTCMAC_NOR_TX_D     (1<<3)
+#define CTCMAC_NOR_AN_D     (1<<2)
+#define CTCMAC_NOR_LINK_DOWN     (1<<1)
+#define CTCMAC_NOR_LINK_UP       (1<<0)
+
+#define CTC_DDR_BASE 0x80000000
+
+#define CSA_SGMII_MD_MASK 0x00000008 
+#define CSA_EN  0x00000001
+
+/*Mask*/
+/*CTCMAC_SGMII_CFG*/
+#define CSC_REP_MASK   0x1fc00000
+#define CSC_SMP_MASK   0x1fc00000
+/*CTCMAC_SGMII_MON*/
+#define CSM_ANST_MASK 0x00000007
+  
+
+#define CSC_1000M 0x00000000
+#define CSC_100M  0x02400000
+#define CSC_10M    0x18c00000
+
+#define CTCMAC_DESC_INT_NUM 1
+
+#define CTCMAC_SUPPORTED (SUPPORTED_10baseT_Full \
+		| SUPPORTED_100baseT_Full \
+		| SUPPORTED_1000baseT_Full \
+		| SUPPORTED_Autoneg)
+
+#define CTCMAC_STATS_LEN  (sizeof(struct ctcmac_pkt_stats)/sizeof(u64))
+
+struct ctcmac_skb_cb {
+	unsigned int bytes_sent; /* bytes-on-wire (i.e. no FCB) */
+};
+#define CTCMAC_CB(skb) ((struct ctcmac_skb_cb *)((skb)->cb))
+
+enum ctcmac_irqinfo_id {
+    CTCMAC_NORMAL = 0,
+    CTCMAC_FUNC,
+    CTCMAC_UNIT,
+    CTCMAC_NUM_IRQS
+};
+
+enum ctcmac_dev_state {
+    CTCMAC_DOWN = 1,
+    CTCMAC_RESETTING
+};
+
+enum ctcmac_int_type {
+    CTCMAC_INT_PACKET = 1,
+    CTCMAC_INT_DESC,
+    CTCMAC_INT_MAX
+};
+
+enum ctcmac_autoneg{
+	CTCMAC_AUTONEG_1000BASEX_M,
+	CTCMAC_AUTONEG_PHY_M,
+	CTCMAC_AUTONEG_MAC_M,
+	CTCMAC_AUTONEG_DISABLE,
+	CTCMAC_AUTONEG_MAX
+};
+
+/*
+ * Per TX queue stats
+ */
+struct txq_stats {
+    unsigned long tx_packets;
+    unsigned long tx_bytes;
+};
+
+struct ctcmac_tx_buff {
+    void *vaddr;
+    dma_addr_t dma;
+    u32 len;
+    u32 offset;
+    bool alloc;
+};
+
+struct ctcmac_priv_tx_q {
+    spinlock_t txlock __attribute__ ((aligned (SMP_CACHE_BYTES)));
+    struct	ctcmac_tx_buff tx_buff[CTCMAC_MAX_RING_SIZE+1];
+    unsigned int num_txbdfree;
+    u16 tx_ring_size;
+    u16 qindex;
+    u16 next_to_alloc;
+    u16 next_to_clean;
+    struct txq_stats stats;
+    struct net_device *dev;
+    struct sk_buff **tx_skbuff;
+};
+
+/*
+ * Per RX queue stats
+ */
+struct rxq_stats {
+    unsigned long rx_packets;
+    unsigned long rx_bytes;
+    unsigned long rx_dropped;
+};
+
+struct ctcmac_rx_buff {
+    dma_addr_t dma;
+    struct page *page;
+    unsigned int page_offset;
+};
+
+struct ctcmac_priv_rx_q {
+	struct	ctcmac_rx_buff *rx_buff __aligned(SMP_CACHE_BYTES);
+	struct	net_device *ndev;
+	struct	device *dev;
+	u16 rx_ring_size;
+	u16 qindex;
+	u16 next_to_clean;
+	u16 next_to_use;
+	u16 next_to_alloc;
+	struct	sk_buff *skb;
+	struct rxq_stats stats;
+	struct	napi_struct napi_rx;
+	struct	napi_struct napi_tx;
+	u32 pps_limit;
+	u32 token, token_max;
+	u32 rx_trigger;
+};
+
+struct ctcmac_irqinfo {
+    unsigned int irq;
+    char name[32];
+};
+
+struct ctcmac_desc_cfg
+{
+    u8 err_type; /*used when err == 1*/
+    u8 err;
+    u8 eop;
+    u8 sop;
+    u32 size;
+    u32 addr_high;
+    u32 addr_low;
+};
+
+struct ctcmac_private {
+	spinlock_t reglock __aligned(SMP_CACHE_BYTES);
+	struct device *dev;
+	struct net_device *ndev;
+	void __iomem *iobase;
+	struct CpuMac_regs __iomem *cpumac_reg;
+	struct CpuMac_mems __iomem *cpumac_mem;
+	struct CpuMacUnit_regs *cpumacu_reg;
+	u32 device_flags;
+	int irq_num;
+	int index;
+
+	struct ctcmac_priv_tx_q *tx_queue[CTCMAC_TX_QUEUE_MAX];
+	struct ctcmac_priv_rx_q *rx_queue[CTCMAC_RX_QUEUE_MAX];
+
+	unsigned long state;
+	unsigned int num_tx_queues;
+	unsigned int num_rx_queues;
+
+	/* PHY stuff */
+	phy_interface_t interface;
+	struct device_node *phy_node;
+	struct mii_bus *mii_bus;
+	int oldspeed;
+	int oldlink;	
+	int oldduplex;
+
+	struct work_struct reset_task;
+	struct platform_device *ofdev;
+	struct	napi_struct napi_rx;
+	struct	napi_struct napi_tx;
+	struct  ctcmac_irqinfo irqinfo[CTCMAC_NUM_IRQS];
+	
+	int hwts_rx_en;
+	int hwts_tx_en;
+	u32 autoneg_mode;
+	u32 supported;
+	u32 msg_enable;
+	u32 int_type;
+	struct timer_list token_timer;
+};
+
+struct ctcmac_pkt_stats{
+	u64 rx_good_ucast_bytes;
+	u64 rx_good_ucast_pkt  ;
+	u64 rx_good_mcast_bytes;
+	u64 rx_good_mcast_pkt  ;
+	u64 rx_good_bcast_bytes;
+	u64 rx_good_bcast_pkt  ;
+	u64 rx_good_pause_bytes;
+	u64 rx_good_pause_pkt  ;
+	u64 rx_good_pfc_bytes  ;
+	u64 rx_good_pfc_pkt    ;
+	u64 rx_good_control_bytes;
+	u64 rx_good_control_pkt;
+	u64 rx_fcs_error_bytes ;
+	u64 rx_fcs_error_pkt   ;
+	u64 rx_mac_overrun_bytes;
+	u64 rx_mac_overrun_pkt ;
+	u64 rx_good_63B_bytes  ;
+	u64 rx_good_63B_pkt    ;
+	u64 rx_bad_63B_bytes   ;
+	u64 rx_bad_63B_pkt     ;
+	u64 rx_good_mtu2B_bytes;
+	u64 rx_good_mtu2B_pkt  ;
+	u64 rx_bad_mtu2B_bytes ;
+	u64 rx_bad_mtu2B_pkt   ;
+	u64 rx_good_jumbo_bytes;
+	u64 rx_good_jumbo_pkt  ;
+	u64 rx_bad_jumbo_bytes ;
+	u64 rx_bad_jumbo_pkt   ;
+	u64 rx_64B_bytes       ;
+	u64 rx_64B_pkt         ;
+	u64 rx_127B_bytes      ;
+	u64 rx_127B_pkt        ;
+	u64 rx_255B_bytes      ;
+	u64 rx_255B_pkt        ;
+	u64 rx_511B_bytes      ;
+	u64 rx_511B_pkt        ;
+	u64 rx_1023B_bytes     ;
+	u64 rx_1023B_pkt       ;
+	u64 rx_mtu1B_bytes     ;
+	u64 rx_mtu1B_pkt       ;
+	u64 tx_ucast_bytes     ;
+	u64 tx_ucast_pkt       ;
+	u64 tx_mcast_bytes     ;
+	u64 tx_mcast_pkt       ;
+	u64 tx_bcast_bytes     ;
+	u64 tx_bcast_pkt       ;
+	u64 tx_pause_bytes     ;
+	u64 tx_pause_pkt       ;
+	u64 tx_control_bytes   ;
+	u64 tx_control_pkt     ;
+	u64 tx_fcs_error_bytes ;
+	u64 tx_fcs_error_pkt   ;
+	u64 tx_underrun_bytes  ;
+	u64 tx_underrun_pkt    ;
+	u64 tx_63B_bytes       ;
+	u64 tx_63B_pkt         ;
+	u64 tx_64B_bytes       ;
+	u64 tx_64B_pkt         ;
+	u64 tx_127B_bytes      ;
+	u64 tx_127B_pkt        ;
+	u64 tx_255B_bytes      ;
+	u64 tx_255B_pkt        ;
+	u64 tx_511B_bytes      ;
+	u64 tx_511B_pkt        ;
+	u64 tx_1023B_bytes     ;
+	u64 tx_1023B_pkt       ;
+	u64 tx_mtu1_bytes     ;
+	u64 tx_mtu1_pkt       ;
+	u64 tx_mtu2_bytes     ;
+	u64 tx_mtu2_pkt       ;
+	u64 tx_jumbo_bytes     ;
+	u64 tx_jumbo_pkt       ;
+	u64 mtu1;
+	u64 mtu2;
+};
+
+
+#endif
+
diff --git a/drivers/net/ethernet/centec/ctcmac_reg.h b/drivers/net/ethernet/centec/ctcmac_reg.h
new file mode 100644
index 0000000..affda1a
--- /dev/null
+++ b/drivers/net/ethernet/centec/ctcmac_reg.h
@@ -0,0 +1,5416 @@
+#ifndef __CTCMAC_H__
+#define __CTCMAC_H__
+
+#define CPUMAC_MEM_BASE   0x00004000
+#define CPUMAC_REG_BASE   0x00000000
+
+struct CpuMac_regs {
+   u32 CpuMacAxiCfg;                    /* 0x00000000 */
+   u32 CpuMacAxiMon;                    /* 0x00000004 */
+   u32 CpuMacDescCfg[2];                /* 0x00000008 */
+   u32 CpuMacBufferCfg[3];              /* 0x00000010 */
+   u32 rsv7;
+   u32 CpuMacDebugStats[3];             /* 0x00000020 */
+   u32 rsv11;
+   u32 CpuMacDescMon[3];                /* 0x00000030 */
+   u32 rsv15;
+   u32 CpuMacDmaWeightCfg;              /* 0x00000040 */
+   u32 CpuMacInit;                      /* 0x00000044 */
+   u32 CpuMacInitDone;                  /* 0x00000048 */
+   u32 CpuMacParityCtl;                 /* 0x0000004c */
+   u32 CpuMacExtRamCfg[2];              /* 0x00000050 */
+   u32 rsv22;
+   u32 rsv23;
+   u32 CpuMacFifoCtl[4];                /* 0x00000060 */
+   u32 CpuMacGmacCfg[4];                /* 0x00000070 */
+   u32 CpuMacRamChkRec;                 /* 0x00000080 */
+   u32 CpuMacReset;                     /* 0x00000084 */
+   u32 CpuMacSgmiiAutoNegCfg;           /* 0x00000088 */
+   u32 CpuMacReserved;                  /* 0x0000008c */
+   u32 CpuMacGmacMon[2];                /* 0x00000090 */
+   u32 CpuMacCreditCtl;                 /* 0x00000098 */
+   u32 CpuMacCreditStatus;              /* 0x0000009c */
+   u32 CpuMacPauseCfg[4];               /* 0x000000a0 */
+   u32 CpuMacPauseMon[3];               /* 0x000000b0 */
+   u32 rsv47;
+   u32 CpuMacSgmiiCfg[2];               /* 0x000000c0 */
+   u32 CpuMacSgmiiMon[2];               /* 0x000000c8 */
+   u32 CpuMacStatsCfg[2];               /* 0x000000d0 */
+   u32 rsv54;
+   u32 rsv55;
+   u32 CpuMacInterruptFunc[4];          /* 0x000000e0 */
+   u32 CpuMacInterruptNormal[4];        /* 0x000000f0 */
+   u32 CpuMacFifoStatus[3];             /* 0x00000100 */
+};
+
+/* ################################################################################
+ * # CpuMacAxiCfg Definition
+ */
+#define CPU_MAC_AXI_CFG_W0_CFG_AXI_WR_BURST_LEN                      BIT(0)
+#define CPU_MAC_AXI_CFG_W0_CFG_AXI_WR_WORD_SWAP_EN                   BIT(18)
+#define CPU_MAC_AXI_CFG_W0_CFG_AXI_WR_D_WORD_SWAP_EN                 BIT(19)
+#define CPU_MAC_AXI_CFG_W0_CFG_AXI_RD_D_WORD_SWAP_EN                 BIT(17)
+#define CPU_MAC_AXI_CFG_W0_CFG_AXI_RD_ADDR_ALIGN_EN                  BIT(20)
+#define CPU_MAC_AXI_CFG_W0_CFG_AXI_RD_BURST_LEN                      BIT(8)
+#define CPU_MAC_AXI_CFG_W0_CFG_AXI_RD_WORD_SWAP_EN                   BIT(16)
+
+#define CPU_MAC_AXI_CFG_W0_CFG_AXI_WR_BURST_LEN_MASK                 0x000000ff
+#define CPU_MAC_AXI_CFG_W0_CFG_AXI_WR_WORD_SWAP_EN_MASK              0x00040000
+#define CPU_MAC_AXI_CFG_W0_CFG_AXI_WR_D_WORD_SWAP_EN_MASK            0x00080000
+#define CPU_MAC_AXI_CFG_W0_CFG_AXI_RD_D_WORD_SWAP_EN_MASK            0x00020000
+#define CPU_MAC_AXI_CFG_W0_CFG_AXI_RD_ADDR_ALIGN_EN_MASK             0x00100000
+#define CPU_MAC_AXI_CFG_W0_CFG_AXI_RD_BURST_LEN_MASK                 0x0000ff00
+#define CPU_MAC_AXI_CFG_W0_CFG_AXI_RD_WORD_SWAP_EN_MASK              0x00010000
+
+/* ################################################################################
+ * # CpuMacAxiMon Definition
+ */
+#define CPU_MAC_AXI_MON_W0_MON_AXI_WR_RESP                           BIT(4)
+#define CPU_MAC_AXI_MON_W0_MON_AXI_RD_RESP                           BIT(0)
+
+#define CPU_MAC_AXI_MON_W0_MON_AXI_WR_RESP_MASK                      0x00000070
+#define CPU_MAC_AXI_MON_W0_MON_AXI_RD_RESP_MASK                      0x00000007
+
+/* ################################################################################
+ * # CpuMacDescCfg Definition
+ */
+#define CPU_MAC_DESC_CFG_W0_CFG_TX_DESC_DONE_INTR_EOP_EN             BIT(30)
+#define CPU_MAC_DESC_CFG_W0_CFG_RX_DESC_DONE_INTR_EOP_EN             BIT(29)
+#define CPU_MAC_DESC_CFG_W0_CFG_RX_DESC0_DONE_INTR_THRD              BIT(8)
+#define CPU_MAC_DESC_CFG_W0_CFG_TX_DESC_DONE_INTR_THRD               BIT(0)
+#define CPU_MAC_DESC_CFG_W0_CFG_RX_DESC1_DONE_INTR_THRD              BIT(16)
+#define CPU_MAC_DESC_CFG_W0_CFG_TX_DESC_ACK_EN                       BIT(31)
+#define CPU_MAC_DESC_CFG_W1_CFG_RX_DESC0_REQ_INTR_THRD               BIT(0)
+#define CPU_MAC_DESC_CFG_W1_CFG_RX_DESC1_REQ_INTR_THRD               BIT(8)
+
+#define CPU_MAC_DESC_CFG_W0_CFG_TX_DESC_DONE_INTR_EOP_EN_MASK        0x40000000
+#define CPU_MAC_DESC_CFG_W0_CFG_RX_DESC_DONE_INTR_EOP_EN_MASK        0x20000000
+#define CPU_MAC_DESC_CFG_W0_CFG_RX_DESC0_DONE_INTR_THRD_MASK         0x0000ff00
+#define CPU_MAC_DESC_CFG_W0_CFG_TX_DESC_DONE_INTR_THRD_MASK          0x000000ff
+#define CPU_MAC_DESC_CFG_W0_CFG_RX_DESC1_DONE_INTR_THRD_MASK         0x00ff0000
+#define CPU_MAC_DESC_CFG_W0_CFG_TX_DESC_ACK_EN_MASK                  0x80000000
+#define CPU_MAC_DESC_CFG_W1_CFG_RX_DESC0_REQ_INTR_THRD_MASK          0x000000ff
+#define CPU_MAC_DESC_CFG_W1_CFG_RX_DESC1_REQ_INTR_THRD_MASK          0x0000ff00
+
+/* ################################################################################
+ * # CpuMacBufferCfg Definition
+ */
+#define CPU_MAC_BUFFER_CFG_W0_CFG_RX_X_OFF_THRD                      BIT(16)
+#define CPU_MAC_BUFFER_CFG_W0_CFG_RX_X_ON_THRD                       BIT(0)
+#define CPU_MAC_BUFFER_CFG_W1_CFG_RX_RSV_THRD                        BIT(0)
+#define CPU_MAC_BUFFER_CFG_W1_CFG_RX_FLUSH_THRD                      BIT(16)
+#define CPU_MAC_BUFFER_CFG_W2_CFG_RX_FLUSH_EN                        BIT(0)
+
+#define CPU_MAC_BUFFER_CFG_W0_CFG_RX_X_OFF_THRD_MASK                 0x3fff0000
+#define CPU_MAC_BUFFER_CFG_W0_CFG_RX_X_ON_THRD_MASK                  0x00003fff
+#define CPU_MAC_BUFFER_CFG_W1_CFG_RX_RSV_THRD_MASK                   0x00003fff
+#define CPU_MAC_BUFFER_CFG_W1_CFG_RX_FLUSH_THRD_MASK                 0x3fff0000
+#define CPU_MAC_BUFFER_CFG_W2_CFG_RX_FLUSH_EN_MASK                   0x00000001
+
+/* ################################################################################
+ * # CpuMacDebugStats Definition
+ */
+#define CPU_MAC_DEBUG_STATS_W0_DMA_RX_ERROR_CNT                      BIT(20)
+#define CPU_MAC_DEBUG_STATS_W0_GMAC_TX_SOP_CNT                       BIT(24)
+#define CPU_MAC_DEBUG_STATS_W0_GMAC_RX_SOP_CNT                       BIT(0)
+#define CPU_MAC_DEBUG_STATS_W0_GMAC_RX_EOP_CNT                       BIT(4)
+#define CPU_MAC_DEBUG_STATS_W0_GMAC_TX_EOP_CNT                       BIT(28)
+#define CPU_MAC_DEBUG_STATS_W0_DMA_RX_EOP_CNT                        BIT(16)
+#define CPU_MAC_DEBUG_STATS_W0_GMAC_RX_ERROR_CNT                     BIT(8)
+#define CPU_MAC_DEBUG_STATS_W0_DMA_RX_SOP_CNT                        BIT(12)
+#define CPU_MAC_DEBUG_STATS_W1_DMA_TX_EOP_CNT                        BIT(8)
+#define CPU_MAC_DEBUG_STATS_W1_GMAC_TX_PTP_ERR_CNT                   BIT(16)
+#define CPU_MAC_DEBUG_STATS_W1_DMA_TX_SOP_CNT                        BIT(4)
+#define CPU_MAC_DEBUG_STATS_W1_DMA_TX_ERROR_CNT                      BIT(12)
+#define CPU_MAC_DEBUG_STATS_W1_GMAC_TX_ERROR_CNT                     BIT(0)
+#define CPU_MAC_DEBUG_STATS_W2_AXI_RD_BURST_CNT                      BIT(8)
+#define CPU_MAC_DEBUG_STATS_W2_EXT_RAM_SBE_CNT                       BIT(16)
+#define CPU_MAC_DEBUG_STATS_W2_AXI_RD_BURST_ERR_CNT                  BIT(12)
+#define CPU_MAC_DEBUG_STATS_W2_AXI_WR_BURST_CNT                      BIT(0)
+#define CPU_MAC_DEBUG_STATS_W2_AXI_WR_BURST_ERR_CNT                  BIT(4)
+
+#define CPU_MAC_DEBUG_STATS_W0_DMA_RX_ERROR_CNT_MASK                 0x00f00000
+#define CPU_MAC_DEBUG_STATS_W0_GMAC_TX_SOP_CNT_MASK                  0x0f000000
+#define CPU_MAC_DEBUG_STATS_W0_GMAC_RX_SOP_CNT_MASK                  0x0000000f
+#define CPU_MAC_DEBUG_STATS_W0_GMAC_RX_EOP_CNT_MASK                  0x000000f0
+#define CPU_MAC_DEBUG_STATS_W0_GMAC_TX_EOP_CNT_MASK                  0xf0000000
+#define CPU_MAC_DEBUG_STATS_W0_DMA_RX_EOP_CNT_MASK                   0x000f0000
+#define CPU_MAC_DEBUG_STATS_W0_GMAC_RX_ERROR_CNT_MASK                0x00000f00
+#define CPU_MAC_DEBUG_STATS_W0_DMA_RX_SOP_CNT_MASK                   0x0000f000
+#define CPU_MAC_DEBUG_STATS_W1_DMA_TX_EOP_CNT_MASK                   0x00000f00
+#define CPU_MAC_DEBUG_STATS_W1_GMAC_TX_PTP_ERR_CNT_MASK              0x000f0000
+#define CPU_MAC_DEBUG_STATS_W1_DMA_TX_SOP_CNT_MASK                   0x000000f0
+#define CPU_MAC_DEBUG_STATS_W1_DMA_TX_ERROR_CNT_MASK                 0x0000f000
+#define CPU_MAC_DEBUG_STATS_W1_GMAC_TX_ERROR_CNT_MASK                0x0000000f
+#define CPU_MAC_DEBUG_STATS_W2_AXI_RD_BURST_CNT_MASK                 0x00000f00
+#define CPU_MAC_DEBUG_STATS_W2_EXT_RAM_SBE_CNT_MASK                  0x000f0000
+#define CPU_MAC_DEBUG_STATS_W2_AXI_RD_BURST_ERR_CNT_MASK             0x0000f000
+#define CPU_MAC_DEBUG_STATS_W2_AXI_WR_BURST_CNT_MASK                 0x0000000f
+#define CPU_MAC_DEBUG_STATS_W2_AXI_WR_BURST_ERR_CNT_MASK             0x000000f0
+
+/* ################################################################################
+ * # CpuMacDescMon Definition
+ */
+#define CPU_MAC_DESC_MON_W0_MON_DESC_AVAIL_NUM0                      BIT(0)
+#define CPU_MAC_DESC_MON_W0_MON_DESC_AVAIL_NUM1                      BIT(16)
+#define CPU_MAC_DESC_MON_W1_MON_DESC_AVAIL_NUM2                      BIT(0)
+#define CPU_MAC_DESC_MON_W1_MON_DESC_DONE_NUM0                       BIT(16)
+#define CPU_MAC_DESC_MON_W2_MON_DESC_DONE_NUM1                       BIT(0)
+#define CPU_MAC_DESC_MON_W2_MON_DESC_DONE_NUM2                       BIT(16)
+
+#define CPU_MAC_DESC_MON_W0_MON_DESC_AVAIL_NUM0_MASK                 0x0000ffff
+#define CPU_MAC_DESC_MON_W0_MON_DESC_AVAIL_NUM1_MASK                 0xffff0000
+#define CPU_MAC_DESC_MON_W1_MON_DESC_AVAIL_NUM2_MASK                 0x0000ffff
+#define CPU_MAC_DESC_MON_W1_MON_DESC_DONE_NUM0_MASK                  0xffff0000
+#define CPU_MAC_DESC_MON_W2_MON_DESC_DONE_NUM1_MASK                  0x0000ffff
+#define CPU_MAC_DESC_MON_W2_MON_DESC_DONE_NUM2_MASK                  0xffff0000
+
+/* ################################################################################
+ * # CpuMacDmaWeightCfg Definition
+ */
+#define CPU_MAC_DMA_WEIGHT_CFG_W0_CFG_DMA_RX_WEIGHT1                 BIT(8)
+#define CPU_MAC_DMA_WEIGHT_CFG_W0_CFG_DMA_RX_WEIGHT0                 BIT(0)
+
+#define CPU_MAC_DMA_WEIGHT_CFG_W0_CFG_DMA_RX_WEIGHT1_MASK            0x00000f00
+#define CPU_MAC_DMA_WEIGHT_CFG_W0_CFG_DMA_RX_WEIGHT0_MASK            0x0000000f
+
+/* ################################################################################
+ * # CpuMacInit Definition
+ */
+#define CPU_MAC_INIT_W0_INIT                                         BIT(0)
+
+#define CPU_MAC_INIT_W0_INIT_MASK                                    0x00000001
+
+/* ################################################################################
+ * # CpuMacInitDone Definition
+ */
+#define CPU_MAC_INIT_DONE_W0_INIT_DONE                               BIT(0)
+
+#define CPU_MAC_INIT_DONE_W0_INIT_DONE_MASK                          0x00000001
+
+/* ################################################################################
+ * # CpuMacParityCtl Definition
+ */
+#define CPU_MAC_PARITY_CTL_W0_RX_PKT_MSG_FIFO_PARITY_EN              BIT(2)
+#define CPU_MAC_PARITY_CTL_W0_TX_PKT_FIFO_PARITY_EN                  BIT(4)
+#define CPU_MAC_PARITY_CTL_W0_EXT_RAM_ECC_DETECT_DIS                 BIT(8)
+#define CPU_MAC_PARITY_CTL_W0_CPU_MAC_STATS_RAM_PARITY_EN            BIT(0)
+#define CPU_MAC_PARITY_CTL_W0_RX_DESC0_CFG_FIFO_PARITY_EN            BIT(5)
+#define CPU_MAC_PARITY_CTL_W0_RX_PKT_DATA_FIFO_PARITY_EN             BIT(1)
+#define CPU_MAC_PARITY_CTL_W0_TX_DESC_CFG_FIFO_PARITY_EN             BIT(7)
+#define CPU_MAC_PARITY_CTL_W0_RX_DESC1_CFG_FIFO_PARITY_EN            BIT(6)
+#define CPU_MAC_PARITY_CTL_W0_EXT_RAM_ECC_CORRECT_DIS                BIT(9)
+
+#define CPU_MAC_PARITY_CTL_W0_RX_PKT_MSG_FIFO_PARITY_EN_MASK         0x00000004
+#define CPU_MAC_PARITY_CTL_W0_TX_PKT_FIFO_PARITY_EN_MASK             0x00000010
+#define CPU_MAC_PARITY_CTL_W0_EXT_RAM_ECC_DETECT_DIS_MASK            0x00000100
+#define CPU_MAC_PARITY_CTL_W0_CPU_MAC_STATS_RAM_PARITY_EN_MASK       0x00000001
+#define CPU_MAC_PARITY_CTL_W0_RX_DESC0_CFG_FIFO_PARITY_EN_MASK       0x00000020
+#define CPU_MAC_PARITY_CTL_W0_RX_PKT_DATA_FIFO_PARITY_EN_MASK        0x00000002
+#define CPU_MAC_PARITY_CTL_W0_TX_DESC_CFG_FIFO_PARITY_EN_MASK        0x00000080
+#define CPU_MAC_PARITY_CTL_W0_RX_DESC1_CFG_FIFO_PARITY_EN_MASK       0x00000040
+#define CPU_MAC_PARITY_CTL_W0_EXT_RAM_ECC_CORRECT_DIS_MASK           0x00000200
+
+/* ################################################################################
+ * # CpuMacExtRamCfg Definition
+ */
+#define CPU_MAC_EXT_RAM_CFG_W0_CFG_EXT_RAM_EN                        BIT(31)
+#define CPU_MAC_EXT_RAM_CFG_W0_CFG_EXT_RAM_BASE_SIZE                 BIT(0)
+#define CPU_MAC_EXT_RAM_CFG_W1_CFG_EXT_RAM_BASE_ADDR                 BIT(0)
+
+#define CPU_MAC_EXT_RAM_CFG_W0_CFG_EXT_RAM_EN_MASK                   0x80000000
+#define CPU_MAC_EXT_RAM_CFG_W0_CFG_EXT_RAM_BASE_SIZE_MASK            0x000003ff
+#define CPU_MAC_EXT_RAM_CFG_W1_CFG_EXT_RAM_BASE_ADDR_MASK            0x000fffff
+
+/* ################################################################################
+ * # CpuMacFifoCtl Definition
+ */
+#define CPU_MAC_FIFO_CTL_W0_RX_PKT_DATA_FIFO_A_FULL_THRD             BIT(0)
+#define CPU_MAC_FIFO_CTL_W1_RX_PKT_MSG_FIFO_A_FULL_THRD              BIT(0)
+#define CPU_MAC_FIFO_CTL_W2_TX_PKT_FIFO_A_FULL_THRD                  BIT(0)
+#define CPU_MAC_FIFO_CTL_W3_RX_PKT_FIFO_A_FULL_THRD                  BIT(0)
+
+#define CPU_MAC_FIFO_CTL_W0_RX_PKT_DATA_FIFO_A_FULL_THRD_MASK        0x00001fff
+#define CPU_MAC_FIFO_CTL_W1_RX_PKT_MSG_FIFO_A_FULL_THRD_MASK         0x000003ff
+#define CPU_MAC_FIFO_CTL_W2_TX_PKT_FIFO_A_FULL_THRD_MASK             0x000007ff
+#define CPU_MAC_FIFO_CTL_W3_RX_PKT_FIFO_A_FULL_THRD_MASK             0x000003ff
+
+/* ################################################################################
+ * # CpuMacGmacCfg Definition
+ */
+#define CPU_MAC_GMAC_CFG_W0_CFG_RX_CUT_THROUGH_EN                    BIT(4)
+#define CPU_MAC_GMAC_CFG_W0_CFG_RX_UNDERSIZE_DROP_EN                 BIT(3)
+#define CPU_MAC_GMAC_CFG_W0_CFG_RX_ERROR_DROP_EN                     BIT(5)
+#define CPU_MAC_GMAC_CFG_W0_CFG_RX_TS_EN                             BIT(0)
+#define CPU_MAC_GMAC_CFG_W0_CFG_RX_OVERSIZE_DROP_EN                  BIT(2)
+#define CPU_MAC_GMAC_CFG_W0_CFG_RX_PAUSE_DROP_EN                     BIT(6)
+#define CPU_MAC_GMAC_CFG_W0_CFG_RX_OVERRUN_DROP_EN                   BIT(1)
+#define CPU_MAC_GMAC_CFG_W1_CFG_RX_MAX_PKT_LEN_CHK_EN                BIT(0)
+#define CPU_MAC_GMAC_CFG_W1_CFG_RX_MIN_PKT_LEN                       BIT(17)
+#define CPU_MAC_GMAC_CFG_W1_CFG_RX_MIN_PKT_LEN_CHK_EN                BIT(16)
+#define CPU_MAC_GMAC_CFG_W1_CFG_RX_MAX_PKT_LEN                       BIT(1)
+#define CPU_MAC_GMAC_CFG_W2_CFG_TX_START_THRD                        BIT(16)
+#define CPU_MAC_GMAC_CFG_W2_CFG_TX_ERR_MASK_OFF                      BIT(1)
+#define CPU_MAC_GMAC_CFG_W2_CFG_TX_PTP_ERR_EN                        BIT(6)
+#define CPU_MAC_GMAC_CFG_W2_CFG_TX_KEEP_TS_EN                        BIT(12)
+#define CPU_MAC_GMAC_CFG_W2_CFG_TX_PAUSE_STALL_EN                    BIT(4)
+#define CPU_MAC_GMAC_CFG_W2_CFG_TX_CUT_THROUGH_EN                    BIT(10)
+#define CPU_MAC_GMAC_CFG_W2_CFG_TX_STRIP_CRC_EN                      BIT(8)
+#define CPU_MAC_GMAC_CFG_W2_CFG_TX_PKT_EN                            BIT(5)
+#define CPU_MAC_GMAC_CFG_W2_CFG_TX_PAD_EN                            BIT(3)
+#define CPU_MAC_GMAC_CFG_W2_CFG_TX_WAIT_CAPTURE_TS                   BIT(9)
+#define CPU_MAC_GMAC_CFG_W2_CFG_TX_HDR_INFO_EN                       BIT(11)
+#define CPU_MAC_GMAC_CFG_W2_CFG_TX_LPI_EN                            BIT(2)
+#define CPU_MAC_GMAC_CFG_W2_CFG_TX_APPEND_CRC_EN                     BIT(0)
+#define CPU_MAC_GMAC_CFG_W3_CFG_TX_SLEEP_TIMER                       BIT(0)
+#define CPU_MAC_GMAC_CFG_W3_CFG_TX_WAKEUP_TIMER                      BIT(16)
+
+#define CPU_MAC_GMAC_CFG_W0_CFG_RX_CUT_THROUGH_EN_MASK               0x00000010
+#define CPU_MAC_GMAC_CFG_W0_CFG_RX_UNDERSIZE_DROP_EN_MASK            0x00000008
+#define CPU_MAC_GMAC_CFG_W0_CFG_RX_ERROR_DROP_EN_MASK                0x00000020
+#define CPU_MAC_GMAC_CFG_W0_CFG_RX_TS_EN_MASK                        0x00000001
+#define CPU_MAC_GMAC_CFG_W0_CFG_RX_OVERSIZE_DROP_EN_MASK             0x00000004
+#define CPU_MAC_GMAC_CFG_W0_CFG_RX_PAUSE_DROP_EN_MASK                0x00000040
+#define CPU_MAC_GMAC_CFG_W0_CFG_RX_OVERRUN_DROP_EN_MASK              0x00000002
+#define CPU_MAC_GMAC_CFG_W1_CFG_RX_MAX_PKT_LEN_CHK_EN_MASK           0x00000001
+#define CPU_MAC_GMAC_CFG_W1_CFG_RX_MIN_PKT_LEN_MASK                  0x00fe0000
+#define CPU_MAC_GMAC_CFG_W1_CFG_RX_MIN_PKT_LEN_CHK_EN_MASK           0x00010000
+#define CPU_MAC_GMAC_CFG_W1_CFG_RX_MAX_PKT_LEN_MASK                  0x0000fffe
+#define CPU_MAC_GMAC_CFG_W2_CFG_TX_START_THRD_MASK                   0x07ff0000
+#define CPU_MAC_GMAC_CFG_W2_CFG_TX_ERR_MASK_OFF_MASK                 0x00000002
+#define CPU_MAC_GMAC_CFG_W2_CFG_TX_PTP_ERR_EN_MASK                   0x00000040
+#define CPU_MAC_GMAC_CFG_W2_CFG_TX_KEEP_TS_EN_MASK                   0x00001000
+#define CPU_MAC_GMAC_CFG_W2_CFG_TX_PAUSE_STALL_EN_MASK               0x00000010
+#define CPU_MAC_GMAC_CFG_W2_CFG_TX_CUT_THROUGH_EN_MASK               0x00000400
+#define CPU_MAC_GMAC_CFG_W2_CFG_TX_STRIP_CRC_EN_MASK                 0x00000100
+#define CPU_MAC_GMAC_CFG_W2_CFG_TX_PKT_EN_MASK                       0x00000020
+#define CPU_MAC_GMAC_CFG_W2_CFG_TX_PAD_EN_MASK                       0x00000008
+#define CPU_MAC_GMAC_CFG_W2_CFG_TX_WAIT_CAPTURE_TS_MASK              0x00000200
+#define CPU_MAC_GMAC_CFG_W2_CFG_TX_HDR_INFO_EN_MASK                  0x00000800
+#define CPU_MAC_GMAC_CFG_W2_CFG_TX_LPI_EN_MASK                       0x00000004
+#define CPU_MAC_GMAC_CFG_W2_CFG_TX_APPEND_CRC_EN_MASK                0x00000001
+#define CPU_MAC_GMAC_CFG_W3_CFG_TX_SLEEP_TIMER_MASK                  0x0000ffff
+#define CPU_MAC_GMAC_CFG_W3_CFG_TX_WAKEUP_TIMER_MASK                 0xffff0000
+
+/* ################################################################################
+ * # CpuMacRamChkRec Definition
+ */
+#define CPU_MAC_RAM_CHK_REC_W0_CPU_MAC_STATS_RAM_PARITY_FAIL         BIT(31)
+#define CPU_MAC_RAM_CHK_REC_W0_CPU_MAC_STATS_RAM_PARITY_FAIL_ADDR    BIT(0)
+
+#define CPU_MAC_RAM_CHK_REC_W0_CPU_MAC_STATS_RAM_PARITY_FAIL_MASK    0x80000000
+#define CPU_MAC_RAM_CHK_REC_W0_CPU_MAC_STATS_RAM_PARITY_FAIL_ADDR_MASK 0x0000003f
+
+/* ################################################################################
+ * # CpuMacReset Definition
+ */
+#define CPU_MAC_RESET_W0_SOFT_RST_TX                                 BIT(1)
+#define CPU_MAC_RESET_W0_SOFT_RST_RX                                 BIT(0)
+
+#define CPU_MAC_RESET_W0_SOFT_RST_TX_MASK                            0x00000002
+#define CPU_MAC_RESET_W0_SOFT_RST_RX_MASK                            0x00000001
+
+/* ################################################################################
+ * # CpuMacSgmiiAutoNegCfg Definition
+ */
+#define CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_AN_RESTART                 BIT(1)
+#define CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_LOCAL_SPEED_MODE           BIT(7)
+#define CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_LINK_TIMER_CNT             BIT(16)
+#define CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_AN_MODE                    BIT(2)
+#define CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_AN_REMOTE_LINKUP_EN        BIT(25)
+#define CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_IGNORE_LINK_FAILURE        BIT(5)
+#define CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_AN_PARALLEL_DETECT_EN      BIT(24)
+#define CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_TX_XMIT_LOAD_USE_ASYNC_FIFO BIT(14)
+#define CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_LOCAL_EEE_ABILITY          BIT(9)
+#define CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_AN_ENABLE                  BIT(0)
+#define CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_LOCAL_OFFLINE              BIT(6)
+#define CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_IGNORE_ANEG_ERR            BIT(4)
+#define CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_TX_CONFIG_REG_BIT14        BIT(13)
+#define CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_LOCAL_EEE_CLK_STOP         BIT(10)
+#define CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_LOCAL_PAUSE_ABILITY        BIT(11)
+
+#define CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_AN_RESTART_MASK            0x00000002
+#define CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_LOCAL_SPEED_MODE_MASK      0x00000180
+#define CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_LINK_TIMER_CNT_MASK        0x00ff0000
+#define CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_AN_MODE_MASK               0x0000000c
+#define CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_AN_REMOTE_LINKUP_EN_MASK   0x02000000
+#define CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_IGNORE_LINK_FAILURE_MASK   0x00000020
+#define CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_AN_PARALLEL_DETECT_EN_MASK 0x01000000
+#define CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_TX_XMIT_LOAD_USE_ASYNC_FIFO_MASK 0x00004000
+#define CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_LOCAL_EEE_ABILITY_MASK     0x00000200
+#define CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_AN_ENABLE_MASK             0x00000001
+#define CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_LOCAL_OFFLINE_MASK         0x00000040
+#define CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_IGNORE_ANEG_ERR_MASK       0x00000010
+#define CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_TX_CONFIG_REG_BIT14_MASK   0x00002000
+#define CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_LOCAL_EEE_CLK_STOP_MASK    0x00000400
+#define CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_LOCAL_PAUSE_ABILITY_MASK   0x00001800
+
+/* ################################################################################
+ * # CpuMacReserved Definition
+ */
+#define CPU_MAC_RESERVED_W0_RESERVED                                 BIT(0)
+
+#define CPU_MAC_RESERVED_W0_RESERVED_MASK                            0xffffffff
+
+/* ################################################################################
+ * # CpuMacGmacMon Definition
+ */
+#define CPU_MAC_GMAC_MON_W0_MON_TX_LPI_STATE                         BIT(6)
+#define CPU_MAC_GMAC_MON_W0_MON_RX_METER_TOKEN                       BIT(8)
+#define CPU_MAC_GMAC_MON_W0_MON_RX_PKT_STATE                         BIT(0)
+#define CPU_MAC_GMAC_MON_W1_GMAC_RX_BUF_FULL_DROP_CNT                BIT(20)
+#define CPU_MAC_GMAC_MON_W1_GMAC_RX_FILTER_DROP_CNT                  BIT(24)
+#define CPU_MAC_GMAC_MON_W1_MON_TX_LPI_STATUS                        BIT(0)
+#define CPU_MAC_GMAC_MON_W1_MON_RX_BUF_RD_STATE                      BIT(2)
+#define CPU_MAC_GMAC_MON_W1_MON_TX_POP_STATE                         BIT(5)
+#define CPU_MAC_GMAC_MON_W1_GMAC_RX_RUNT_DROP_CNT                    BIT(16)
+#define CPU_MAC_GMAC_MON_W1_MON_TX_STATS_UNDERRUN                    BIT(1)
+#define CPU_MAC_GMAC_MON_W1_MON_RX_PKT_LEN                           BIT(8)
+#define CPU_MAC_GMAC_MON_W1_GMAC_RX_PAUSE_DROP_CNT                   BIT(28)
+
+#define CPU_MAC_GMAC_MON_W0_MON_TX_LPI_STATE_MASK                    0x000000c0
+#define CPU_MAC_GMAC_MON_W0_MON_RX_METER_TOKEN_MASK                  0xffffff00
+#define CPU_MAC_GMAC_MON_W0_MON_RX_PKT_STATE_MASK                    0x0000000f
+#define CPU_MAC_GMAC_MON_W1_GMAC_RX_BUF_FULL_DROP_CNT_MASK           0x00f00000
+#define CPU_MAC_GMAC_MON_W1_GMAC_RX_FILTER_DROP_CNT_MASK             0x0f000000
+#define CPU_MAC_GMAC_MON_W1_MON_TX_LPI_STATUS_MASK                   0x00000001
+#define CPU_MAC_GMAC_MON_W1_MON_RX_BUF_RD_STATE_MASK                 0x0000001c
+#define CPU_MAC_GMAC_MON_W1_MON_TX_POP_STATE_MASK                    0x000000e0
+#define CPU_MAC_GMAC_MON_W1_GMAC_RX_RUNT_DROP_CNT_MASK               0x000f0000
+#define CPU_MAC_GMAC_MON_W1_MON_TX_STATS_UNDERRUN_MASK               0x00000002
+#define CPU_MAC_GMAC_MON_W1_MON_RX_PKT_LEN_MASK                      0x0000ff00
+#define CPU_MAC_GMAC_MON_W1_GMAC_RX_PAUSE_DROP_CNT_MASK              0xf0000000
+
+/* ################################################################################
+ * # CpuMacCreditCtl Definition
+ */
+#define CPU_MAC_CREDIT_CTL_W0_CPU_MAC_CPU_RAM_CREDIT_THRD            BIT(0)
+
+#define CPU_MAC_CREDIT_CTL_W0_CPU_MAC_CPU_RAM_CREDIT_THRD_MASK       0x000000ff
+
+/* ################################################################################
+ * # CpuMacCreditStatus Definition
+ */
+#define CPU_MAC_CREDIT_STATUS_W0_CPU_MAC_CPU_RAM_CREDIT_USED         BIT(0)
+
+#define CPU_MAC_CREDIT_STATUS_W0_CPU_MAC_CPU_RAM_CREDIT_USED_MASK    0x000000ff
+
+/* ################################################################################
+ * # CpuMacPauseCfg Definition
+ */
+#define CPU_MAC_PAUSE_CFG_W0_CFG_RX_PAUSE_TIMER_ADJ_VALUE            BIT(1)
+#define CPU_MAC_PAUSE_CFG_W0_CFG_RX_NORM_PAUSE_EN                    BIT(0)
+#define CPU_MAC_PAUSE_CFG_W0_CFG_RX_PAUSE_TIMER_DEC_VALUE            BIT(11)
+#define CPU_MAC_PAUSE_CFG_W1_CFG_TX_PAUSE_TIMER_ADJ_VALUE            BIT(1)
+#define CPU_MAC_PAUSE_CFG_W1_CFG_TX_PAUSE_TIMER_DEC_VALUE            BIT(18)
+#define CPU_MAC_PAUSE_CFG_W1_CFG_TX_PAUSE_EN                         BIT(0)
+#define CPU_MAC_PAUSE_CFG_W2_CFG_TX_PAUSE_MAC_SA_31_0                BIT(0)
+#define CPU_MAC_PAUSE_CFG_W3_CFG_TX_PAUSE_MAC_SA_47_32               BIT(0)
+#define CPU_MAC_PAUSE_CFG_W3_CFG_TX_PAUSE_QUANTA                     BIT(16)
+
+#define CPU_MAC_PAUSE_CFG_W0_CFG_RX_PAUSE_TIMER_ADJ_VALUE_MASK       0x000007fe
+#define CPU_MAC_PAUSE_CFG_W0_CFG_RX_NORM_PAUSE_EN_MASK               0x00000001
+#define CPU_MAC_PAUSE_CFG_W0_CFG_RX_PAUSE_TIMER_DEC_VALUE_MASK       0x0007f800
+#define CPU_MAC_PAUSE_CFG_W1_CFG_TX_PAUSE_TIMER_ADJ_VALUE_MASK       0x0003fffe
+#define CPU_MAC_PAUSE_CFG_W1_CFG_TX_PAUSE_TIMER_DEC_VALUE_MASK       0x03fc0000
+#define CPU_MAC_PAUSE_CFG_W1_CFG_TX_PAUSE_EN_MASK                    0x00000001
+#define CPU_MAC_PAUSE_CFG_W2_CFG_TX_PAUSE_MAC_SA_31_0_MASK           0x00000001
+#define CPU_MAC_PAUSE_CFG_W3_CFG_TX_PAUSE_MAC_SA_47_32_MASK          0x00000001
+#define CPU_MAC_PAUSE_CFG_W3_CFG_TX_PAUSE_QUANTA_MASK                0xffff0000
+
+/* ################################################################################
+ * # CpuMacPauseMon Definition
+ */
+#define CPU_MAC_PAUSE_MON_W0_MON_TX_PAUSE_TIMER                      BIT(0)
+#define CPU_MAC_PAUSE_MON_W1_MON_RX_PAUSE_TIMER                      BIT(0)
+#define CPU_MAC_PAUSE_MON_W2_MON_TX_PAUSE_CUR_STATUS                 BIT(0)
+#define CPU_MAC_PAUSE_MON_W2_MON_TX_PAUSE_LOG_STATUS                 BIT(1)
+
+#define CPU_MAC_PAUSE_MON_W0_MON_TX_PAUSE_TIMER_MASK                 0x0001ffff
+#define CPU_MAC_PAUSE_MON_W1_MON_RX_PAUSE_TIMER_MASK                 0x0000ffff
+#define CPU_MAC_PAUSE_MON_W2_MON_TX_PAUSE_CUR_STATUS_MASK            0x00000001
+#define CPU_MAC_PAUSE_MON_W2_MON_TX_PAUSE_LOG_STATUS_MASK            0x00000002
+
+/* ################################################################################
+ * # CpuMacSgmiiCfg Definition
+ */
+#define CPU_MAC_SGMII_CFG_W0_CFG_TX_EVEN_IGNORE                      BIT(3)
+#define CPU_MAC_SGMII_CFG_W0_CFG_TX_IPG_LEN                          BIT(14)
+#define CPU_MAC_SGMII_CFG_W0_CFG_TX_PREAMBLE_LEN                     BIT(18)
+#define CPU_MAC_SGMII_CFG_W0_CFG_UNIDIRECTION_EN                     BIT(4)
+#define CPU_MAC_SGMII_CFG_W0_CFG_MII_RX_CHK_LINK_FOR_SOP             BIT(31)
+#define CPU_MAC_SGMII_CFG_W0_CFG_FORCE_RELOCK                        BIT(0)
+#define CPU_MAC_SGMII_CFG_W0_CFG_FORCE_SIGNAL_DETECT                 BIT(1)
+#define CPU_MAC_SGMII_CFG_W0_CFG_TX_REPLICATE_CNT                    BIT(22)
+#define CPU_MAC_SGMII_CFG_W0_CFG_MII_RX_LINK_FILTER_TIMER            BIT(6)
+#define CPU_MAC_SGMII_CFG_W0_CFG_SIG_DET_ACTIVE_VALUE                BIT(2)
+#define CPU_MAC_SGMII_CFG_W0_CFG_MII_RX_LINK_FILTER_EN               BIT(5)
+#define CPU_MAC_SGMII_CFG_W1_CFG_MII_RX_SAMPLE_CNT                   BIT(22)
+#define CPU_MAC_SGMII_CFG_W1_CFG_TX_THRESHOLD                        BIT(0)
+#define CPU_MAC_SGMII_CFG_W1_CFG_MII_TX_A_FULL_THRD                  BIT(5)
+
+#define CPU_MAC_SGMII_CFG_W0_CFG_TX_EVEN_IGNORE_MASK                 0x00000008
+#define CPU_MAC_SGMII_CFG_W0_CFG_TX_IPG_LEN_MASK                     0x0003c000
+#define CPU_MAC_SGMII_CFG_W0_CFG_TX_PREAMBLE_LEN_MASK                0x003c0000
+#define CPU_MAC_SGMII_CFG_W0_CFG_UNIDIRECTION_EN_MASK                0x00000010
+#define CPU_MAC_SGMII_CFG_W0_CFG_MII_RX_CHK_LINK_FOR_SOP_MASK        0x80000000
+#define CPU_MAC_SGMII_CFG_W0_CFG_FORCE_RELOCK_MASK                   0x00000001
+#define CPU_MAC_SGMII_CFG_W0_CFG_FORCE_SIGNAL_DETECT_MASK            0x00000002
+#define CPU_MAC_SGMII_CFG_W0_CFG_TX_REPLICATE_CNT_MASK               0x1fc00000
+#define CPU_MAC_SGMII_CFG_W0_CFG_MII_RX_LINK_FILTER_TIMER_MASK       0x00003fc0
+#define CPU_MAC_SGMII_CFG_W0_CFG_SIG_DET_ACTIVE_VALUE_MASK           0x00000004
+#define CPU_MAC_SGMII_CFG_W0_CFG_MII_RX_LINK_FILTER_EN_MASK          0x00000020
+#define CPU_MAC_SGMII_CFG_W1_CFG_MII_RX_SAMPLE_CNT_MASK              0x1fc00000
+#define CPU_MAC_SGMII_CFG_W1_CFG_TX_THRESHOLD_MASK                   0x0000001f
+#define CPU_MAC_SGMII_CFG_W1_CFG_MII_TX_A_FULL_THRD_MASK             0x000003e0
+
+/* ################################################################################
+ * # CpuMacSgmiiMon Definition
+ */
+#define CPU_MAC_SGMII_MON_W0_MON_SGMII_TX_CODE_STATE                 BIT(23)
+#define CPU_MAC_SGMII_MON_W0_MON_SGMII_TX_SOP_FLAG                   BIT(18)
+#define CPU_MAC_SGMII_MON_W0_MON_SGMII_TX_EOP_FLAG                   BIT(19)
+#define CPU_MAC_SGMII_MON_W0_MON_SGMII_RX_EOP_FLAG                   BIT(9)
+#define CPU_MAC_SGMII_MON_W0_MON_SGMII_RX_SFD_FLAG                   BIT(11)
+#define CPU_MAC_SGMII_MON_W0_MON_SGMII_TX_LPI_STATE                  BIT(20)
+#define CPU_MAC_SGMII_MON_W0_MON_SGMII_RX_LPI_STATE                  BIT(12)
+#define CPU_MAC_SGMII_MON_W0_MON_SGMII_RX_PKT_STATE                  BIT(15)
+#define CPU_MAC_SGMII_MON_W0_MON_ANEG_STATE                          BIT(0)
+#define CPU_MAC_SGMII_MON_W0_MON_CODE_ERR_CNT                        BIT(4)
+#define CPU_MAC_SGMII_MON_W0_MON_LINK_STATUS                         BIT(8)
+#define CPU_MAC_SGMII_MON_W0_MON_SGMII_RX_SOP_FLAG                   BIT(10)
+#define CPU_MAC_SGMII_MON_W1_MON_AN_RX_REMOTE_CFG                    BIT(0)
+
+#define CPU_MAC_SGMII_MON_W0_MON_SGMII_TX_CODE_STATE_MASK            0x03800000
+#define CPU_MAC_SGMII_MON_W0_MON_SGMII_TX_SOP_FLAG_MASK              0x00040000
+#define CPU_MAC_SGMII_MON_W0_MON_SGMII_TX_EOP_FLAG_MASK              0x00080000
+#define CPU_MAC_SGMII_MON_W0_MON_SGMII_RX_EOP_FLAG_MASK              0x00000200
+#define CPU_MAC_SGMII_MON_W0_MON_SGMII_RX_SFD_FLAG_MASK              0x00000800
+#define CPU_MAC_SGMII_MON_W0_MON_SGMII_TX_LPI_STATE_MASK             0x00700000
+#define CPU_MAC_SGMII_MON_W0_MON_SGMII_RX_LPI_STATE_MASK             0x00007000
+#define CPU_MAC_SGMII_MON_W0_MON_SGMII_RX_PKT_STATE_MASK             0x00038000
+#define CPU_MAC_SGMII_MON_W0_MON_ANEG_STATE_MASK                     0x00000007
+#define CPU_MAC_SGMII_MON_W0_MON_CODE_ERR_CNT_MASK                   0x000000f0
+#define CPU_MAC_SGMII_MON_W0_MON_LINK_STATUS_MASK                    0x00000100
+#define CPU_MAC_SGMII_MON_W0_MON_SGMII_RX_SOP_FLAG_MASK              0x00000400
+#define CPU_MAC_SGMII_MON_W1_MON_AN_RX_REMOTE_CFG_MASK               0x0000ffff
+
+/* ################################################################################
+ * # CpuMacStatsCfg Definition
+ */
+#define CPU_MAC_STATS_CFG_W0_CFG_GMAC_STATS64_B_PKT_HI_PRI           BIT(4)
+#define CPU_MAC_STATS_CFG_W0_CFG_GMAC_STATS_INCR_SATURATE            BIT(1)
+#define CPU_MAC_STATS_CFG_W0_CFG_GMAC_STATS_INCR_HOLD                BIT(2)
+#define CPU_MAC_STATS_CFG_W0_CFG_GMAC_STATS_CLEAR_ON_READ            BIT(0)
+#define CPU_MAC_STATS_CFG_W0_CFG_GMAC_STATS_OVER_WRITE_EN            BIT(3)
+#define CPU_MAC_STATS_CFG_W1_CFG_GMAC_STATS_MTU1                     BIT(0)
+#define CPU_MAC_STATS_CFG_W1_CFG_GMAC_STATS_MTU2                     BIT(16)
+
+#define CPU_MAC_STATS_CFG_W0_CFG_GMAC_STATS64_B_PKT_HI_PRI_MASK      0x00000010
+#define CPU_MAC_STATS_CFG_W0_CFG_GMAC_STATS_INCR_SATURATE_MASK       0x00000002
+#define CPU_MAC_STATS_CFG_W0_CFG_GMAC_STATS_INCR_HOLD_MASK           0x00000004
+#define CPU_MAC_STATS_CFG_W0_CFG_GMAC_STATS_CLEAR_ON_READ_MASK       0x00000001
+#define CPU_MAC_STATS_CFG_W0_CFG_GMAC_STATS_OVER_WRITE_EN_MASK       0x00000008
+#define CPU_MAC_STATS_CFG_W1_CFG_GMAC_STATS_MTU1_MASK                0x00003fff
+#define CPU_MAC_STATS_CFG_W1_CFG_GMAC_STATS_MTU2_MASK                0x3fff0000
+
+/* ################################################################################
+ * # CpuMacInterruptFunc Definition
+ */
+#define CPU_MAC_INTERRUPT_FUNC_W0_VALUE_SET0_CPU_MAC_INTERRUPT_FUNC  BIT(0)
+#define CPU_MAC_INTERRUPT_FUNC_W1_VALUE_RESET0_CPU_MAC_INTERRUPT_FUNC BIT(0)
+#define CPU_MAC_INTERRUPT_FUNC_W2_MASK_SET0_CPU_MAC_INTERRUPT_FUNC   BIT(0)
+#define CPU_MAC_INTERRUPT_FUNC_W3_MASK_RESET0_CPU_MAC_INTERRUPT_FUNC BIT(0)
+
+#define CPU_MAC_INTERRUPT_FUNC_W0_VALUE_SET0_CPU_MAC_INTERRUPT_FUNC_MASK 0x000000ff
+#define CPU_MAC_INTERRUPT_FUNC_W1_VALUE_RESET0_CPU_MAC_INTERRUPT_FUNC_MASK 0x000000ff
+#define CPU_MAC_INTERRUPT_FUNC_W2_MASK_SET0_CPU_MAC_INTERRUPT_FUNC_MASK 0x000000ff
+#define CPU_MAC_INTERRUPT_FUNC_W3_MASK_RESET0_CPU_MAC_INTERRUPT_FUNC_MASK 0x000000ff
+
+/* ################################################################################
+ * # CpuMacInterruptNormal Definition
+ */
+#define CPU_MAC_INTERRUPT_NORMAL_W0_VALUE_SET0_CPU_MAC_INTERRUPT_NORMAL BIT(0)
+#define CPU_MAC_INTERRUPT_NORMAL_W1_VALUE_RESET0_CPU_MAC_INTERRUPT_NORMAL BIT(0)
+#define CPU_MAC_INTERRUPT_NORMAL_W2_MASK_SET0_CPU_MAC_INTERRUPT_NORMAL BIT(0)
+#define CPU_MAC_INTERRUPT_NORMAL_W3_MASK_RESET0_CPU_MAC_INTERRUPT_NORMAL BIT(0)
+
+#define CPU_MAC_INTERRUPT_NORMAL_W0_VALUE_SET0_CPU_MAC_INTERRUPT_NORMAL_MASK 0xffffffff
+#define CPU_MAC_INTERRUPT_NORMAL_W1_VALUE_RESET0_CPU_MAC_INTERRUPT_NORMAL_MASK 0xffffffff
+#define CPU_MAC_INTERRUPT_NORMAL_W2_MASK_SET0_CPU_MAC_INTERRUPT_NORMAL_MASK 0xffffffff
+#define CPU_MAC_INTERRUPT_NORMAL_W3_MASK_RESET0_CPU_MAC_INTERRUPT_NORMAL_MASK 0xffffffff
+
+/* ################################################################################
+ * # CpuMacFifoStatus Definition
+ */
+#define CPU_MAC_FIFO_STATUS_W0_RX_PKT_MSG_FIFO_FIFO_DEPTH            BIT(0)
+#define CPU_MAC_FIFO_STATUS_W0_RX_PKT_DATA_FIFO_FIFO_DEPTH           BIT(20)
+#define CPU_MAC_FIFO_STATUS_W0_TX_DESC_ACK_FIFO_FIFO_DEPTH           BIT(10)
+#define CPU_MAC_FIFO_STATUS_W0_EXT_RAM_RD_TRACK_FIFO_FIFO_DEPTH      BIT(16)
+#define CPU_MAC_FIFO_STATUS_W1_RX_DESC0_ACK_FIFO_FIFO_DEPTH          BIT(12)
+#define CPU_MAC_FIFO_STATUS_W1_RX_DESC1_CFG_FIFO_FIFO_DEPTH          BIT(18)
+#define CPU_MAC_FIFO_STATUS_W1_RX_DESC0_CFG_FIFO_FIFO_DEPTH          BIT(6)
+#define CPU_MAC_FIFO_STATUS_W1_RX_DESC1_ACK_FIFO_FIFO_DEPTH          BIT(24)
+#define CPU_MAC_FIFO_STATUS_W1_TX_DESC_CFG_FIFO_FIFO_DEPTH           BIT(0)
+#define CPU_MAC_FIFO_STATUS_W2_TX_PKT_FIFO_FIFO_DEPTH                BIT(16)
+#define CPU_MAC_FIFO_STATUS_W2_RX_PKT_FIFO_FIFO_DEPTH                BIT(0)
+
+#define CPU_MAC_FIFO_STATUS_W0_RX_PKT_MSG_FIFO_FIFO_DEPTH_MASK       0x000003ff
+#define CPU_MAC_FIFO_STATUS_W0_RX_PKT_DATA_FIFO_FIFO_DEPTH_MASK      0xfff00000
+#define CPU_MAC_FIFO_STATUS_W0_TX_DESC_ACK_FIFO_FIFO_DEPTH_MASK      0x0000fc00
+#define CPU_MAC_FIFO_STATUS_W0_EXT_RAM_RD_TRACK_FIFO_FIFO_DEPTH_MASK 0x000f0000
+#define CPU_MAC_FIFO_STATUS_W1_RX_DESC0_ACK_FIFO_FIFO_DEPTH_MASK     0x0003f000
+#define CPU_MAC_FIFO_STATUS_W1_RX_DESC1_CFG_FIFO_FIFO_DEPTH_MASK     0x00fc0000
+#define CPU_MAC_FIFO_STATUS_W1_RX_DESC0_CFG_FIFO_FIFO_DEPTH_MASK     0x00000fc0
+#define CPU_MAC_FIFO_STATUS_W1_RX_DESC1_ACK_FIFO_FIFO_DEPTH_MASK     0x3f000000
+#define CPU_MAC_FIFO_STATUS_W1_TX_DESC_CFG_FIFO_FIFO_DEPTH_MASK      0x0000003f
+#define CPU_MAC_FIFO_STATUS_W2_TX_PKT_FIFO_FIFO_DEPTH_MASK           0x03ff0000
+#define CPU_MAC_FIFO_STATUS_W2_RX_PKT_FIFO_FIFO_DEPTH_MASK           0x000003ff
+
+
+struct CpuMac_mems {
+   u32 TxPktFifo0[3];                   /* 0x00004000 */
+   u32 TxPktFifo0_rsv3;
+   u32 TxPktFifo1[3];                   /* 0x00004010 */
+   u32 TxPktFifo1_rsv3;
+   u32 TxPktFifo2[3];                   /* 0x00004020 */
+   u32 TxPktFifo2_rsv3;
+   u32 TxPktFifo3[3];                   /* 0x00004030 */
+   u32 TxPktFifo3_rsv3;
+   u32 TxPktFifo4[3];                   /* 0x00004040 */
+   u32 TxPktFifo4_rsv3;
+   u32 TxPktFifo5[3];                   /* 0x00004050 */
+   u32 TxPktFifo5_rsv3;
+   u32 TxPktFifo6[3];                   /* 0x00004060 */
+   u32 TxPktFifo6_rsv3;
+   u32 TxPktFifo7[3];                   /* 0x00004070 */
+   u32 TxPktFifo7_rsv3;
+   u32 TxPktFifo8[3];                   /* 0x00004080 */
+   u32 TxPktFifo8_rsv3;
+   u32 TxPktFifo9[3];                   /* 0x00004090 */
+   u32 TxPktFifo9_rsv3;
+   u32 TxPktFifo10[3];                  /* 0x000040a0 */
+   u32 TxPktFifo10_rsv3;
+   u32 TxPktFifo11[3];                  /* 0x000040b0 */
+   u32 TxPktFifo11_rsv3;
+   u32 TxPktFifo12[3];                  /* 0x000040c0 */
+   u32 TxPktFifo12_rsv3;
+   u32 TxPktFifo13[3];                  /* 0x000040d0 */
+   u32 TxPktFifo13_rsv3;
+   u32 TxPktFifo14[3];                  /* 0x000040e0 */
+   u32 TxPktFifo14_rsv3;
+   u32 TxPktFifo15[3];                  /* 0x000040f0 */
+   u32 TxPktFifo15_rsv3;
+   u32 TxPktFifo16[3];                  /* 0x00004100 */
+   u32 TxPktFifo16_rsv3;
+   u32 TxPktFifo17[3];                  /* 0x00004110 */
+   u32 TxPktFifo17_rsv3;
+   u32 TxPktFifo18[3];                  /* 0x00004120 */
+   u32 TxPktFifo18_rsv3;
+   u32 TxPktFifo19[3];                  /* 0x00004130 */
+   u32 TxPktFifo19_rsv3;
+   u32 TxPktFifo20[3];                  /* 0x00004140 */
+   u32 TxPktFifo20_rsv3;
+   u32 TxPktFifo21[3];                  /* 0x00004150 */
+   u32 TxPktFifo21_rsv3;
+   u32 TxPktFifo22[3];                  /* 0x00004160 */
+   u32 TxPktFifo22_rsv3;
+   u32 TxPktFifo23[3];                  /* 0x00004170 */
+   u32 TxPktFifo23_rsv3;
+   u32 TxPktFifo24[3];                  /* 0x00004180 */
+   u32 TxPktFifo24_rsv3;
+   u32 TxPktFifo25[3];                  /* 0x00004190 */
+   u32 TxPktFifo25_rsv3;
+   u32 TxPktFifo26[3];                  /* 0x000041a0 */
+   u32 TxPktFifo26_rsv3;
+   u32 TxPktFifo27[3];                  /* 0x000041b0 */
+   u32 TxPktFifo27_rsv3;
+   u32 TxPktFifo28[3];                  /* 0x000041c0 */
+   u32 TxPktFifo28_rsv3;
+   u32 TxPktFifo29[3];                  /* 0x000041d0 */
+   u32 TxPktFifo29_rsv3;
+   u32 TxPktFifo30[3];                  /* 0x000041e0 */
+   u32 TxPktFifo30_rsv3;
+   u32 TxPktFifo31[3];                  /* 0x000041f0 */
+   u32 TxPktFifo31_rsv3;
+   u32 TxPktFifo32[3];                  /* 0x00004200 */
+   u32 TxPktFifo32_rsv3;
+   u32 TxPktFifo33[3];                  /* 0x00004210 */
+   u32 TxPktFifo33_rsv3;
+   u32 TxPktFifo34[3];                  /* 0x00004220 */
+   u32 TxPktFifo34_rsv3;
+   u32 TxPktFifo35[3];                  /* 0x00004230 */
+   u32 TxPktFifo35_rsv3;
+   u32 TxPktFifo36[3];                  /* 0x00004240 */
+   u32 TxPktFifo36_rsv3;
+   u32 TxPktFifo37[3];                  /* 0x00004250 */
+   u32 TxPktFifo37_rsv3;
+   u32 TxPktFifo38[3];                  /* 0x00004260 */
+   u32 TxPktFifo38_rsv3;
+   u32 TxPktFifo39[3];                  /* 0x00004270 */
+   u32 TxPktFifo39_rsv3;
+   u32 TxPktFifo40[3];                  /* 0x00004280 */
+   u32 TxPktFifo40_rsv3;
+   u32 TxPktFifo41[3];                  /* 0x00004290 */
+   u32 TxPktFifo41_rsv3;
+   u32 TxPktFifo42[3];                  /* 0x000042a0 */
+   u32 TxPktFifo42_rsv3;
+   u32 TxPktFifo43[3];                  /* 0x000042b0 */
+   u32 TxPktFifo43_rsv3;
+   u32 TxPktFifo44[3];                  /* 0x000042c0 */
+   u32 TxPktFifo44_rsv3;
+   u32 TxPktFifo45[3];                  /* 0x000042d0 */
+   u32 TxPktFifo45_rsv3;
+   u32 TxPktFifo46[3];                  /* 0x000042e0 */
+   u32 TxPktFifo46_rsv3;
+   u32 TxPktFifo47[3];                  /* 0x000042f0 */
+   u32 TxPktFifo47_rsv3;
+   u32 TxPktFifo48[3];                  /* 0x00004300 */
+   u32 TxPktFifo48_rsv3;
+   u32 TxPktFifo49[3];                  /* 0x00004310 */
+   u32 TxPktFifo49_rsv3;
+   u32 TxPktFifo50[3];                  /* 0x00004320 */
+   u32 TxPktFifo50_rsv3;
+   u32 TxPktFifo51[3];                  /* 0x00004330 */
+   u32 TxPktFifo51_rsv3;
+   u32 TxPktFifo52[3];                  /* 0x00004340 */
+   u32 TxPktFifo52_rsv3;
+   u32 TxPktFifo53[3];                  /* 0x00004350 */
+   u32 TxPktFifo53_rsv3;
+   u32 TxPktFifo54[3];                  /* 0x00004360 */
+   u32 TxPktFifo54_rsv3;
+   u32 TxPktFifo55[3];                  /* 0x00004370 */
+   u32 TxPktFifo55_rsv3;
+   u32 TxPktFifo56[3];                  /* 0x00004380 */
+   u32 TxPktFifo56_rsv3;
+   u32 TxPktFifo57[3];                  /* 0x00004390 */
+   u32 TxPktFifo57_rsv3;
+   u32 TxPktFifo58[3];                  /* 0x000043a0 */
+   u32 TxPktFifo58_rsv3;
+   u32 TxPktFifo59[3];                  /* 0x000043b0 */
+   u32 TxPktFifo59_rsv3;
+   u32 TxPktFifo60[3];                  /* 0x000043c0 */
+   u32 TxPktFifo60_rsv3;
+   u32 TxPktFifo61[3];                  /* 0x000043d0 */
+   u32 TxPktFifo61_rsv3;
+   u32 TxPktFifo62[3];                  /* 0x000043e0 */
+   u32 TxPktFifo62_rsv3;
+   u32 TxPktFifo63[3];                  /* 0x000043f0 */
+   u32 TxPktFifo63_rsv3;
+   u32 TxPktFifo64[3];                  /* 0x00004400 */
+   u32 TxPktFifo64_rsv3;
+   u32 TxPktFifo65[3];                  /* 0x00004410 */
+   u32 TxPktFifo65_rsv3;
+   u32 TxPktFifo66[3];                  /* 0x00004420 */
+   u32 TxPktFifo66_rsv3;
+   u32 TxPktFifo67[3];                  /* 0x00004430 */
+   u32 TxPktFifo67_rsv3;
+   u32 TxPktFifo68[3];                  /* 0x00004440 */
+   u32 TxPktFifo68_rsv3;
+   u32 TxPktFifo69[3];                  /* 0x00004450 */
+   u32 TxPktFifo69_rsv3;
+   u32 TxPktFifo70[3];                  /* 0x00004460 */
+   u32 TxPktFifo70_rsv3;
+   u32 TxPktFifo71[3];                  /* 0x00004470 */
+   u32 TxPktFifo71_rsv3;
+   u32 TxPktFifo72[3];                  /* 0x00004480 */
+   u32 TxPktFifo72_rsv3;
+   u32 TxPktFifo73[3];                  /* 0x00004490 */
+   u32 TxPktFifo73_rsv3;
+   u32 TxPktFifo74[3];                  /* 0x000044a0 */
+   u32 TxPktFifo74_rsv3;
+   u32 TxPktFifo75[3];                  /* 0x000044b0 */
+   u32 TxPktFifo75_rsv3;
+   u32 TxPktFifo76[3];                  /* 0x000044c0 */
+   u32 TxPktFifo76_rsv3;
+   u32 TxPktFifo77[3];                  /* 0x000044d0 */
+   u32 TxPktFifo77_rsv3;
+   u32 TxPktFifo78[3];                  /* 0x000044e0 */
+   u32 TxPktFifo78_rsv3;
+   u32 TxPktFifo79[3];                  /* 0x000044f0 */
+   u32 TxPktFifo79_rsv3;
+   u32 TxPktFifo80[3];                  /* 0x00004500 */
+   u32 TxPktFifo80_rsv3;
+   u32 TxPktFifo81[3];                  /* 0x00004510 */
+   u32 TxPktFifo81_rsv3;
+   u32 TxPktFifo82[3];                  /* 0x00004520 */
+   u32 TxPktFifo82_rsv3;
+   u32 TxPktFifo83[3];                  /* 0x00004530 */
+   u32 TxPktFifo83_rsv3;
+   u32 TxPktFifo84[3];                  /* 0x00004540 */
+   u32 TxPktFifo84_rsv3;
+   u32 TxPktFifo85[3];                  /* 0x00004550 */
+   u32 TxPktFifo85_rsv3;
+   u32 TxPktFifo86[3];                  /* 0x00004560 */
+   u32 TxPktFifo86_rsv3;
+   u32 TxPktFifo87[3];                  /* 0x00004570 */
+   u32 TxPktFifo87_rsv3;
+   u32 TxPktFifo88[3];                  /* 0x00004580 */
+   u32 TxPktFifo88_rsv3;
+   u32 TxPktFifo89[3];                  /* 0x00004590 */
+   u32 TxPktFifo89_rsv3;
+   u32 TxPktFifo90[3];                  /* 0x000045a0 */
+   u32 TxPktFifo90_rsv3;
+   u32 TxPktFifo91[3];                  /* 0x000045b0 */
+   u32 TxPktFifo91_rsv3;
+   u32 TxPktFifo92[3];                  /* 0x000045c0 */
+   u32 TxPktFifo92_rsv3;
+   u32 TxPktFifo93[3];                  /* 0x000045d0 */
+   u32 TxPktFifo93_rsv3;
+   u32 TxPktFifo94[3];                  /* 0x000045e0 */
+   u32 TxPktFifo94_rsv3;
+   u32 TxPktFifo95[3];                  /* 0x000045f0 */
+   u32 TxPktFifo95_rsv3;
+   u32 TxPktFifo96[3];                  /* 0x00004600 */
+   u32 TxPktFifo96_rsv3;
+   u32 TxPktFifo97[3];                  /* 0x00004610 */
+   u32 TxPktFifo97_rsv3;
+   u32 TxPktFifo98[3];                  /* 0x00004620 */
+   u32 TxPktFifo98_rsv3;
+   u32 TxPktFifo99[3];                  /* 0x00004630 */
+   u32 TxPktFifo99_rsv3;
+   u32 TxPktFifo100[3];                 /* 0x00004640 */
+   u32 TxPktFifo100_rsv3;
+   u32 TxPktFifo101[3];                 /* 0x00004650 */
+   u32 TxPktFifo101_rsv3;
+   u32 TxPktFifo102[3];                 /* 0x00004660 */
+   u32 TxPktFifo102_rsv3;
+   u32 TxPktFifo103[3];                 /* 0x00004670 */
+   u32 TxPktFifo103_rsv3;
+   u32 TxPktFifo104[3];                 /* 0x00004680 */
+   u32 TxPktFifo104_rsv3;
+   u32 TxPktFifo105[3];                 /* 0x00004690 */
+   u32 TxPktFifo105_rsv3;
+   u32 TxPktFifo106[3];                 /* 0x000046a0 */
+   u32 TxPktFifo106_rsv3;
+   u32 TxPktFifo107[3];                 /* 0x000046b0 */
+   u32 TxPktFifo107_rsv3;
+   u32 TxPktFifo108[3];                 /* 0x000046c0 */
+   u32 TxPktFifo108_rsv3;
+   u32 TxPktFifo109[3];                 /* 0x000046d0 */
+   u32 TxPktFifo109_rsv3;
+   u32 TxPktFifo110[3];                 /* 0x000046e0 */
+   u32 TxPktFifo110_rsv3;
+   u32 TxPktFifo111[3];                 /* 0x000046f0 */
+   u32 TxPktFifo111_rsv3;
+   u32 TxPktFifo112[3];                 /* 0x00004700 */
+   u32 TxPktFifo112_rsv3;
+   u32 TxPktFifo113[3];                 /* 0x00004710 */
+   u32 TxPktFifo113_rsv3;
+   u32 TxPktFifo114[3];                 /* 0x00004720 */
+   u32 TxPktFifo114_rsv3;
+   u32 TxPktFifo115[3];                 /* 0x00004730 */
+   u32 TxPktFifo115_rsv3;
+   u32 TxPktFifo116[3];                 /* 0x00004740 */
+   u32 TxPktFifo116_rsv3;
+   u32 TxPktFifo117[3];                 /* 0x00004750 */
+   u32 TxPktFifo117_rsv3;
+   u32 TxPktFifo118[3];                 /* 0x00004760 */
+   u32 TxPktFifo118_rsv3;
+   u32 TxPktFifo119[3];                 /* 0x00004770 */
+   u32 TxPktFifo119_rsv3;
+   u32 TxPktFifo120[3];                 /* 0x00004780 */
+   u32 TxPktFifo120_rsv3;
+   u32 TxPktFifo121[3];                 /* 0x00004790 */
+   u32 TxPktFifo121_rsv3;
+   u32 TxPktFifo122[3];                 /* 0x000047a0 */
+   u32 TxPktFifo122_rsv3;
+   u32 TxPktFifo123[3];                 /* 0x000047b0 */
+   u32 TxPktFifo123_rsv3;
+   u32 TxPktFifo124[3];                 /* 0x000047c0 */
+   u32 TxPktFifo124_rsv3;
+   u32 TxPktFifo125[3];                 /* 0x000047d0 */
+   u32 TxPktFifo125_rsv3;
+   u32 TxPktFifo126[3];                 /* 0x000047e0 */
+   u32 TxPktFifo126_rsv3;
+   u32 TxPktFifo127[3];                 /* 0x000047f0 */
+   u32 TxPktFifo127_rsv3;
+   u32 TxPktFifo128[3];                 /* 0x00004800 */
+   u32 TxPktFifo128_rsv3;
+   u32 TxPktFifo129[3];                 /* 0x00004810 */
+   u32 TxPktFifo129_rsv3;
+   u32 TxPktFifo130[3];                 /* 0x00004820 */
+   u32 TxPktFifo130_rsv3;
+   u32 TxPktFifo131[3];                 /* 0x00004830 */
+   u32 TxPktFifo131_rsv3;
+   u32 TxPktFifo132[3];                 /* 0x00004840 */
+   u32 TxPktFifo132_rsv3;
+   u32 TxPktFifo133[3];                 /* 0x00004850 */
+   u32 TxPktFifo133_rsv3;
+   u32 TxPktFifo134[3];                 /* 0x00004860 */
+   u32 TxPktFifo134_rsv3;
+   u32 TxPktFifo135[3];                 /* 0x00004870 */
+   u32 TxPktFifo135_rsv3;
+   u32 TxPktFifo136[3];                 /* 0x00004880 */
+   u32 TxPktFifo136_rsv3;
+   u32 TxPktFifo137[3];                 /* 0x00004890 */
+   u32 TxPktFifo137_rsv3;
+   u32 TxPktFifo138[3];                 /* 0x000048a0 */
+   u32 TxPktFifo138_rsv3;
+   u32 TxPktFifo139[3];                 /* 0x000048b0 */
+   u32 TxPktFifo139_rsv3;
+   u32 TxPktFifo140[3];                 /* 0x000048c0 */
+   u32 TxPktFifo140_rsv3;
+   u32 TxPktFifo141[3];                 /* 0x000048d0 */
+   u32 TxPktFifo141_rsv3;
+   u32 TxPktFifo142[3];                 /* 0x000048e0 */
+   u32 TxPktFifo142_rsv3;
+   u32 TxPktFifo143[3];                 /* 0x000048f0 */
+   u32 TxPktFifo143_rsv3;
+   u32 TxPktFifo144[3];                 /* 0x00004900 */
+   u32 TxPktFifo144_rsv3;
+   u32 TxPktFifo145[3];                 /* 0x00004910 */
+   u32 TxPktFifo145_rsv3;
+   u32 TxPktFifo146[3];                 /* 0x00004920 */
+   u32 TxPktFifo146_rsv3;
+   u32 TxPktFifo147[3];                 /* 0x00004930 */
+   u32 TxPktFifo147_rsv3;
+   u32 TxPktFifo148[3];                 /* 0x00004940 */
+   u32 TxPktFifo148_rsv3;
+   u32 TxPktFifo149[3];                 /* 0x00004950 */
+   u32 TxPktFifo149_rsv3;
+   u32 TxPktFifo150[3];                 /* 0x00004960 */
+   u32 TxPktFifo150_rsv3;
+   u32 TxPktFifo151[3];                 /* 0x00004970 */
+   u32 TxPktFifo151_rsv3;
+   u32 TxPktFifo152[3];                 /* 0x00004980 */
+   u32 TxPktFifo152_rsv3;
+   u32 TxPktFifo153[3];                 /* 0x00004990 */
+   u32 TxPktFifo153_rsv3;
+   u32 TxPktFifo154[3];                 /* 0x000049a0 */
+   u32 TxPktFifo154_rsv3;
+   u32 TxPktFifo155[3];                 /* 0x000049b0 */
+   u32 TxPktFifo155_rsv3;
+   u32 TxPktFifo156[3];                 /* 0x000049c0 */
+   u32 TxPktFifo156_rsv3;
+   u32 TxPktFifo157[3];                 /* 0x000049d0 */
+   u32 TxPktFifo157_rsv3;
+   u32 TxPktFifo158[3];                 /* 0x000049e0 */
+   u32 TxPktFifo158_rsv3;
+   u32 TxPktFifo159[3];                 /* 0x000049f0 */
+   u32 TxPktFifo159_rsv3;
+   u32 TxPktFifo160[3];                 /* 0x00004a00 */
+   u32 TxPktFifo160_rsv3;
+   u32 TxPktFifo161[3];                 /* 0x00004a10 */
+   u32 TxPktFifo161_rsv3;
+   u32 TxPktFifo162[3];                 /* 0x00004a20 */
+   u32 TxPktFifo162_rsv3;
+   u32 TxPktFifo163[3];                 /* 0x00004a30 */
+   u32 TxPktFifo163_rsv3;
+   u32 TxPktFifo164[3];                 /* 0x00004a40 */
+   u32 TxPktFifo164_rsv3;
+   u32 TxPktFifo165[3];                 /* 0x00004a50 */
+   u32 TxPktFifo165_rsv3;
+   u32 TxPktFifo166[3];                 /* 0x00004a60 */
+   u32 TxPktFifo166_rsv3;
+   u32 TxPktFifo167[3];                 /* 0x00004a70 */
+   u32 TxPktFifo167_rsv3;
+   u32 TxPktFifo168[3];                 /* 0x00004a80 */
+   u32 TxPktFifo168_rsv3;
+   u32 TxPktFifo169[3];                 /* 0x00004a90 */
+   u32 TxPktFifo169_rsv3;
+   u32 TxPktFifo170[3];                 /* 0x00004aa0 */
+   u32 TxPktFifo170_rsv3;
+   u32 TxPktFifo171[3];                 /* 0x00004ab0 */
+   u32 TxPktFifo171_rsv3;
+   u32 TxPktFifo172[3];                 /* 0x00004ac0 */
+   u32 TxPktFifo172_rsv3;
+   u32 TxPktFifo173[3];                 /* 0x00004ad0 */
+   u32 TxPktFifo173_rsv3;
+   u32 TxPktFifo174[3];                 /* 0x00004ae0 */
+   u32 TxPktFifo174_rsv3;
+   u32 TxPktFifo175[3];                 /* 0x00004af0 */
+   u32 TxPktFifo175_rsv3;
+   u32 TxPktFifo176[3];                 /* 0x00004b00 */
+   u32 TxPktFifo176_rsv3;
+   u32 TxPktFifo177[3];                 /* 0x00004b10 */
+   u32 TxPktFifo177_rsv3;
+   u32 TxPktFifo178[3];                 /* 0x00004b20 */
+   u32 TxPktFifo178_rsv3;
+   u32 TxPktFifo179[3];                 /* 0x00004b30 */
+   u32 TxPktFifo179_rsv3;
+   u32 TxPktFifo180[3];                 /* 0x00004b40 */
+   u32 TxPktFifo180_rsv3;
+   u32 TxPktFifo181[3];                 /* 0x00004b50 */
+   u32 TxPktFifo181_rsv3;
+   u32 TxPktFifo182[3];                 /* 0x00004b60 */
+   u32 TxPktFifo182_rsv3;
+   u32 TxPktFifo183[3];                 /* 0x00004b70 */
+   u32 TxPktFifo183_rsv3;
+   u32 TxPktFifo184[3];                 /* 0x00004b80 */
+   u32 TxPktFifo184_rsv3;
+   u32 TxPktFifo185[3];                 /* 0x00004b90 */
+   u32 TxPktFifo185_rsv3;
+   u32 TxPktFifo186[3];                 /* 0x00004ba0 */
+   u32 TxPktFifo186_rsv3;
+   u32 TxPktFifo187[3];                 /* 0x00004bb0 */
+   u32 TxPktFifo187_rsv3;
+   u32 TxPktFifo188[3];                 /* 0x00004bc0 */
+   u32 TxPktFifo188_rsv3;
+   u32 TxPktFifo189[3];                 /* 0x00004bd0 */
+   u32 TxPktFifo189_rsv3;
+   u32 TxPktFifo190[3];                 /* 0x00004be0 */
+   u32 TxPktFifo190_rsv3;
+   u32 TxPktFifo191[3];                 /* 0x00004bf0 */
+   u32 TxPktFifo191_rsv3;
+   u32 TxPktFifo192[3];                 /* 0x00004c00 */
+   u32 TxPktFifo192_rsv3;
+   u32 TxPktFifo193[3];                 /* 0x00004c10 */
+   u32 TxPktFifo193_rsv3;
+   u32 TxPktFifo194[3];                 /* 0x00004c20 */
+   u32 TxPktFifo194_rsv3;
+   u32 TxPktFifo195[3];                 /* 0x00004c30 */
+   u32 TxPktFifo195_rsv3;
+   u32 TxPktFifo196[3];                 /* 0x00004c40 */
+   u32 TxPktFifo196_rsv3;
+   u32 TxPktFifo197[3];                 /* 0x00004c50 */
+   u32 TxPktFifo197_rsv3;
+   u32 TxPktFifo198[3];                 /* 0x00004c60 */
+   u32 TxPktFifo198_rsv3;
+   u32 TxPktFifo199[3];                 /* 0x00004c70 */
+   u32 TxPktFifo199_rsv3;
+   u32 TxPktFifo200[3];                 /* 0x00004c80 */
+   u32 TxPktFifo200_rsv3;
+   u32 TxPktFifo201[3];                 /* 0x00004c90 */
+   u32 TxPktFifo201_rsv3;
+   u32 TxPktFifo202[3];                 /* 0x00004ca0 */
+   u32 TxPktFifo202_rsv3;
+   u32 TxPktFifo203[3];                 /* 0x00004cb0 */
+   u32 TxPktFifo203_rsv3;
+   u32 TxPktFifo204[3];                 /* 0x00004cc0 */
+   u32 TxPktFifo204_rsv3;
+   u32 TxPktFifo205[3];                 /* 0x00004cd0 */
+   u32 TxPktFifo205_rsv3;
+   u32 TxPktFifo206[3];                 /* 0x00004ce0 */
+   u32 TxPktFifo206_rsv3;
+   u32 TxPktFifo207[3];                 /* 0x00004cf0 */
+   u32 TxPktFifo207_rsv3;
+   u32 TxPktFifo208[3];                 /* 0x00004d00 */
+   u32 TxPktFifo208_rsv3;
+   u32 TxPktFifo209[3];                 /* 0x00004d10 */
+   u32 TxPktFifo209_rsv3;
+   u32 TxPktFifo210[3];                 /* 0x00004d20 */
+   u32 TxPktFifo210_rsv3;
+   u32 TxPktFifo211[3];                 /* 0x00004d30 */
+   u32 TxPktFifo211_rsv3;
+   u32 TxPktFifo212[3];                 /* 0x00004d40 */
+   u32 TxPktFifo212_rsv3;
+   u32 TxPktFifo213[3];                 /* 0x00004d50 */
+   u32 TxPktFifo213_rsv3;
+   u32 TxPktFifo214[3];                 /* 0x00004d60 */
+   u32 TxPktFifo214_rsv3;
+   u32 TxPktFifo215[3];                 /* 0x00004d70 */
+   u32 TxPktFifo215_rsv3;
+   u32 TxPktFifo216[3];                 /* 0x00004d80 */
+   u32 TxPktFifo216_rsv3;
+   u32 TxPktFifo217[3];                 /* 0x00004d90 */
+   u32 TxPktFifo217_rsv3;
+   u32 TxPktFifo218[3];                 /* 0x00004da0 */
+   u32 TxPktFifo218_rsv3;
+   u32 TxPktFifo219[3];                 /* 0x00004db0 */
+   u32 TxPktFifo219_rsv3;
+   u32 TxPktFifo220[3];                 /* 0x00004dc0 */
+   u32 TxPktFifo220_rsv3;
+   u32 TxPktFifo221[3];                 /* 0x00004dd0 */
+   u32 TxPktFifo221_rsv3;
+   u32 TxPktFifo222[3];                 /* 0x00004de0 */
+   u32 TxPktFifo222_rsv3;
+   u32 TxPktFifo223[3];                 /* 0x00004df0 */
+   u32 TxPktFifo223_rsv3;
+   u32 TxPktFifo224[3];                 /* 0x00004e00 */
+   u32 TxPktFifo224_rsv3;
+   u32 TxPktFifo225[3];                 /* 0x00004e10 */
+   u32 TxPktFifo225_rsv3;
+   u32 TxPktFifo226[3];                 /* 0x00004e20 */
+   u32 TxPktFifo226_rsv3;
+   u32 TxPktFifo227[3];                 /* 0x00004e30 */
+   u32 TxPktFifo227_rsv3;
+   u32 TxPktFifo228[3];                 /* 0x00004e40 */
+   u32 TxPktFifo228_rsv3;
+   u32 TxPktFifo229[3];                 /* 0x00004e50 */
+   u32 TxPktFifo229_rsv3;
+   u32 TxPktFifo230[3];                 /* 0x00004e60 */
+   u32 TxPktFifo230_rsv3;
+   u32 TxPktFifo231[3];                 /* 0x00004e70 */
+   u32 TxPktFifo231_rsv3;
+   u32 TxPktFifo232[3];                 /* 0x00004e80 */
+   u32 TxPktFifo232_rsv3;
+   u32 TxPktFifo233[3];                 /* 0x00004e90 */
+   u32 TxPktFifo233_rsv3;
+   u32 TxPktFifo234[3];                 /* 0x00004ea0 */
+   u32 TxPktFifo234_rsv3;
+   u32 TxPktFifo235[3];                 /* 0x00004eb0 */
+   u32 TxPktFifo235_rsv3;
+   u32 TxPktFifo236[3];                 /* 0x00004ec0 */
+   u32 TxPktFifo236_rsv3;
+   u32 TxPktFifo237[3];                 /* 0x00004ed0 */
+   u32 TxPktFifo237_rsv3;
+   u32 TxPktFifo238[3];                 /* 0x00004ee0 */
+   u32 TxPktFifo238_rsv3;
+   u32 TxPktFifo239[3];                 /* 0x00004ef0 */
+   u32 TxPktFifo239_rsv3;
+   u32 TxPktFifo240[3];                 /* 0x00004f00 */
+   u32 TxPktFifo240_rsv3;
+   u32 TxPktFifo241[3];                 /* 0x00004f10 */
+   u32 TxPktFifo241_rsv3;
+   u32 TxPktFifo242[3];                 /* 0x00004f20 */
+   u32 TxPktFifo242_rsv3;
+   u32 TxPktFifo243[3];                 /* 0x00004f30 */
+   u32 TxPktFifo243_rsv3;
+   u32 TxPktFifo244[3];                 /* 0x00004f40 */
+   u32 TxPktFifo244_rsv3;
+   u32 TxPktFifo245[3];                 /* 0x00004f50 */
+   u32 TxPktFifo245_rsv3;
+   u32 TxPktFifo246[3];                 /* 0x00004f60 */
+   u32 TxPktFifo246_rsv3;
+   u32 TxPktFifo247[3];                 /* 0x00004f70 */
+   u32 TxPktFifo247_rsv3;
+   u32 TxPktFifo248[3];                 /* 0x00004f80 */
+   u32 TxPktFifo248_rsv3;
+   u32 TxPktFifo249[3];                 /* 0x00004f90 */
+   u32 TxPktFifo249_rsv3;
+   u32 TxPktFifo250[3];                 /* 0x00004fa0 */
+   u32 TxPktFifo250_rsv3;
+   u32 TxPktFifo251[3];                 /* 0x00004fb0 */
+   u32 TxPktFifo251_rsv3;
+   u32 TxPktFifo252[3];                 /* 0x00004fc0 */
+   u32 TxPktFifo252_rsv3;
+   u32 TxPktFifo253[3];                 /* 0x00004fd0 */
+   u32 TxPktFifo253_rsv3;
+   u32 TxPktFifo254[3];                 /* 0x00004fe0 */
+   u32 TxPktFifo254_rsv3;
+   u32 TxPktFifo255[3];                 /* 0x00004ff0 */
+   u32 TxPktFifo255_rsv3;
+   u32 TxPktFifo256[3];                 /* 0x00005000 */
+   u32 TxPktFifo256_rsv3;
+   u32 TxPktFifo257[3];                 /* 0x00005010 */
+   u32 TxPktFifo257_rsv3;
+   u32 TxPktFifo258[3];                 /* 0x00005020 */
+   u32 TxPktFifo258_rsv3;
+   u32 TxPktFifo259[3];                 /* 0x00005030 */
+   u32 TxPktFifo259_rsv3;
+   u32 TxPktFifo260[3];                 /* 0x00005040 */
+   u32 TxPktFifo260_rsv3;
+   u32 TxPktFifo261[3];                 /* 0x00005050 */
+   u32 TxPktFifo261_rsv3;
+   u32 TxPktFifo262[3];                 /* 0x00005060 */
+   u32 TxPktFifo262_rsv3;
+   u32 TxPktFifo263[3];                 /* 0x00005070 */
+   u32 TxPktFifo263_rsv3;
+   u32 TxPktFifo264[3];                 /* 0x00005080 */
+   u32 TxPktFifo264_rsv3;
+   u32 TxPktFifo265[3];                 /* 0x00005090 */
+   u32 TxPktFifo265_rsv3;
+   u32 TxPktFifo266[3];                 /* 0x000050a0 */
+   u32 TxPktFifo266_rsv3;
+   u32 TxPktFifo267[3];                 /* 0x000050b0 */
+   u32 TxPktFifo267_rsv3;
+   u32 TxPktFifo268[3];                 /* 0x000050c0 */
+   u32 TxPktFifo268_rsv3;
+   u32 TxPktFifo269[3];                 /* 0x000050d0 */
+   u32 TxPktFifo269_rsv3;
+   u32 TxPktFifo270[3];                 /* 0x000050e0 */
+   u32 TxPktFifo270_rsv3;
+   u32 TxPktFifo271[3];                 /* 0x000050f0 */
+   u32 TxPktFifo271_rsv3;
+   u32 TxPktFifo272[3];                 /* 0x00005100 */
+   u32 TxPktFifo272_rsv3;
+   u32 TxPktFifo273[3];                 /* 0x00005110 */
+   u32 TxPktFifo273_rsv3;
+   u32 TxPktFifo274[3];                 /* 0x00005120 */
+   u32 TxPktFifo274_rsv3;
+   u32 TxPktFifo275[3];                 /* 0x00005130 */
+   u32 TxPktFifo275_rsv3;
+   u32 TxPktFifo276[3];                 /* 0x00005140 */
+   u32 TxPktFifo276_rsv3;
+   u32 TxPktFifo277[3];                 /* 0x00005150 */
+   u32 TxPktFifo277_rsv3;
+   u32 TxPktFifo278[3];                 /* 0x00005160 */
+   u32 TxPktFifo278_rsv3;
+   u32 TxPktFifo279[3];                 /* 0x00005170 */
+   u32 TxPktFifo279_rsv3;
+   u32 TxPktFifo280[3];                 /* 0x00005180 */
+   u32 TxPktFifo280_rsv3;
+   u32 TxPktFifo281[3];                 /* 0x00005190 */
+   u32 TxPktFifo281_rsv3;
+   u32 TxPktFifo282[3];                 /* 0x000051a0 */
+   u32 TxPktFifo282_rsv3;
+   u32 TxPktFifo283[3];                 /* 0x000051b0 */
+   u32 TxPktFifo283_rsv3;
+   u32 TxPktFifo284[3];                 /* 0x000051c0 */
+   u32 TxPktFifo284_rsv3;
+   u32 TxPktFifo285[3];                 /* 0x000051d0 */
+   u32 TxPktFifo285_rsv3;
+   u32 TxPktFifo286[3];                 /* 0x000051e0 */
+   u32 TxPktFifo286_rsv3;
+   u32 TxPktFifo287[3];                 /* 0x000051f0 */
+   u32 TxPktFifo287_rsv3;
+   u32 TxPktFifo288[3];                 /* 0x00005200 */
+   u32 TxPktFifo288_rsv3;
+   u32 TxPktFifo289[3];                 /* 0x00005210 */
+   u32 TxPktFifo289_rsv3;
+   u32 TxPktFifo290[3];                 /* 0x00005220 */
+   u32 TxPktFifo290_rsv3;
+   u32 TxPktFifo291[3];                 /* 0x00005230 */
+   u32 TxPktFifo291_rsv3;
+   u32 TxPktFifo292[3];                 /* 0x00005240 */
+   u32 TxPktFifo292_rsv3;
+   u32 TxPktFifo293[3];                 /* 0x00005250 */
+   u32 TxPktFifo293_rsv3;
+   u32 TxPktFifo294[3];                 /* 0x00005260 */
+   u32 TxPktFifo294_rsv3;
+   u32 TxPktFifo295[3];                 /* 0x00005270 */
+   u32 TxPktFifo295_rsv3;
+   u32 TxPktFifo296[3];                 /* 0x00005280 */
+   u32 TxPktFifo296_rsv3;
+   u32 TxPktFifo297[3];                 /* 0x00005290 */
+   u32 TxPktFifo297_rsv3;
+   u32 TxPktFifo298[3];                 /* 0x000052a0 */
+   u32 TxPktFifo298_rsv3;
+   u32 TxPktFifo299[3];                 /* 0x000052b0 */
+   u32 TxPktFifo299_rsv3;
+   u32 TxPktFifo300[3];                 /* 0x000052c0 */
+   u32 TxPktFifo300_rsv3;
+   u32 TxPktFifo301[3];                 /* 0x000052d0 */
+   u32 TxPktFifo301_rsv3;
+   u32 TxPktFifo302[3];                 /* 0x000052e0 */
+   u32 TxPktFifo302_rsv3;
+   u32 TxPktFifo303[3];                 /* 0x000052f0 */
+   u32 TxPktFifo303_rsv3;
+   u32 TxPktFifo304[3];                 /* 0x00005300 */
+   u32 TxPktFifo304_rsv3;
+   u32 TxPktFifo305[3];                 /* 0x00005310 */
+   u32 TxPktFifo305_rsv3;
+   u32 TxPktFifo306[3];                 /* 0x00005320 */
+   u32 TxPktFifo306_rsv3;
+   u32 TxPktFifo307[3];                 /* 0x00005330 */
+   u32 TxPktFifo307_rsv3;
+   u32 TxPktFifo308[3];                 /* 0x00005340 */
+   u32 TxPktFifo308_rsv3;
+   u32 TxPktFifo309[3];                 /* 0x00005350 */
+   u32 TxPktFifo309_rsv3;
+   u32 TxPktFifo310[3];                 /* 0x00005360 */
+   u32 TxPktFifo310_rsv3;
+   u32 TxPktFifo311[3];                 /* 0x00005370 */
+   u32 TxPktFifo311_rsv3;
+   u32 TxPktFifo312[3];                 /* 0x00005380 */
+   u32 TxPktFifo312_rsv3;
+   u32 TxPktFifo313[3];                 /* 0x00005390 */
+   u32 TxPktFifo313_rsv3;
+   u32 TxPktFifo314[3];                 /* 0x000053a0 */
+   u32 TxPktFifo314_rsv3;
+   u32 TxPktFifo315[3];                 /* 0x000053b0 */
+   u32 TxPktFifo315_rsv3;
+   u32 TxPktFifo316[3];                 /* 0x000053c0 */
+   u32 TxPktFifo316_rsv3;
+   u32 TxPktFifo317[3];                 /* 0x000053d0 */
+   u32 TxPktFifo317_rsv3;
+   u32 TxPktFifo318[3];                 /* 0x000053e0 */
+   u32 TxPktFifo318_rsv3;
+   u32 TxPktFifo319[3];                 /* 0x000053f0 */
+   u32 TxPktFifo319_rsv3;
+   u32 TxPktFifo320[3];                 /* 0x00005400 */
+   u32 TxPktFifo320_rsv3;
+   u32 TxPktFifo321[3];                 /* 0x00005410 */
+   u32 TxPktFifo321_rsv3;
+   u32 TxPktFifo322[3];                 /* 0x00005420 */
+   u32 TxPktFifo322_rsv3;
+   u32 TxPktFifo323[3];                 /* 0x00005430 */
+   u32 TxPktFifo323_rsv3;
+   u32 TxPktFifo324[3];                 /* 0x00005440 */
+   u32 TxPktFifo324_rsv3;
+   u32 TxPktFifo325[3];                 /* 0x00005450 */
+   u32 TxPktFifo325_rsv3;
+   u32 TxPktFifo326[3];                 /* 0x00005460 */
+   u32 TxPktFifo326_rsv3;
+   u32 TxPktFifo327[3];                 /* 0x00005470 */
+   u32 TxPktFifo327_rsv3;
+   u32 TxPktFifo328[3];                 /* 0x00005480 */
+   u32 TxPktFifo328_rsv3;
+   u32 TxPktFifo329[3];                 /* 0x00005490 */
+   u32 TxPktFifo329_rsv3;
+   u32 TxPktFifo330[3];                 /* 0x000054a0 */
+   u32 TxPktFifo330_rsv3;
+   u32 TxPktFifo331[3];                 /* 0x000054b0 */
+   u32 TxPktFifo331_rsv3;
+   u32 TxPktFifo332[3];                 /* 0x000054c0 */
+   u32 TxPktFifo332_rsv3;
+   u32 TxPktFifo333[3];                 /* 0x000054d0 */
+   u32 TxPktFifo333_rsv3;
+   u32 TxPktFifo334[3];                 /* 0x000054e0 */
+   u32 TxPktFifo334_rsv3;
+   u32 TxPktFifo335[3];                 /* 0x000054f0 */
+   u32 TxPktFifo335_rsv3;
+   u32 TxPktFifo336[3];                 /* 0x00005500 */
+   u32 TxPktFifo336_rsv3;
+   u32 TxPktFifo337[3];                 /* 0x00005510 */
+   u32 TxPktFifo337_rsv3;
+   u32 TxPktFifo338[3];                 /* 0x00005520 */
+   u32 TxPktFifo338_rsv3;
+   u32 TxPktFifo339[3];                 /* 0x00005530 */
+   u32 TxPktFifo339_rsv3;
+   u32 TxPktFifo340[3];                 /* 0x00005540 */
+   u32 TxPktFifo340_rsv3;
+   u32 TxPktFifo341[3];                 /* 0x00005550 */
+   u32 TxPktFifo341_rsv3;
+   u32 TxPktFifo342[3];                 /* 0x00005560 */
+   u32 TxPktFifo342_rsv3;
+   u32 TxPktFifo343[3];                 /* 0x00005570 */
+   u32 TxPktFifo343_rsv3;
+   u32 TxPktFifo344[3];                 /* 0x00005580 */
+   u32 TxPktFifo344_rsv3;
+   u32 TxPktFifo345[3];                 /* 0x00005590 */
+   u32 TxPktFifo345_rsv3;
+   u32 TxPktFifo346[3];                 /* 0x000055a0 */
+   u32 TxPktFifo346_rsv3;
+   u32 TxPktFifo347[3];                 /* 0x000055b0 */
+   u32 TxPktFifo347_rsv3;
+   u32 TxPktFifo348[3];                 /* 0x000055c0 */
+   u32 TxPktFifo348_rsv3;
+   u32 TxPktFifo349[3];                 /* 0x000055d0 */
+   u32 TxPktFifo349_rsv3;
+   u32 TxPktFifo350[3];                 /* 0x000055e0 */
+   u32 TxPktFifo350_rsv3;
+   u32 TxPktFifo351[3];                 /* 0x000055f0 */
+   u32 TxPktFifo351_rsv3;
+   u32 TxPktFifo352[3];                 /* 0x00005600 */
+   u32 TxPktFifo352_rsv3;
+   u32 TxPktFifo353[3];                 /* 0x00005610 */
+   u32 TxPktFifo353_rsv3;
+   u32 TxPktFifo354[3];                 /* 0x00005620 */
+   u32 TxPktFifo354_rsv3;
+   u32 TxPktFifo355[3];                 /* 0x00005630 */
+   u32 TxPktFifo355_rsv3;
+   u32 TxPktFifo356[3];                 /* 0x00005640 */
+   u32 TxPktFifo356_rsv3;
+   u32 TxPktFifo357[3];                 /* 0x00005650 */
+   u32 TxPktFifo357_rsv3;
+   u32 TxPktFifo358[3];                 /* 0x00005660 */
+   u32 TxPktFifo358_rsv3;
+   u32 TxPktFifo359[3];                 /* 0x00005670 */
+   u32 TxPktFifo359_rsv3;
+   u32 TxPktFifo360[3];                 /* 0x00005680 */
+   u32 TxPktFifo360_rsv3;
+   u32 TxPktFifo361[3];                 /* 0x00005690 */
+   u32 TxPktFifo361_rsv3;
+   u32 TxPktFifo362[3];                 /* 0x000056a0 */
+   u32 TxPktFifo362_rsv3;
+   u32 TxPktFifo363[3];                 /* 0x000056b0 */
+   u32 TxPktFifo363_rsv3;
+   u32 TxPktFifo364[3];                 /* 0x000056c0 */
+   u32 TxPktFifo364_rsv3;
+   u32 TxPktFifo365[3];                 /* 0x000056d0 */
+   u32 TxPktFifo365_rsv3;
+   u32 TxPktFifo366[3];                 /* 0x000056e0 */
+   u32 TxPktFifo366_rsv3;
+   u32 TxPktFifo367[3];                 /* 0x000056f0 */
+   u32 TxPktFifo367_rsv3;
+   u32 TxPktFifo368[3];                 /* 0x00005700 */
+   u32 TxPktFifo368_rsv3;
+   u32 TxPktFifo369[3];                 /* 0x00005710 */
+   u32 TxPktFifo369_rsv3;
+   u32 TxPktFifo370[3];                 /* 0x00005720 */
+   u32 TxPktFifo370_rsv3;
+   u32 TxPktFifo371[3];                 /* 0x00005730 */
+   u32 TxPktFifo371_rsv3;
+   u32 TxPktFifo372[3];                 /* 0x00005740 */
+   u32 TxPktFifo372_rsv3;
+   u32 TxPktFifo373[3];                 /* 0x00005750 */
+   u32 TxPktFifo373_rsv3;
+   u32 TxPktFifo374[3];                 /* 0x00005760 */
+   u32 TxPktFifo374_rsv3;
+   u32 TxPktFifo375[3];                 /* 0x00005770 */
+   u32 TxPktFifo375_rsv3;
+   u32 TxPktFifo376[3];                 /* 0x00005780 */
+   u32 TxPktFifo376_rsv3;
+   u32 TxPktFifo377[3];                 /* 0x00005790 */
+   u32 TxPktFifo377_rsv3;
+   u32 TxPktFifo378[3];                 /* 0x000057a0 */
+   u32 TxPktFifo378_rsv3;
+   u32 TxPktFifo379[3];                 /* 0x000057b0 */
+   u32 TxPktFifo379_rsv3;
+   u32 TxPktFifo380[3];                 /* 0x000057c0 */
+   u32 TxPktFifo380_rsv3;
+   u32 TxPktFifo381[3];                 /* 0x000057d0 */
+   u32 TxPktFifo381_rsv3;
+   u32 TxPktFifo382[3];                 /* 0x000057e0 */
+   u32 TxPktFifo382_rsv3;
+   u32 TxPktFifo383[3];                 /* 0x000057f0 */
+   u32 TxPktFifo383_rsv3;
+   u32 TxPktFifo384[3];                 /* 0x00005800 */
+   u32 TxPktFifo384_rsv3;
+   u32 TxPktFifo385[3];                 /* 0x00005810 */
+   u32 TxPktFifo385_rsv3;
+   u32 TxPktFifo386[3];                 /* 0x00005820 */
+   u32 TxPktFifo386_rsv3;
+   u32 TxPktFifo387[3];                 /* 0x00005830 */
+   u32 TxPktFifo387_rsv3;
+   u32 TxPktFifo388[3];                 /* 0x00005840 */
+   u32 TxPktFifo388_rsv3;
+   u32 TxPktFifo389[3];                 /* 0x00005850 */
+   u32 TxPktFifo389_rsv3;
+   u32 TxPktFifo390[3];                 /* 0x00005860 */
+   u32 TxPktFifo390_rsv3;
+   u32 TxPktFifo391[3];                 /* 0x00005870 */
+   u32 TxPktFifo391_rsv3;
+   u32 TxPktFifo392[3];                 /* 0x00005880 */
+   u32 TxPktFifo392_rsv3;
+   u32 TxPktFifo393[3];                 /* 0x00005890 */
+   u32 TxPktFifo393_rsv3;
+   u32 TxPktFifo394[3];                 /* 0x000058a0 */
+   u32 TxPktFifo394_rsv3;
+   u32 TxPktFifo395[3];                 /* 0x000058b0 */
+   u32 TxPktFifo395_rsv3;
+   u32 TxPktFifo396[3];                 /* 0x000058c0 */
+   u32 TxPktFifo396_rsv3;
+   u32 TxPktFifo397[3];                 /* 0x000058d0 */
+   u32 TxPktFifo397_rsv3;
+   u32 TxPktFifo398[3];                 /* 0x000058e0 */
+   u32 TxPktFifo398_rsv3;
+   u32 TxPktFifo399[3];                 /* 0x000058f0 */
+   u32 TxPktFifo399_rsv3;
+   u32 TxPktFifo400[3];                 /* 0x00005900 */
+   u32 TxPktFifo400_rsv3;
+   u32 TxPktFifo401[3];                 /* 0x00005910 */
+   u32 TxPktFifo401_rsv3;
+   u32 TxPktFifo402[3];                 /* 0x00005920 */
+   u32 TxPktFifo402_rsv3;
+   u32 TxPktFifo403[3];                 /* 0x00005930 */
+   u32 TxPktFifo403_rsv3;
+   u32 TxPktFifo404[3];                 /* 0x00005940 */
+   u32 TxPktFifo404_rsv3;
+   u32 TxPktFifo405[3];                 /* 0x00005950 */
+   u32 TxPktFifo405_rsv3;
+   u32 TxPktFifo406[3];                 /* 0x00005960 */
+   u32 TxPktFifo406_rsv3;
+   u32 TxPktFifo407[3];                 /* 0x00005970 */
+   u32 TxPktFifo407_rsv3;
+   u32 TxPktFifo408[3];                 /* 0x00005980 */
+   u32 TxPktFifo408_rsv3;
+   u32 TxPktFifo409[3];                 /* 0x00005990 */
+   u32 TxPktFifo409_rsv3;
+   u32 TxPktFifo410[3];                 /* 0x000059a0 */
+   u32 TxPktFifo410_rsv3;
+   u32 TxPktFifo411[3];                 /* 0x000059b0 */
+   u32 TxPktFifo411_rsv3;
+   u32 TxPktFifo412[3];                 /* 0x000059c0 */
+   u32 TxPktFifo412_rsv3;
+   u32 TxPktFifo413[3];                 /* 0x000059d0 */
+   u32 TxPktFifo413_rsv3;
+   u32 TxPktFifo414[3];                 /* 0x000059e0 */
+   u32 TxPktFifo414_rsv3;
+   u32 TxPktFifo415[3];                 /* 0x000059f0 */
+   u32 TxPktFifo415_rsv3;
+   u32 TxPktFifo416[3];                 /* 0x00005a00 */
+   u32 TxPktFifo416_rsv3;
+   u32 TxPktFifo417[3];                 /* 0x00005a10 */
+   u32 TxPktFifo417_rsv3;
+   u32 TxPktFifo418[3];                 /* 0x00005a20 */
+   u32 TxPktFifo418_rsv3;
+   u32 TxPktFifo419[3];                 /* 0x00005a30 */
+   u32 TxPktFifo419_rsv3;
+   u32 TxPktFifo420[3];                 /* 0x00005a40 */
+   u32 TxPktFifo420_rsv3;
+   u32 TxPktFifo421[3];                 /* 0x00005a50 */
+   u32 TxPktFifo421_rsv3;
+   u32 TxPktFifo422[3];                 /* 0x00005a60 */
+   u32 TxPktFifo422_rsv3;
+   u32 TxPktFifo423[3];                 /* 0x00005a70 */
+   u32 TxPktFifo423_rsv3;
+   u32 TxPktFifo424[3];                 /* 0x00005a80 */
+   u32 TxPktFifo424_rsv3;
+   u32 TxPktFifo425[3];                 /* 0x00005a90 */
+   u32 TxPktFifo425_rsv3;
+   u32 TxPktFifo426[3];                 /* 0x00005aa0 */
+   u32 TxPktFifo426_rsv3;
+   u32 TxPktFifo427[3];                 /* 0x00005ab0 */
+   u32 TxPktFifo427_rsv3;
+   u32 TxPktFifo428[3];                 /* 0x00005ac0 */
+   u32 TxPktFifo428_rsv3;
+   u32 TxPktFifo429[3];                 /* 0x00005ad0 */
+   u32 TxPktFifo429_rsv3;
+   u32 TxPktFifo430[3];                 /* 0x00005ae0 */
+   u32 TxPktFifo430_rsv3;
+   u32 TxPktFifo431[3];                 /* 0x00005af0 */
+   u32 TxPktFifo431_rsv3;
+   u32 TxPktFifo432[3];                 /* 0x00005b00 */
+   u32 TxPktFifo432_rsv3;
+   u32 TxPktFifo433[3];                 /* 0x00005b10 */
+   u32 TxPktFifo433_rsv3;
+   u32 TxPktFifo434[3];                 /* 0x00005b20 */
+   u32 TxPktFifo434_rsv3;
+   u32 TxPktFifo435[3];                 /* 0x00005b30 */
+   u32 TxPktFifo435_rsv3;
+   u32 TxPktFifo436[3];                 /* 0x00005b40 */
+   u32 TxPktFifo436_rsv3;
+   u32 TxPktFifo437[3];                 /* 0x00005b50 */
+   u32 TxPktFifo437_rsv3;
+   u32 TxPktFifo438[3];                 /* 0x00005b60 */
+   u32 TxPktFifo438_rsv3;
+   u32 TxPktFifo439[3];                 /* 0x00005b70 */
+   u32 TxPktFifo439_rsv3;
+   u32 TxPktFifo440[3];                 /* 0x00005b80 */
+   u32 TxPktFifo440_rsv3;
+   u32 TxPktFifo441[3];                 /* 0x00005b90 */
+   u32 TxPktFifo441_rsv3;
+   u32 TxPktFifo442[3];                 /* 0x00005ba0 */
+   u32 TxPktFifo442_rsv3;
+   u32 TxPktFifo443[3];                 /* 0x00005bb0 */
+   u32 TxPktFifo443_rsv3;
+   u32 TxPktFifo444[3];                 /* 0x00005bc0 */
+   u32 TxPktFifo444_rsv3;
+   u32 TxPktFifo445[3];                 /* 0x00005bd0 */
+   u32 TxPktFifo445_rsv3;
+   u32 TxPktFifo446[3];                 /* 0x00005be0 */
+   u32 TxPktFifo446_rsv3;
+   u32 TxPktFifo447[3];                 /* 0x00005bf0 */
+   u32 TxPktFifo447_rsv3;
+   u32 TxPktFifo448[3];                 /* 0x00005c00 */
+   u32 TxPktFifo448_rsv3;
+   u32 TxPktFifo449[3];                 /* 0x00005c10 */
+   u32 TxPktFifo449_rsv3;
+   u32 TxPktFifo450[3];                 /* 0x00005c20 */
+   u32 TxPktFifo450_rsv3;
+   u32 TxPktFifo451[3];                 /* 0x00005c30 */
+   u32 TxPktFifo451_rsv3;
+   u32 TxPktFifo452[3];                 /* 0x00005c40 */
+   u32 TxPktFifo452_rsv3;
+   u32 TxPktFifo453[3];                 /* 0x00005c50 */
+   u32 TxPktFifo453_rsv3;
+   u32 TxPktFifo454[3];                 /* 0x00005c60 */
+   u32 TxPktFifo454_rsv3;
+   u32 TxPktFifo455[3];                 /* 0x00005c70 */
+   u32 TxPktFifo455_rsv3;
+   u32 TxPktFifo456[3];                 /* 0x00005c80 */
+   u32 TxPktFifo456_rsv3;
+   u32 TxPktFifo457[3];                 /* 0x00005c90 */
+   u32 TxPktFifo457_rsv3;
+   u32 TxPktFifo458[3];                 /* 0x00005ca0 */
+   u32 TxPktFifo458_rsv3;
+   u32 TxPktFifo459[3];                 /* 0x00005cb0 */
+   u32 TxPktFifo459_rsv3;
+   u32 TxPktFifo460[3];                 /* 0x00005cc0 */
+   u32 TxPktFifo460_rsv3;
+   u32 TxPktFifo461[3];                 /* 0x00005cd0 */
+   u32 TxPktFifo461_rsv3;
+   u32 TxPktFifo462[3];                 /* 0x00005ce0 */
+   u32 TxPktFifo462_rsv3;
+   u32 TxPktFifo463[3];                 /* 0x00005cf0 */
+   u32 TxPktFifo463_rsv3;
+   u32 TxPktFifo464[3];                 /* 0x00005d00 */
+   u32 TxPktFifo464_rsv3;
+   u32 TxPktFifo465[3];                 /* 0x00005d10 */
+   u32 TxPktFifo465_rsv3;
+   u32 TxPktFifo466[3];                 /* 0x00005d20 */
+   u32 TxPktFifo466_rsv3;
+   u32 TxPktFifo467[3];                 /* 0x00005d30 */
+   u32 TxPktFifo467_rsv3;
+   u32 TxPktFifo468[3];                 /* 0x00005d40 */
+   u32 TxPktFifo468_rsv3;
+   u32 TxPktFifo469[3];                 /* 0x00005d50 */
+   u32 TxPktFifo469_rsv3;
+   u32 TxPktFifo470[3];                 /* 0x00005d60 */
+   u32 TxPktFifo470_rsv3;
+   u32 TxPktFifo471[3];                 /* 0x00005d70 */
+   u32 TxPktFifo471_rsv3;
+   u32 TxPktFifo472[3];                 /* 0x00005d80 */
+   u32 TxPktFifo472_rsv3;
+   u32 TxPktFifo473[3];                 /* 0x00005d90 */
+   u32 TxPktFifo473_rsv3;
+   u32 TxPktFifo474[3];                 /* 0x00005da0 */
+   u32 TxPktFifo474_rsv3;
+   u32 TxPktFifo475[3];                 /* 0x00005db0 */
+   u32 TxPktFifo475_rsv3;
+   u32 TxPktFifo476[3];                 /* 0x00005dc0 */
+   u32 TxPktFifo476_rsv3;
+   u32 TxPktFifo477[3];                 /* 0x00005dd0 */
+   u32 TxPktFifo477_rsv3;
+   u32 TxPktFifo478[3];                 /* 0x00005de0 */
+   u32 TxPktFifo478_rsv3;
+   u32 TxPktFifo479[3];                 /* 0x00005df0 */
+   u32 TxPktFifo479_rsv3;
+   u32 TxPktFifo480[3];                 /* 0x00005e00 */
+   u32 TxPktFifo480_rsv3;
+   u32 TxPktFifo481[3];                 /* 0x00005e10 */
+   u32 TxPktFifo481_rsv3;
+   u32 TxPktFifo482[3];                 /* 0x00005e20 */
+   u32 TxPktFifo482_rsv3;
+   u32 TxPktFifo483[3];                 /* 0x00005e30 */
+   u32 TxPktFifo483_rsv3;
+   u32 TxPktFifo484[3];                 /* 0x00005e40 */
+   u32 TxPktFifo484_rsv3;
+   u32 TxPktFifo485[3];                 /* 0x00005e50 */
+   u32 TxPktFifo485_rsv3;
+   u32 TxPktFifo486[3];                 /* 0x00005e60 */
+   u32 TxPktFifo486_rsv3;
+   u32 TxPktFifo487[3];                 /* 0x00005e70 */
+   u32 TxPktFifo487_rsv3;
+   u32 TxPktFifo488[3];                 /* 0x00005e80 */
+   u32 TxPktFifo488_rsv3;
+   u32 TxPktFifo489[3];                 /* 0x00005e90 */
+   u32 TxPktFifo489_rsv3;
+   u32 TxPktFifo490[3];                 /* 0x00005ea0 */
+   u32 TxPktFifo490_rsv3;
+   u32 TxPktFifo491[3];                 /* 0x00005eb0 */
+   u32 TxPktFifo491_rsv3;
+   u32 TxPktFifo492[3];                 /* 0x00005ec0 */
+   u32 TxPktFifo492_rsv3;
+   u32 TxPktFifo493[3];                 /* 0x00005ed0 */
+   u32 TxPktFifo493_rsv3;
+   u32 TxPktFifo494[3];                 /* 0x00005ee0 */
+   u32 TxPktFifo494_rsv3;
+   u32 TxPktFifo495[3];                 /* 0x00005ef0 */
+   u32 TxPktFifo495_rsv3;
+   u32 TxPktFifo496[3];                 /* 0x00005f00 */
+   u32 TxPktFifo496_rsv3;
+   u32 TxPktFifo497[3];                 /* 0x00005f10 */
+   u32 TxPktFifo497_rsv3;
+   u32 TxPktFifo498[3];                 /* 0x00005f20 */
+   u32 TxPktFifo498_rsv3;
+   u32 TxPktFifo499[3];                 /* 0x00005f30 */
+   u32 TxPktFifo499_rsv3;
+   u32 TxPktFifo500[3];                 /* 0x00005f40 */
+   u32 TxPktFifo500_rsv3;
+   u32 TxPktFifo501[3];                 /* 0x00005f50 */
+   u32 TxPktFifo501_rsv3;
+   u32 TxPktFifo502[3];                 /* 0x00005f60 */
+   u32 TxPktFifo502_rsv3;
+   u32 TxPktFifo503[3];                 /* 0x00005f70 */
+   u32 TxPktFifo503_rsv3;
+   u32 TxPktFifo504[3];                 /* 0x00005f80 */
+   u32 TxPktFifo504_rsv3;
+   u32 TxPktFifo505[3];                 /* 0x00005f90 */
+   u32 TxPktFifo505_rsv3;
+   u32 TxPktFifo506[3];                 /* 0x00005fa0 */
+   u32 TxPktFifo506_rsv3;
+   u32 TxPktFifo507[3];                 /* 0x00005fb0 */
+   u32 TxPktFifo507_rsv3;
+   u32 TxPktFifo508[3];                 /* 0x00005fc0 */
+   u32 TxPktFifo508_rsv3;
+   u32 TxPktFifo509[3];                 /* 0x00005fd0 */
+   u32 TxPktFifo509_rsv3;
+   u32 TxPktFifo510[3];                 /* 0x00005fe0 */
+   u32 TxPktFifo510_rsv3;
+   u32 TxPktFifo511[3];                 /* 0x00005ff0 */
+   u32 TxPktFifo511_rsv3;
+   u32 TxPktFifo512[3];                 /* 0x00006000 */
+   u32 TxPktFifo512_rsv3;
+   u32 TxPktFifo513[3];                 /* 0x00006010 */
+   u32 TxPktFifo513_rsv3;
+   u32 TxPktFifo514[3];                 /* 0x00006020 */
+   u32 TxPktFifo514_rsv3;
+   u32 TxPktFifo515[3];                 /* 0x00006030 */
+   u32 TxPktFifo515_rsv3;
+   u32 TxPktFifo516[3];                 /* 0x00006040 */
+   u32 TxPktFifo516_rsv3;
+   u32 TxPktFifo517[3];                 /* 0x00006050 */
+   u32 TxPktFifo517_rsv3;
+   u32 TxPktFifo518[3];                 /* 0x00006060 */
+   u32 TxPktFifo518_rsv3;
+   u32 TxPktFifo519[3];                 /* 0x00006070 */
+   u32 TxPktFifo519_rsv3;
+   u32 TxPktFifo520[3];                 /* 0x00006080 */
+   u32 TxPktFifo520_rsv3;
+   u32 TxPktFifo521[3];                 /* 0x00006090 */
+   u32 TxPktFifo521_rsv3;
+   u32 TxPktFifo522[3];                 /* 0x000060a0 */
+   u32 TxPktFifo522_rsv3;
+   u32 TxPktFifo523[3];                 /* 0x000060b0 */
+   u32 TxPktFifo523_rsv3;
+   u32 TxPktFifo524[3];                 /* 0x000060c0 */
+   u32 TxPktFifo524_rsv3;
+   u32 TxPktFifo525[3];                 /* 0x000060d0 */
+   u32 TxPktFifo525_rsv3;
+   u32 TxPktFifo526[3];                 /* 0x000060e0 */
+   u32 TxPktFifo526_rsv3;
+   u32 TxPktFifo527[3];                 /* 0x000060f0 */
+   u32 TxPktFifo527_rsv3;
+   u32 TxPktFifo528[3];                 /* 0x00006100 */
+   u32 TxPktFifo528_rsv3;
+   u32 TxPktFifo529[3];                 /* 0x00006110 */
+   u32 TxPktFifo529_rsv3;
+   u32 TxPktFifo530[3];                 /* 0x00006120 */
+   u32 TxPktFifo530_rsv3;
+   u32 TxPktFifo531[3];                 /* 0x00006130 */
+   u32 TxPktFifo531_rsv3;
+   u32 TxPktFifo532[3];                 /* 0x00006140 */
+   u32 TxPktFifo532_rsv3;
+   u32 TxPktFifo533[3];                 /* 0x00006150 */
+   u32 TxPktFifo533_rsv3;
+   u32 TxPktFifo534[3];                 /* 0x00006160 */
+   u32 TxPktFifo534_rsv3;
+   u32 TxPktFifo535[3];                 /* 0x00006170 */
+   u32 TxPktFifo535_rsv3;
+   u32 TxPktFifo536[3];                 /* 0x00006180 */
+   u32 TxPktFifo536_rsv3;
+   u32 TxPktFifo537[3];                 /* 0x00006190 */
+   u32 TxPktFifo537_rsv3;
+   u32 TxPktFifo538[3];                 /* 0x000061a0 */
+   u32 TxPktFifo538_rsv3;
+   u32 TxPktFifo539[3];                 /* 0x000061b0 */
+   u32 TxPktFifo539_rsv3;
+   u32 TxPktFifo540[3];                 /* 0x000061c0 */
+   u32 TxPktFifo540_rsv3;
+   u32 TxPktFifo541[3];                 /* 0x000061d0 */
+   u32 TxPktFifo541_rsv3;
+   u32 TxPktFifo542[3];                 /* 0x000061e0 */
+   u32 TxPktFifo542_rsv3;
+   u32 TxPktFifo543[3];                 /* 0x000061f0 */
+   u32 TxPktFifo543_rsv3;
+   u32 TxPktFifo544[3];                 /* 0x00006200 */
+   u32 TxPktFifo544_rsv3;
+   u32 TxPktFifo545[3];                 /* 0x00006210 */
+   u32 TxPktFifo545_rsv3;
+   u32 TxPktFifo546[3];                 /* 0x00006220 */
+   u32 TxPktFifo546_rsv3;
+   u32 TxPktFifo547[3];                 /* 0x00006230 */
+   u32 TxPktFifo547_rsv3;
+   u32 TxPktFifo548[3];                 /* 0x00006240 */
+   u32 TxPktFifo548_rsv3;
+   u32 TxPktFifo549[3];                 /* 0x00006250 */
+   u32 TxPktFifo549_rsv3;
+   u32 TxPktFifo550[3];                 /* 0x00006260 */
+   u32 TxPktFifo550_rsv3;
+   u32 TxPktFifo551[3];                 /* 0x00006270 */
+   u32 TxPktFifo551_rsv3;
+   u32 TxPktFifo552[3];                 /* 0x00006280 */
+   u32 TxPktFifo552_rsv3;
+   u32 TxPktFifo553[3];                 /* 0x00006290 */
+   u32 TxPktFifo553_rsv3;
+   u32 TxPktFifo554[3];                 /* 0x000062a0 */
+   u32 TxPktFifo554_rsv3;
+   u32 TxPktFifo555[3];                 /* 0x000062b0 */
+   u32 TxPktFifo555_rsv3;
+   u32 TxPktFifo556[3];                 /* 0x000062c0 */
+   u32 TxPktFifo556_rsv3;
+   u32 TxPktFifo557[3];                 /* 0x000062d0 */
+   u32 TxPktFifo557_rsv3;
+   u32 TxPktFifo558[3];                 /* 0x000062e0 */
+   u32 TxPktFifo558_rsv3;
+   u32 TxPktFifo559[3];                 /* 0x000062f0 */
+   u32 TxPktFifo559_rsv3;
+   u32 TxPktFifo560[3];                 /* 0x00006300 */
+   u32 TxPktFifo560_rsv3;
+   u32 TxPktFifo561[3];                 /* 0x00006310 */
+   u32 TxPktFifo561_rsv3;
+   u32 TxPktFifo562[3];                 /* 0x00006320 */
+   u32 TxPktFifo562_rsv3;
+   u32 TxPktFifo563[3];                 /* 0x00006330 */
+   u32 TxPktFifo563_rsv3;
+   u32 TxPktFifo564[3];                 /* 0x00006340 */
+   u32 TxPktFifo564_rsv3;
+   u32 TxPktFifo565[3];                 /* 0x00006350 */
+   u32 TxPktFifo565_rsv3;
+   u32 TxPktFifo566[3];                 /* 0x00006360 */
+   u32 TxPktFifo566_rsv3;
+   u32 TxPktFifo567[3];                 /* 0x00006370 */
+   u32 TxPktFifo567_rsv3;
+   u32 TxPktFifo568[3];                 /* 0x00006380 */
+   u32 TxPktFifo568_rsv3;
+   u32 TxPktFifo569[3];                 /* 0x00006390 */
+   u32 TxPktFifo569_rsv3;
+   u32 TxPktFifo570[3];                 /* 0x000063a0 */
+   u32 TxPktFifo570_rsv3;
+   u32 TxPktFifo571[3];                 /* 0x000063b0 */
+   u32 TxPktFifo571_rsv3;
+   u32 TxPktFifo572[3];                 /* 0x000063c0 */
+   u32 TxPktFifo572_rsv3;
+   u32 TxPktFifo573[3];                 /* 0x000063d0 */
+   u32 TxPktFifo573_rsv3;
+   u32 TxPktFifo574[3];                 /* 0x000063e0 */
+   u32 TxPktFifo574_rsv3;
+   u32 TxPktFifo575[3];                 /* 0x000063f0 */
+   u32 TxPktFifo575_rsv3;
+   u32 TxPktFifo576[3];                 /* 0x00006400 */
+   u32 TxPktFifo576_rsv3;
+   u32 TxPktFifo577[3];                 /* 0x00006410 */
+   u32 TxPktFifo577_rsv3;
+   u32 TxPktFifo578[3];                 /* 0x00006420 */
+   u32 TxPktFifo578_rsv3;
+   u32 TxPktFifo579[3];                 /* 0x00006430 */
+   u32 TxPktFifo579_rsv3;
+   u32 TxPktFifo580[3];                 /* 0x00006440 */
+   u32 TxPktFifo580_rsv3;
+   u32 TxPktFifo581[3];                 /* 0x00006450 */
+   u32 TxPktFifo581_rsv3;
+   u32 TxPktFifo582[3];                 /* 0x00006460 */
+   u32 TxPktFifo582_rsv3;
+   u32 TxPktFifo583[3];                 /* 0x00006470 */
+   u32 TxPktFifo583_rsv3;
+   u32 TxPktFifo584[3];                 /* 0x00006480 */
+   u32 TxPktFifo584_rsv3;
+   u32 TxPktFifo585[3];                 /* 0x00006490 */
+   u32 TxPktFifo585_rsv3;
+   u32 TxPktFifo586[3];                 /* 0x000064a0 */
+   u32 TxPktFifo586_rsv3;
+   u32 TxPktFifo587[3];                 /* 0x000064b0 */
+   u32 TxPktFifo587_rsv3;
+   u32 TxPktFifo588[3];                 /* 0x000064c0 */
+   u32 TxPktFifo588_rsv3;
+   u32 TxPktFifo589[3];                 /* 0x000064d0 */
+   u32 TxPktFifo589_rsv3;
+   u32 TxPktFifo590[3];                 /* 0x000064e0 */
+   u32 TxPktFifo590_rsv3;
+   u32 TxPktFifo591[3];                 /* 0x000064f0 */
+   u32 TxPktFifo591_rsv3;
+   u32 TxPktFifo592[3];                 /* 0x00006500 */
+   u32 TxPktFifo592_rsv3;
+   u32 TxPktFifo593[3];                 /* 0x00006510 */
+   u32 TxPktFifo593_rsv3;
+   u32 TxPktFifo594[3];                 /* 0x00006520 */
+   u32 TxPktFifo594_rsv3;
+   u32 TxPktFifo595[3];                 /* 0x00006530 */
+   u32 TxPktFifo595_rsv3;
+   u32 TxPktFifo596[3];                 /* 0x00006540 */
+   u32 TxPktFifo596_rsv3;
+   u32 TxPktFifo597[3];                 /* 0x00006550 */
+   u32 TxPktFifo597_rsv3;
+   u32 TxPktFifo598[3];                 /* 0x00006560 */
+   u32 TxPktFifo598_rsv3;
+   u32 TxPktFifo599[3];                 /* 0x00006570 */
+   u32 TxPktFifo599_rsv3;
+   u32 TxPktFifo600[3];                 /* 0x00006580 */
+   u32 TxPktFifo600_rsv3;
+   u32 TxPktFifo601[3];                 /* 0x00006590 */
+   u32 TxPktFifo601_rsv3;
+   u32 TxPktFifo602[3];                 /* 0x000065a0 */
+   u32 TxPktFifo602_rsv3;
+   u32 TxPktFifo603[3];                 /* 0x000065b0 */
+   u32 TxPktFifo603_rsv3;
+   u32 TxPktFifo604[3];                 /* 0x000065c0 */
+   u32 TxPktFifo604_rsv3;
+   u32 TxPktFifo605[3];                 /* 0x000065d0 */
+   u32 TxPktFifo605_rsv3;
+   u32 TxPktFifo606[3];                 /* 0x000065e0 */
+   u32 TxPktFifo606_rsv3;
+   u32 TxPktFifo607[3];                 /* 0x000065f0 */
+   u32 TxPktFifo607_rsv3;
+   u32 TxPktFifo608[3];                 /* 0x00006600 */
+   u32 TxPktFifo608_rsv3;
+   u32 TxPktFifo609[3];                 /* 0x00006610 */
+   u32 TxPktFifo609_rsv3;
+   u32 TxPktFifo610[3];                 /* 0x00006620 */
+   u32 TxPktFifo610_rsv3;
+   u32 TxPktFifo611[3];                 /* 0x00006630 */
+   u32 TxPktFifo611_rsv3;
+   u32 TxPktFifo612[3];                 /* 0x00006640 */
+   u32 TxPktFifo612_rsv3;
+   u32 TxPktFifo613[3];                 /* 0x00006650 */
+   u32 TxPktFifo613_rsv3;
+   u32 TxPktFifo614[3];                 /* 0x00006660 */
+   u32 TxPktFifo614_rsv3;
+   u32 TxPktFifo615[3];                 /* 0x00006670 */
+   u32 TxPktFifo615_rsv3;
+   u32 TxPktFifo616[3];                 /* 0x00006680 */
+   u32 TxPktFifo616_rsv3;
+   u32 TxPktFifo617[3];                 /* 0x00006690 */
+   u32 TxPktFifo617_rsv3;
+   u32 TxPktFifo618[3];                 /* 0x000066a0 */
+   u32 TxPktFifo618_rsv3;
+   u32 TxPktFifo619[3];                 /* 0x000066b0 */
+   u32 TxPktFifo619_rsv3;
+   u32 TxPktFifo620[3];                 /* 0x000066c0 */
+   u32 TxPktFifo620_rsv3;
+   u32 TxPktFifo621[3];                 /* 0x000066d0 */
+   u32 TxPktFifo621_rsv3;
+   u32 TxPktFifo622[3];                 /* 0x000066e0 */
+   u32 TxPktFifo622_rsv3;
+   u32 TxPktFifo623[3];                 /* 0x000066f0 */
+   u32 TxPktFifo623_rsv3;
+   u32 TxPktFifo624[3];                 /* 0x00006700 */
+   u32 TxPktFifo624_rsv3;
+   u32 TxPktFifo625[3];                 /* 0x00006710 */
+   u32 TxPktFifo625_rsv3;
+   u32 TxPktFifo626[3];                 /* 0x00006720 */
+   u32 TxPktFifo626_rsv3;
+   u32 TxPktFifo627[3];                 /* 0x00006730 */
+   u32 TxPktFifo627_rsv3;
+   u32 TxPktFifo628[3];                 /* 0x00006740 */
+   u32 TxPktFifo628_rsv3;
+   u32 TxPktFifo629[3];                 /* 0x00006750 */
+   u32 TxPktFifo629_rsv3;
+   u32 TxPktFifo630[3];                 /* 0x00006760 */
+   u32 TxPktFifo630_rsv3;
+   u32 TxPktFifo631[3];                 /* 0x00006770 */
+   u32 TxPktFifo631_rsv3;
+   u32 TxPktFifo632[3];                 /* 0x00006780 */
+   u32 TxPktFifo632_rsv3;
+   u32 TxPktFifo633[3];                 /* 0x00006790 */
+   u32 TxPktFifo633_rsv3;
+   u32 TxPktFifo634[3];                 /* 0x000067a0 */
+   u32 TxPktFifo634_rsv3;
+   u32 TxPktFifo635[3];                 /* 0x000067b0 */
+   u32 TxPktFifo635_rsv3;
+   u32 TxPktFifo636[3];                 /* 0x000067c0 */
+   u32 TxPktFifo636_rsv3;
+   u32 TxPktFifo637[3];                 /* 0x000067d0 */
+   u32 TxPktFifo637_rsv3;
+   u32 TxPktFifo638[3];                 /* 0x000067e0 */
+   u32 TxPktFifo638_rsv3;
+   u32 TxPktFifo639[3];                 /* 0x000067f0 */
+   u32 TxPktFifo639_rsv3;
+   u32 rsv6656;
+   u32 rsv6657;
+   u32 rsv6658;
+   u32 rsv6659;
+   u32 rsv6660;
+   u32 rsv6661;
+   u32 rsv6662;
+   u32 rsv6663;
+   u32 rsv6664;
+   u32 rsv6665;
+   u32 rsv6666;
+   u32 rsv6667;
+   u32 rsv6668;
+   u32 rsv6669;
+   u32 rsv6670;
+   u32 rsv6671;
+   u32 rsv6672;
+   u32 rsv6673;
+   u32 rsv6674;
+   u32 rsv6675;
+   u32 rsv6676;
+   u32 rsv6677;
+   u32 rsv6678;
+   u32 rsv6679;
+   u32 rsv6680;
+   u32 rsv6681;
+   u32 rsv6682;
+   u32 rsv6683;
+   u32 rsv6684;
+   u32 rsv6685;
+   u32 rsv6686;
+   u32 rsv6687;
+   u32 rsv6688;
+   u32 rsv6689;
+   u32 rsv6690;
+   u32 rsv6691;
+   u32 rsv6692;
+   u32 rsv6693;
+   u32 rsv6694;
+   u32 rsv6695;
+   u32 rsv6696;
+   u32 rsv6697;
+   u32 rsv6698;
+   u32 rsv6699;
+   u32 rsv6700;
+   u32 rsv6701;
+   u32 rsv6702;
+   u32 rsv6703;
+   u32 rsv6704;
+   u32 rsv6705;
+   u32 rsv6706;
+   u32 rsv6707;
+   u32 rsv6708;
+   u32 rsv6709;
+   u32 rsv6710;
+   u32 rsv6711;
+   u32 rsv6712;
+   u32 rsv6713;
+   u32 rsv6714;
+   u32 rsv6715;
+   u32 rsv6716;
+   u32 rsv6717;
+   u32 rsv6718;
+   u32 rsv6719;
+   u32 rsv6720;
+   u32 rsv6721;
+   u32 rsv6722;
+   u32 rsv6723;
+   u32 rsv6724;
+   u32 rsv6725;
+   u32 rsv6726;
+   u32 rsv6727;
+   u32 rsv6728;
+   u32 rsv6729;
+   u32 rsv6730;
+   u32 rsv6731;
+   u32 rsv6732;
+   u32 rsv6733;
+   u32 rsv6734;
+   u32 rsv6735;
+   u32 rsv6736;
+   u32 rsv6737;
+   u32 rsv6738;
+   u32 rsv6739;
+   u32 rsv6740;
+   u32 rsv6741;
+   u32 rsv6742;
+   u32 rsv6743;
+   u32 rsv6744;
+   u32 rsv6745;
+   u32 rsv6746;
+   u32 rsv6747;
+   u32 rsv6748;
+   u32 rsv6749;
+   u32 rsv6750;
+   u32 rsv6751;
+   u32 rsv6752;
+   u32 rsv6753;
+   u32 rsv6754;
+   u32 rsv6755;
+   u32 rsv6756;
+   u32 rsv6757;
+   u32 rsv6758;
+   u32 rsv6759;
+   u32 rsv6760;
+   u32 rsv6761;
+   u32 rsv6762;
+   u32 rsv6763;
+   u32 rsv6764;
+   u32 rsv6765;
+   u32 rsv6766;
+   u32 rsv6767;
+   u32 rsv6768;
+   u32 rsv6769;
+   u32 rsv6770;
+   u32 rsv6771;
+   u32 rsv6772;
+   u32 rsv6773;
+   u32 rsv6774;
+   u32 rsv6775;
+   u32 rsv6776;
+   u32 rsv6777;
+   u32 rsv6778;
+   u32 rsv6779;
+   u32 rsv6780;
+   u32 rsv6781;
+   u32 rsv6782;
+   u32 rsv6783;
+   u32 rsv6784;
+   u32 rsv6785;
+   u32 rsv6786;
+   u32 rsv6787;
+   u32 rsv6788;
+   u32 rsv6789;
+   u32 rsv6790;
+   u32 rsv6791;
+   u32 rsv6792;
+   u32 rsv6793;
+   u32 rsv6794;
+   u32 rsv6795;
+   u32 rsv6796;
+   u32 rsv6797;
+   u32 rsv6798;
+   u32 rsv6799;
+   u32 rsv6800;
+   u32 rsv6801;
+   u32 rsv6802;
+   u32 rsv6803;
+   u32 rsv6804;
+   u32 rsv6805;
+   u32 rsv6806;
+   u32 rsv6807;
+   u32 rsv6808;
+   u32 rsv6809;
+   u32 rsv6810;
+   u32 rsv6811;
+   u32 rsv6812;
+   u32 rsv6813;
+   u32 rsv6814;
+   u32 rsv6815;
+   u32 rsv6816;
+   u32 rsv6817;
+   u32 rsv6818;
+   u32 rsv6819;
+   u32 rsv6820;
+   u32 rsv6821;
+   u32 rsv6822;
+   u32 rsv6823;
+   u32 rsv6824;
+   u32 rsv6825;
+   u32 rsv6826;
+   u32 rsv6827;
+   u32 rsv6828;
+   u32 rsv6829;
+   u32 rsv6830;
+   u32 rsv6831;
+   u32 rsv6832;
+   u32 rsv6833;
+   u32 rsv6834;
+   u32 rsv6835;
+   u32 rsv6836;
+   u32 rsv6837;
+   u32 rsv6838;
+   u32 rsv6839;
+   u32 rsv6840;
+   u32 rsv6841;
+   u32 rsv6842;
+   u32 rsv6843;
+   u32 rsv6844;
+   u32 rsv6845;
+   u32 rsv6846;
+   u32 rsv6847;
+   u32 rsv6848;
+   u32 rsv6849;
+   u32 rsv6850;
+   u32 rsv6851;
+   u32 rsv6852;
+   u32 rsv6853;
+   u32 rsv6854;
+   u32 rsv6855;
+   u32 rsv6856;
+   u32 rsv6857;
+   u32 rsv6858;
+   u32 rsv6859;
+   u32 rsv6860;
+   u32 rsv6861;
+   u32 rsv6862;
+   u32 rsv6863;
+   u32 rsv6864;
+   u32 rsv6865;
+   u32 rsv6866;
+   u32 rsv6867;
+   u32 rsv6868;
+   u32 rsv6869;
+   u32 rsv6870;
+   u32 rsv6871;
+   u32 rsv6872;
+   u32 rsv6873;
+   u32 rsv6874;
+   u32 rsv6875;
+   u32 rsv6876;
+   u32 rsv6877;
+   u32 rsv6878;
+   u32 rsv6879;
+   u32 rsv6880;
+   u32 rsv6881;
+   u32 rsv6882;
+   u32 rsv6883;
+   u32 rsv6884;
+   u32 rsv6885;
+   u32 rsv6886;
+   u32 rsv6887;
+   u32 rsv6888;
+   u32 rsv6889;
+   u32 rsv6890;
+   u32 rsv6891;
+   u32 rsv6892;
+   u32 rsv6893;
+   u32 rsv6894;
+   u32 rsv6895;
+   u32 rsv6896;
+   u32 rsv6897;
+   u32 rsv6898;
+   u32 rsv6899;
+   u32 rsv6900;
+   u32 rsv6901;
+   u32 rsv6902;
+   u32 rsv6903;
+   u32 rsv6904;
+   u32 rsv6905;
+   u32 rsv6906;
+   u32 rsv6907;
+   u32 rsv6908;
+   u32 rsv6909;
+   u32 rsv6910;
+   u32 rsv6911;
+   u32 rsv6912;
+   u32 rsv6913;
+   u32 rsv6914;
+   u32 rsv6915;
+   u32 rsv6916;
+   u32 rsv6917;
+   u32 rsv6918;
+   u32 rsv6919;
+   u32 rsv6920;
+   u32 rsv6921;
+   u32 rsv6922;
+   u32 rsv6923;
+   u32 rsv6924;
+   u32 rsv6925;
+   u32 rsv6926;
+   u32 rsv6927;
+   u32 rsv6928;
+   u32 rsv6929;
+   u32 rsv6930;
+   u32 rsv6931;
+   u32 rsv6932;
+   u32 rsv6933;
+   u32 rsv6934;
+   u32 rsv6935;
+   u32 rsv6936;
+   u32 rsv6937;
+   u32 rsv6938;
+   u32 rsv6939;
+   u32 rsv6940;
+   u32 rsv6941;
+   u32 rsv6942;
+   u32 rsv6943;
+   u32 rsv6944;
+   u32 rsv6945;
+   u32 rsv6946;
+   u32 rsv6947;
+   u32 rsv6948;
+   u32 rsv6949;
+   u32 rsv6950;
+   u32 rsv6951;
+   u32 rsv6952;
+   u32 rsv6953;
+   u32 rsv6954;
+   u32 rsv6955;
+   u32 rsv6956;
+   u32 rsv6957;
+   u32 rsv6958;
+   u32 rsv6959;
+   u32 rsv6960;
+   u32 rsv6961;
+   u32 rsv6962;
+   u32 rsv6963;
+   u32 rsv6964;
+   u32 rsv6965;
+   u32 rsv6966;
+   u32 rsv6967;
+   u32 rsv6968;
+   u32 rsv6969;
+   u32 rsv6970;
+   u32 rsv6971;
+   u32 rsv6972;
+   u32 rsv6973;
+   u32 rsv6974;
+   u32 rsv6975;
+   u32 rsv6976;
+   u32 rsv6977;
+   u32 rsv6978;
+   u32 rsv6979;
+   u32 rsv6980;
+   u32 rsv6981;
+   u32 rsv6982;
+   u32 rsv6983;
+   u32 rsv6984;
+   u32 rsv6985;
+   u32 rsv6986;
+   u32 rsv6987;
+   u32 rsv6988;
+   u32 rsv6989;
+   u32 rsv6990;
+   u32 rsv6991;
+   u32 rsv6992;
+   u32 rsv6993;
+   u32 rsv6994;
+   u32 rsv6995;
+   u32 rsv6996;
+   u32 rsv6997;
+   u32 rsv6998;
+   u32 rsv6999;
+   u32 rsv7000;
+   u32 rsv7001;
+   u32 rsv7002;
+   u32 rsv7003;
+   u32 rsv7004;
+   u32 rsv7005;
+   u32 rsv7006;
+   u32 rsv7007;
+   u32 rsv7008;
+   u32 rsv7009;
+   u32 rsv7010;
+   u32 rsv7011;
+   u32 rsv7012;
+   u32 rsv7013;
+   u32 rsv7014;
+   u32 rsv7015;
+   u32 rsv7016;
+   u32 rsv7017;
+   u32 rsv7018;
+   u32 rsv7019;
+   u32 rsv7020;
+   u32 rsv7021;
+   u32 rsv7022;
+   u32 rsv7023;
+   u32 rsv7024;
+   u32 rsv7025;
+   u32 rsv7026;
+   u32 rsv7027;
+   u32 rsv7028;
+   u32 rsv7029;
+   u32 rsv7030;
+   u32 rsv7031;
+   u32 rsv7032;
+   u32 rsv7033;
+   u32 rsv7034;
+   u32 rsv7035;
+   u32 rsv7036;
+   u32 rsv7037;
+   u32 rsv7038;
+   u32 rsv7039;
+   u32 rsv7040;
+   u32 rsv7041;
+   u32 rsv7042;
+   u32 rsv7043;
+   u32 rsv7044;
+   u32 rsv7045;
+   u32 rsv7046;
+   u32 rsv7047;
+   u32 rsv7048;
+   u32 rsv7049;
+   u32 rsv7050;
+   u32 rsv7051;
+   u32 rsv7052;
+   u32 rsv7053;
+   u32 rsv7054;
+   u32 rsv7055;
+   u32 rsv7056;
+   u32 rsv7057;
+   u32 rsv7058;
+   u32 rsv7059;
+   u32 rsv7060;
+   u32 rsv7061;
+   u32 rsv7062;
+   u32 rsv7063;
+   u32 rsv7064;
+   u32 rsv7065;
+   u32 rsv7066;
+   u32 rsv7067;
+   u32 rsv7068;
+   u32 rsv7069;
+   u32 rsv7070;
+   u32 rsv7071;
+   u32 rsv7072;
+   u32 rsv7073;
+   u32 rsv7074;
+   u32 rsv7075;
+   u32 rsv7076;
+   u32 rsv7077;
+   u32 rsv7078;
+   u32 rsv7079;
+   u32 rsv7080;
+   u32 rsv7081;
+   u32 rsv7082;
+   u32 rsv7083;
+   u32 rsv7084;
+   u32 rsv7085;
+   u32 rsv7086;
+   u32 rsv7087;
+   u32 rsv7088;
+   u32 rsv7089;
+   u32 rsv7090;
+   u32 rsv7091;
+   u32 rsv7092;
+   u32 rsv7093;
+   u32 rsv7094;
+   u32 rsv7095;
+   u32 rsv7096;
+   u32 rsv7097;
+   u32 rsv7098;
+   u32 rsv7099;
+   u32 rsv7100;
+   u32 rsv7101;
+   u32 rsv7102;
+   u32 rsv7103;
+   u32 rsv7104;
+   u32 rsv7105;
+   u32 rsv7106;
+   u32 rsv7107;
+   u32 rsv7108;
+   u32 rsv7109;
+   u32 rsv7110;
+   u32 rsv7111;
+   u32 rsv7112;
+   u32 rsv7113;
+   u32 rsv7114;
+   u32 rsv7115;
+   u32 rsv7116;
+   u32 rsv7117;
+   u32 rsv7118;
+   u32 rsv7119;
+   u32 rsv7120;
+   u32 rsv7121;
+   u32 rsv7122;
+   u32 rsv7123;
+   u32 rsv7124;
+   u32 rsv7125;
+   u32 rsv7126;
+   u32 rsv7127;
+   u32 rsv7128;
+   u32 rsv7129;
+   u32 rsv7130;
+   u32 rsv7131;
+   u32 rsv7132;
+   u32 rsv7133;
+   u32 rsv7134;
+   u32 rsv7135;
+   u32 rsv7136;
+   u32 rsv7137;
+   u32 rsv7138;
+   u32 rsv7139;
+   u32 rsv7140;
+   u32 rsv7141;
+   u32 rsv7142;
+   u32 rsv7143;
+   u32 rsv7144;
+   u32 rsv7145;
+   u32 rsv7146;
+   u32 rsv7147;
+   u32 rsv7148;
+   u32 rsv7149;
+   u32 rsv7150;
+   u32 rsv7151;
+   u32 rsv7152;
+   u32 rsv7153;
+   u32 rsv7154;
+   u32 rsv7155;
+   u32 rsv7156;
+   u32 rsv7157;
+   u32 rsv7158;
+   u32 rsv7159;
+   u32 rsv7160;
+   u32 rsv7161;
+   u32 rsv7162;
+   u32 rsv7163;
+   u32 rsv7164;
+   u32 rsv7165;
+   u32 rsv7166;
+   u32 rsv7167;
+   u32 rsv7168;
+   u32 rsv7169;
+   u32 rsv7170;
+   u32 rsv7171;
+   u32 rsv7172;
+   u32 rsv7173;
+   u32 rsv7174;
+   u32 rsv7175;
+   u32 rsv7176;
+   u32 rsv7177;
+   u32 rsv7178;
+   u32 rsv7179;
+   u32 rsv7180;
+   u32 rsv7181;
+   u32 rsv7182;
+   u32 rsv7183;
+   u32 rsv7184;
+   u32 rsv7185;
+   u32 rsv7186;
+   u32 rsv7187;
+   u32 rsv7188;
+   u32 rsv7189;
+   u32 rsv7190;
+   u32 rsv7191;
+   u32 rsv7192;
+   u32 rsv7193;
+   u32 rsv7194;
+   u32 rsv7195;
+   u32 rsv7196;
+   u32 rsv7197;
+   u32 rsv7198;
+   u32 rsv7199;
+   u32 rsv7200;
+   u32 rsv7201;
+   u32 rsv7202;
+   u32 rsv7203;
+   u32 rsv7204;
+   u32 rsv7205;
+   u32 rsv7206;
+   u32 rsv7207;
+   u32 rsv7208;
+   u32 rsv7209;
+   u32 rsv7210;
+   u32 rsv7211;
+   u32 rsv7212;
+   u32 rsv7213;
+   u32 rsv7214;
+   u32 rsv7215;
+   u32 rsv7216;
+   u32 rsv7217;
+   u32 rsv7218;
+   u32 rsv7219;
+   u32 rsv7220;
+   u32 rsv7221;
+   u32 rsv7222;
+   u32 rsv7223;
+   u32 rsv7224;
+   u32 rsv7225;
+   u32 rsv7226;
+   u32 rsv7227;
+   u32 rsv7228;
+   u32 rsv7229;
+   u32 rsv7230;
+   u32 rsv7231;
+   u32 rsv7232;
+   u32 rsv7233;
+   u32 rsv7234;
+   u32 rsv7235;
+   u32 rsv7236;
+   u32 rsv7237;
+   u32 rsv7238;
+   u32 rsv7239;
+   u32 rsv7240;
+   u32 rsv7241;
+   u32 rsv7242;
+   u32 rsv7243;
+   u32 rsv7244;
+   u32 rsv7245;
+   u32 rsv7246;
+   u32 rsv7247;
+   u32 rsv7248;
+   u32 rsv7249;
+   u32 rsv7250;
+   u32 rsv7251;
+   u32 rsv7252;
+   u32 rsv7253;
+   u32 rsv7254;
+   u32 rsv7255;
+   u32 rsv7256;
+   u32 rsv7257;
+   u32 rsv7258;
+   u32 rsv7259;
+   u32 rsv7260;
+   u32 rsv7261;
+   u32 rsv7262;
+   u32 rsv7263;
+   u32 rsv7264;
+   u32 rsv7265;
+   u32 rsv7266;
+   u32 rsv7267;
+   u32 rsv7268;
+   u32 rsv7269;
+   u32 rsv7270;
+   u32 rsv7271;
+   u32 rsv7272;
+   u32 rsv7273;
+   u32 rsv7274;
+   u32 rsv7275;
+   u32 rsv7276;
+   u32 rsv7277;
+   u32 rsv7278;
+   u32 rsv7279;
+   u32 rsv7280;
+   u32 rsv7281;
+   u32 rsv7282;
+   u32 rsv7283;
+   u32 rsv7284;
+   u32 rsv7285;
+   u32 rsv7286;
+   u32 rsv7287;
+   u32 rsv7288;
+   u32 rsv7289;
+   u32 rsv7290;
+   u32 rsv7291;
+   u32 rsv7292;
+   u32 rsv7293;
+   u32 rsv7294;
+   u32 rsv7295;
+   u32 rsv7296;
+   u32 rsv7297;
+   u32 rsv7298;
+   u32 rsv7299;
+   u32 rsv7300;
+   u32 rsv7301;
+   u32 rsv7302;
+   u32 rsv7303;
+   u32 rsv7304;
+   u32 rsv7305;
+   u32 rsv7306;
+   u32 rsv7307;
+   u32 rsv7308;
+   u32 rsv7309;
+   u32 rsv7310;
+   u32 rsv7311;
+   u32 rsv7312;
+   u32 rsv7313;
+   u32 rsv7314;
+   u32 rsv7315;
+   u32 rsv7316;
+   u32 rsv7317;
+   u32 rsv7318;
+   u32 rsv7319;
+   u32 rsv7320;
+   u32 rsv7321;
+   u32 rsv7322;
+   u32 rsv7323;
+   u32 rsv7324;
+   u32 rsv7325;
+   u32 rsv7326;
+   u32 rsv7327;
+   u32 rsv7328;
+   u32 rsv7329;
+   u32 rsv7330;
+   u32 rsv7331;
+   u32 rsv7332;
+   u32 rsv7333;
+   u32 rsv7334;
+   u32 rsv7335;
+   u32 rsv7336;
+   u32 rsv7337;
+   u32 rsv7338;
+   u32 rsv7339;
+   u32 rsv7340;
+   u32 rsv7341;
+   u32 rsv7342;
+   u32 rsv7343;
+   u32 rsv7344;
+   u32 rsv7345;
+   u32 rsv7346;
+   u32 rsv7347;
+   u32 rsv7348;
+   u32 rsv7349;
+   u32 rsv7350;
+   u32 rsv7351;
+   u32 rsv7352;
+   u32 rsv7353;
+   u32 rsv7354;
+   u32 rsv7355;
+   u32 rsv7356;
+   u32 rsv7357;
+   u32 rsv7358;
+   u32 rsv7359;
+   u32 rsv7360;
+   u32 rsv7361;
+   u32 rsv7362;
+   u32 rsv7363;
+   u32 rsv7364;
+   u32 rsv7365;
+   u32 rsv7366;
+   u32 rsv7367;
+   u32 rsv7368;
+   u32 rsv7369;
+   u32 rsv7370;
+   u32 rsv7371;
+   u32 rsv7372;
+   u32 rsv7373;
+   u32 rsv7374;
+   u32 rsv7375;
+   u32 rsv7376;
+   u32 rsv7377;
+   u32 rsv7378;
+   u32 rsv7379;
+   u32 rsv7380;
+   u32 rsv7381;
+   u32 rsv7382;
+   u32 rsv7383;
+   u32 rsv7384;
+   u32 rsv7385;
+   u32 rsv7386;
+   u32 rsv7387;
+   u32 rsv7388;
+   u32 rsv7389;
+   u32 rsv7390;
+   u32 rsv7391;
+   u32 rsv7392;
+   u32 rsv7393;
+   u32 rsv7394;
+   u32 rsv7395;
+   u32 rsv7396;
+   u32 rsv7397;
+   u32 rsv7398;
+   u32 rsv7399;
+   u32 rsv7400;
+   u32 rsv7401;
+   u32 rsv7402;
+   u32 rsv7403;
+   u32 rsv7404;
+   u32 rsv7405;
+   u32 rsv7406;
+   u32 rsv7407;
+   u32 rsv7408;
+   u32 rsv7409;
+   u32 rsv7410;
+   u32 rsv7411;
+   u32 rsv7412;
+   u32 rsv7413;
+   u32 rsv7414;
+   u32 rsv7415;
+   u32 rsv7416;
+   u32 rsv7417;
+   u32 rsv7418;
+   u32 rsv7419;
+   u32 rsv7420;
+   u32 rsv7421;
+   u32 rsv7422;
+   u32 rsv7423;
+   u32 rsv7424;
+   u32 rsv7425;
+   u32 rsv7426;
+   u32 rsv7427;
+   u32 rsv7428;
+   u32 rsv7429;
+   u32 rsv7430;
+   u32 rsv7431;
+   u32 rsv7432;
+   u32 rsv7433;
+   u32 rsv7434;
+   u32 rsv7435;
+   u32 rsv7436;
+   u32 rsv7437;
+   u32 rsv7438;
+   u32 rsv7439;
+   u32 rsv7440;
+   u32 rsv7441;
+   u32 rsv7442;
+   u32 rsv7443;
+   u32 rsv7444;
+   u32 rsv7445;
+   u32 rsv7446;
+   u32 rsv7447;
+   u32 rsv7448;
+   u32 rsv7449;
+   u32 rsv7450;
+   u32 rsv7451;
+   u32 rsv7452;
+   u32 rsv7453;
+   u32 rsv7454;
+   u32 rsv7455;
+   u32 rsv7456;
+   u32 rsv7457;
+   u32 rsv7458;
+   u32 rsv7459;
+   u32 rsv7460;
+   u32 rsv7461;
+   u32 rsv7462;
+   u32 rsv7463;
+   u32 rsv7464;
+   u32 rsv7465;
+   u32 rsv7466;
+   u32 rsv7467;
+   u32 rsv7468;
+   u32 rsv7469;
+   u32 rsv7470;
+   u32 rsv7471;
+   u32 rsv7472;
+   u32 rsv7473;
+   u32 rsv7474;
+   u32 rsv7475;
+   u32 rsv7476;
+   u32 rsv7477;
+   u32 rsv7478;
+   u32 rsv7479;
+   u32 rsv7480;
+   u32 rsv7481;
+   u32 rsv7482;
+   u32 rsv7483;
+   u32 rsv7484;
+   u32 rsv7485;
+   u32 rsv7486;
+   u32 rsv7487;
+   u32 rsv7488;
+   u32 rsv7489;
+   u32 rsv7490;
+   u32 rsv7491;
+   u32 rsv7492;
+   u32 rsv7493;
+   u32 rsv7494;
+   u32 rsv7495;
+   u32 rsv7496;
+   u32 rsv7497;
+   u32 rsv7498;
+   u32 rsv7499;
+   u32 rsv7500;
+   u32 rsv7501;
+   u32 rsv7502;
+   u32 rsv7503;
+   u32 rsv7504;
+   u32 rsv7505;
+   u32 rsv7506;
+   u32 rsv7507;
+   u32 rsv7508;
+   u32 rsv7509;
+   u32 rsv7510;
+   u32 rsv7511;
+   u32 rsv7512;
+   u32 rsv7513;
+   u32 rsv7514;
+   u32 rsv7515;
+   u32 rsv7516;
+   u32 rsv7517;
+   u32 rsv7518;
+   u32 rsv7519;
+   u32 rsv7520;
+   u32 rsv7521;
+   u32 rsv7522;
+   u32 rsv7523;
+   u32 rsv7524;
+   u32 rsv7525;
+   u32 rsv7526;
+   u32 rsv7527;
+   u32 rsv7528;
+   u32 rsv7529;
+   u32 rsv7530;
+   u32 rsv7531;
+   u32 rsv7532;
+   u32 rsv7533;
+   u32 rsv7534;
+   u32 rsv7535;
+   u32 rsv7536;
+   u32 rsv7537;
+   u32 rsv7538;
+   u32 rsv7539;
+   u32 rsv7540;
+   u32 rsv7541;
+   u32 rsv7542;
+   u32 rsv7543;
+   u32 rsv7544;
+   u32 rsv7545;
+   u32 rsv7546;
+   u32 rsv7547;
+   u32 rsv7548;
+   u32 rsv7549;
+   u32 rsv7550;
+   u32 rsv7551;
+   u32 rsv7552;
+   u32 rsv7553;
+   u32 rsv7554;
+   u32 rsv7555;
+   u32 rsv7556;
+   u32 rsv7557;
+   u32 rsv7558;
+   u32 rsv7559;
+   u32 rsv7560;
+   u32 rsv7561;
+   u32 rsv7562;
+   u32 rsv7563;
+   u32 rsv7564;
+   u32 rsv7565;
+   u32 rsv7566;
+   u32 rsv7567;
+   u32 rsv7568;
+   u32 rsv7569;
+   u32 rsv7570;
+   u32 rsv7571;
+   u32 rsv7572;
+   u32 rsv7573;
+   u32 rsv7574;
+   u32 rsv7575;
+   u32 rsv7576;
+   u32 rsv7577;
+   u32 rsv7578;
+   u32 rsv7579;
+   u32 rsv7580;
+   u32 rsv7581;
+   u32 rsv7582;
+   u32 rsv7583;
+   u32 rsv7584;
+   u32 rsv7585;
+   u32 rsv7586;
+   u32 rsv7587;
+   u32 rsv7588;
+   u32 rsv7589;
+   u32 rsv7590;
+   u32 rsv7591;
+   u32 rsv7592;
+   u32 rsv7593;
+   u32 rsv7594;
+   u32 rsv7595;
+   u32 rsv7596;
+   u32 rsv7597;
+   u32 rsv7598;
+   u32 rsv7599;
+   u32 rsv7600;
+   u32 rsv7601;
+   u32 rsv7602;
+   u32 rsv7603;
+   u32 rsv7604;
+   u32 rsv7605;
+   u32 rsv7606;
+   u32 rsv7607;
+   u32 rsv7608;
+   u32 rsv7609;
+   u32 rsv7610;
+   u32 rsv7611;
+   u32 rsv7612;
+   u32 rsv7613;
+   u32 rsv7614;
+   u32 rsv7615;
+   u32 rsv7616;
+   u32 rsv7617;
+   u32 rsv7618;
+   u32 rsv7619;
+   u32 rsv7620;
+   u32 rsv7621;
+   u32 rsv7622;
+   u32 rsv7623;
+   u32 rsv7624;
+   u32 rsv7625;
+   u32 rsv7626;
+   u32 rsv7627;
+   u32 rsv7628;
+   u32 rsv7629;
+   u32 rsv7630;
+   u32 rsv7631;
+   u32 rsv7632;
+   u32 rsv7633;
+   u32 rsv7634;
+   u32 rsv7635;
+   u32 rsv7636;
+   u32 rsv7637;
+   u32 rsv7638;
+   u32 rsv7639;
+   u32 rsv7640;
+   u32 rsv7641;
+   u32 rsv7642;
+   u32 rsv7643;
+   u32 rsv7644;
+   u32 rsv7645;
+   u32 rsv7646;
+   u32 rsv7647;
+   u32 rsv7648;
+   u32 rsv7649;
+   u32 rsv7650;
+   u32 rsv7651;
+   u32 rsv7652;
+   u32 rsv7653;
+   u32 rsv7654;
+   u32 rsv7655;
+   u32 rsv7656;
+   u32 rsv7657;
+   u32 rsv7658;
+   u32 rsv7659;
+   u32 rsv7660;
+   u32 rsv7661;
+   u32 rsv7662;
+   u32 rsv7663;
+   u32 rsv7664;
+   u32 rsv7665;
+   u32 rsv7666;
+   u32 rsv7667;
+   u32 rsv7668;
+   u32 rsv7669;
+   u32 rsv7670;
+   u32 rsv7671;
+   u32 rsv7672;
+   u32 rsv7673;
+   u32 rsv7674;
+   u32 rsv7675;
+   u32 rsv7676;
+   u32 rsv7677;
+   u32 rsv7678;
+   u32 rsv7679;
+   u32 rsv7680;
+   u32 rsv7681;
+   u32 rsv7682;
+   u32 rsv7683;
+   u32 rsv7684;
+   u32 rsv7685;
+   u32 rsv7686;
+   u32 rsv7687;
+   u32 rsv7688;
+   u32 rsv7689;
+   u32 rsv7690;
+   u32 rsv7691;
+   u32 rsv7692;
+   u32 rsv7693;
+   u32 rsv7694;
+   u32 rsv7695;
+   u32 rsv7696;
+   u32 rsv7697;
+   u32 rsv7698;
+   u32 rsv7699;
+   u32 rsv7700;
+   u32 rsv7701;
+   u32 rsv7702;
+   u32 rsv7703;
+   u32 rsv7704;
+   u32 rsv7705;
+   u32 rsv7706;
+   u32 rsv7707;
+   u32 rsv7708;
+   u32 rsv7709;
+   u32 rsv7710;
+   u32 rsv7711;
+   u32 rsv7712;
+   u32 rsv7713;
+   u32 rsv7714;
+   u32 rsv7715;
+   u32 rsv7716;
+   u32 rsv7717;
+   u32 rsv7718;
+   u32 rsv7719;
+   u32 rsv7720;
+   u32 rsv7721;
+   u32 rsv7722;
+   u32 rsv7723;
+   u32 rsv7724;
+   u32 rsv7725;
+   u32 rsv7726;
+   u32 rsv7727;
+   u32 rsv7728;
+   u32 rsv7729;
+   u32 rsv7730;
+   u32 rsv7731;
+   u32 rsv7732;
+   u32 rsv7733;
+   u32 rsv7734;
+   u32 rsv7735;
+   u32 rsv7736;
+   u32 rsv7737;
+   u32 rsv7738;
+   u32 rsv7739;
+   u32 rsv7740;
+   u32 rsv7741;
+   u32 rsv7742;
+   u32 rsv7743;
+   u32 rsv7744;
+   u32 rsv7745;
+   u32 rsv7746;
+   u32 rsv7747;
+   u32 rsv7748;
+   u32 rsv7749;
+   u32 rsv7750;
+   u32 rsv7751;
+   u32 rsv7752;
+   u32 rsv7753;
+   u32 rsv7754;
+   u32 rsv7755;
+   u32 rsv7756;
+   u32 rsv7757;
+   u32 rsv7758;
+   u32 rsv7759;
+   u32 rsv7760;
+   u32 rsv7761;
+   u32 rsv7762;
+   u32 rsv7763;
+   u32 rsv7764;
+   u32 rsv7765;
+   u32 rsv7766;
+   u32 rsv7767;
+   u32 rsv7768;
+   u32 rsv7769;
+   u32 rsv7770;
+   u32 rsv7771;
+   u32 rsv7772;
+   u32 rsv7773;
+   u32 rsv7774;
+   u32 rsv7775;
+   u32 rsv7776;
+   u32 rsv7777;
+   u32 rsv7778;
+   u32 rsv7779;
+   u32 rsv7780;
+   u32 rsv7781;
+   u32 rsv7782;
+   u32 rsv7783;
+   u32 rsv7784;
+   u32 rsv7785;
+   u32 rsv7786;
+   u32 rsv7787;
+   u32 rsv7788;
+   u32 rsv7789;
+   u32 rsv7790;
+   u32 rsv7791;
+   u32 rsv7792;
+   u32 rsv7793;
+   u32 rsv7794;
+   u32 rsv7795;
+   u32 rsv7796;
+   u32 rsv7797;
+   u32 rsv7798;
+   u32 rsv7799;
+   u32 rsv7800;
+   u32 rsv7801;
+   u32 rsv7802;
+   u32 rsv7803;
+   u32 rsv7804;
+   u32 rsv7805;
+   u32 rsv7806;
+   u32 rsv7807;
+   u32 rsv7808;
+   u32 rsv7809;
+   u32 rsv7810;
+   u32 rsv7811;
+   u32 rsv7812;
+   u32 rsv7813;
+   u32 rsv7814;
+   u32 rsv7815;
+   u32 rsv7816;
+   u32 rsv7817;
+   u32 rsv7818;
+   u32 rsv7819;
+   u32 rsv7820;
+   u32 rsv7821;
+   u32 rsv7822;
+   u32 rsv7823;
+   u32 rsv7824;
+   u32 rsv7825;
+   u32 rsv7826;
+   u32 rsv7827;
+   u32 rsv7828;
+   u32 rsv7829;
+   u32 rsv7830;
+   u32 rsv7831;
+   u32 rsv7832;
+   u32 rsv7833;
+   u32 rsv7834;
+   u32 rsv7835;
+   u32 rsv7836;
+   u32 rsv7837;
+   u32 rsv7838;
+   u32 rsv7839;
+   u32 rsv7840;
+   u32 rsv7841;
+   u32 rsv7842;
+   u32 rsv7843;
+   u32 rsv7844;
+   u32 rsv7845;
+   u32 rsv7846;
+   u32 rsv7847;
+   u32 rsv7848;
+   u32 rsv7849;
+   u32 rsv7850;
+   u32 rsv7851;
+   u32 rsv7852;
+   u32 rsv7853;
+   u32 rsv7854;
+   u32 rsv7855;
+   u32 rsv7856;
+   u32 rsv7857;
+   u32 rsv7858;
+   u32 rsv7859;
+   u32 rsv7860;
+   u32 rsv7861;
+   u32 rsv7862;
+   u32 rsv7863;
+   u32 rsv7864;
+   u32 rsv7865;
+   u32 rsv7866;
+   u32 rsv7867;
+   u32 rsv7868;
+   u32 rsv7869;
+   u32 rsv7870;
+   u32 rsv7871;
+   u32 rsv7872;
+   u32 rsv7873;
+   u32 rsv7874;
+   u32 rsv7875;
+   u32 rsv7876;
+   u32 rsv7877;
+   u32 rsv7878;
+   u32 rsv7879;
+   u32 rsv7880;
+   u32 rsv7881;
+   u32 rsv7882;
+   u32 rsv7883;
+   u32 rsv7884;
+   u32 rsv7885;
+   u32 rsv7886;
+   u32 rsv7887;
+   u32 rsv7888;
+   u32 rsv7889;
+   u32 rsv7890;
+   u32 rsv7891;
+   u32 rsv7892;
+   u32 rsv7893;
+   u32 rsv7894;
+   u32 rsv7895;
+   u32 rsv7896;
+   u32 rsv7897;
+   u32 rsv7898;
+   u32 rsv7899;
+   u32 rsv7900;
+   u32 rsv7901;
+   u32 rsv7902;
+   u32 rsv7903;
+   u32 rsv7904;
+   u32 rsv7905;
+   u32 rsv7906;
+   u32 rsv7907;
+   u32 rsv7908;
+   u32 rsv7909;
+   u32 rsv7910;
+   u32 rsv7911;
+   u32 rsv7912;
+   u32 rsv7913;
+   u32 rsv7914;
+   u32 rsv7915;
+   u32 rsv7916;
+   u32 rsv7917;
+   u32 rsv7918;
+   u32 rsv7919;
+   u32 rsv7920;
+   u32 rsv7921;
+   u32 rsv7922;
+   u32 rsv7923;
+   u32 rsv7924;
+   u32 rsv7925;
+   u32 rsv7926;
+   u32 rsv7927;
+   u32 rsv7928;
+   u32 rsv7929;
+   u32 rsv7930;
+   u32 rsv7931;
+   u32 rsv7932;
+   u32 rsv7933;
+   u32 rsv7934;
+   u32 rsv7935;
+   u32 rsv7936;
+   u32 rsv7937;
+   u32 rsv7938;
+   u32 rsv7939;
+   u32 rsv7940;
+   u32 rsv7941;
+   u32 rsv7942;
+   u32 rsv7943;
+   u32 rsv7944;
+   u32 rsv7945;
+   u32 rsv7946;
+   u32 rsv7947;
+   u32 rsv7948;
+   u32 rsv7949;
+   u32 rsv7950;
+   u32 rsv7951;
+   u32 rsv7952;
+   u32 rsv7953;
+   u32 rsv7954;
+   u32 rsv7955;
+   u32 rsv7956;
+   u32 rsv7957;
+   u32 rsv7958;
+   u32 rsv7959;
+   u32 rsv7960;
+   u32 rsv7961;
+   u32 rsv7962;
+   u32 rsv7963;
+   u32 rsv7964;
+   u32 rsv7965;
+   u32 rsv7966;
+   u32 rsv7967;
+   u32 rsv7968;
+   u32 rsv7969;
+   u32 rsv7970;
+   u32 rsv7971;
+   u32 rsv7972;
+   u32 rsv7973;
+   u32 rsv7974;
+   u32 rsv7975;
+   u32 rsv7976;
+   u32 rsv7977;
+   u32 rsv7978;
+   u32 rsv7979;
+   u32 rsv7980;
+   u32 rsv7981;
+   u32 rsv7982;
+   u32 rsv7983;
+   u32 rsv7984;
+   u32 rsv7985;
+   u32 rsv7986;
+   u32 rsv7987;
+   u32 rsv7988;
+   u32 rsv7989;
+   u32 rsv7990;
+   u32 rsv7991;
+   u32 rsv7992;
+   u32 rsv7993;
+   u32 rsv7994;
+   u32 rsv7995;
+   u32 rsv7996;
+   u32 rsv7997;
+   u32 rsv7998;
+   u32 rsv7999;
+   u32 rsv8000;
+   u32 rsv8001;
+   u32 rsv8002;
+   u32 rsv8003;
+   u32 rsv8004;
+   u32 rsv8005;
+   u32 rsv8006;
+   u32 rsv8007;
+   u32 rsv8008;
+   u32 rsv8009;
+   u32 rsv8010;
+   u32 rsv8011;
+   u32 rsv8012;
+   u32 rsv8013;
+   u32 rsv8014;
+   u32 rsv8015;
+   u32 rsv8016;
+   u32 rsv8017;
+   u32 rsv8018;
+   u32 rsv8019;
+   u32 rsv8020;
+   u32 rsv8021;
+   u32 rsv8022;
+   u32 rsv8023;
+   u32 rsv8024;
+   u32 rsv8025;
+   u32 rsv8026;
+   u32 rsv8027;
+   u32 rsv8028;
+   u32 rsv8029;
+   u32 rsv8030;
+   u32 rsv8031;
+   u32 rsv8032;
+   u32 rsv8033;
+   u32 rsv8034;
+   u32 rsv8035;
+   u32 rsv8036;
+   u32 rsv8037;
+   u32 rsv8038;
+   u32 rsv8039;
+   u32 rsv8040;
+   u32 rsv8041;
+   u32 rsv8042;
+   u32 rsv8043;
+   u32 rsv8044;
+   u32 rsv8045;
+   u32 rsv8046;
+   u32 rsv8047;
+   u32 rsv8048;
+   u32 rsv8049;
+   u32 rsv8050;
+   u32 rsv8051;
+   u32 rsv8052;
+   u32 rsv8053;
+   u32 rsv8054;
+   u32 rsv8055;
+   u32 rsv8056;
+   u32 rsv8057;
+   u32 rsv8058;
+   u32 rsv8059;
+   u32 rsv8060;
+   u32 rsv8061;
+   u32 rsv8062;
+   u32 rsv8063;
+   u32 rsv8064;
+   u32 rsv8065;
+   u32 rsv8066;
+   u32 rsv8067;
+   u32 rsv8068;
+   u32 rsv8069;
+   u32 rsv8070;
+   u32 rsv8071;
+   u32 rsv8072;
+   u32 rsv8073;
+   u32 rsv8074;
+   u32 rsv8075;
+   u32 rsv8076;
+   u32 rsv8077;
+   u32 rsv8078;
+   u32 rsv8079;
+   u32 rsv8080;
+   u32 rsv8081;
+   u32 rsv8082;
+   u32 rsv8083;
+   u32 rsv8084;
+   u32 rsv8085;
+   u32 rsv8086;
+   u32 rsv8087;
+   u32 rsv8088;
+   u32 rsv8089;
+   u32 rsv8090;
+   u32 rsv8091;
+   u32 rsv8092;
+   u32 rsv8093;
+   u32 rsv8094;
+   u32 rsv8095;
+   u32 rsv8096;
+   u32 rsv8097;
+   u32 rsv8098;
+   u32 rsv8099;
+   u32 rsv8100;
+   u32 rsv8101;
+   u32 rsv8102;
+   u32 rsv8103;
+   u32 rsv8104;
+   u32 rsv8105;
+   u32 rsv8106;
+   u32 rsv8107;
+   u32 rsv8108;
+   u32 rsv8109;
+   u32 rsv8110;
+   u32 rsv8111;
+   u32 rsv8112;
+   u32 rsv8113;
+   u32 rsv8114;
+   u32 rsv8115;
+   u32 rsv8116;
+   u32 rsv8117;
+   u32 rsv8118;
+   u32 rsv8119;
+   u32 rsv8120;
+   u32 rsv8121;
+   u32 rsv8122;
+   u32 rsv8123;
+   u32 rsv8124;
+   u32 rsv8125;
+   u32 rsv8126;
+   u32 rsv8127;
+   u32 rsv8128;
+   u32 rsv8129;
+   u32 rsv8130;
+   u32 rsv8131;
+   u32 rsv8132;
+   u32 rsv8133;
+   u32 rsv8134;
+   u32 rsv8135;
+   u32 rsv8136;
+   u32 rsv8137;
+   u32 rsv8138;
+   u32 rsv8139;
+   u32 rsv8140;
+   u32 rsv8141;
+   u32 rsv8142;
+   u32 rsv8143;
+   u32 rsv8144;
+   u32 rsv8145;
+   u32 rsv8146;
+   u32 rsv8147;
+   u32 rsv8148;
+   u32 rsv8149;
+   u32 rsv8150;
+   u32 rsv8151;
+   u32 rsv8152;
+   u32 rsv8153;
+   u32 rsv8154;
+   u32 rsv8155;
+   u32 rsv8156;
+   u32 rsv8157;
+   u32 rsv8158;
+   u32 rsv8159;
+   u32 rsv8160;
+   u32 rsv8161;
+   u32 rsv8162;
+   u32 rsv8163;
+   u32 rsv8164;
+   u32 rsv8165;
+   u32 rsv8166;
+   u32 rsv8167;
+   u32 rsv8168;
+   u32 rsv8169;
+   u32 rsv8170;
+   u32 rsv8171;
+   u32 rsv8172;
+   u32 rsv8173;
+   u32 rsv8174;
+   u32 rsv8175;
+   u32 rsv8176;
+   u32 rsv8177;
+   u32 rsv8178;
+   u32 rsv8179;
+   u32 rsv8180;
+   u32 rsv8181;
+   u32 rsv8182;
+   u32 rsv8183;
+   u32 rsv8184;
+   u32 rsv8185;
+   u32 rsv8186;
+   u32 rsv8187;
+   u32 rsv8188;
+   u32 rsv8189;
+   u32 rsv8190;
+   u32 rsv8191;
+   u32 RxPktMsgFifo0[1];                /* 0x00008000 */
+   u32 RxPktMsgFifo1[1];                /* 0x00008004 */
+   u32 RxPktMsgFifo2[1];                /* 0x00008008 */
+   u32 RxPktMsgFifo3[1];                /* 0x0000800c */
+   u32 RxPktMsgFifo4[1];                /* 0x00008010 */
+   u32 RxPktMsgFifo5[1];                /* 0x00008014 */
+   u32 RxPktMsgFifo6[1];                /* 0x00008018 */
+   u32 RxPktMsgFifo7[1];                /* 0x0000801c */
+   u32 RxPktMsgFifo8[1];                /* 0x00008020 */
+   u32 RxPktMsgFifo9[1];                /* 0x00008024 */
+   u32 RxPktMsgFifo10[1];               /* 0x00008028 */
+   u32 RxPktMsgFifo11[1];               /* 0x0000802c */
+   u32 RxPktMsgFifo12[1];               /* 0x00008030 */
+   u32 RxPktMsgFifo13[1];               /* 0x00008034 */
+   u32 RxPktMsgFifo14[1];               /* 0x00008038 */
+   u32 RxPktMsgFifo15[1];               /* 0x0000803c */
+   u32 RxPktMsgFifo16[1];               /* 0x00008040 */
+   u32 RxPktMsgFifo17[1];               /* 0x00008044 */
+   u32 RxPktMsgFifo18[1];               /* 0x00008048 */
+   u32 RxPktMsgFifo19[1];               /* 0x0000804c */
+   u32 RxPktMsgFifo20[1];               /* 0x00008050 */
+   u32 RxPktMsgFifo21[1];               /* 0x00008054 */
+   u32 RxPktMsgFifo22[1];               /* 0x00008058 */
+   u32 RxPktMsgFifo23[1];               /* 0x0000805c */
+   u32 RxPktMsgFifo24[1];               /* 0x00008060 */
+   u32 RxPktMsgFifo25[1];               /* 0x00008064 */
+   u32 RxPktMsgFifo26[1];               /* 0x00008068 */
+   u32 RxPktMsgFifo27[1];               /* 0x0000806c */
+   u32 RxPktMsgFifo28[1];               /* 0x00008070 */
+   u32 RxPktMsgFifo29[1];               /* 0x00008074 */
+   u32 RxPktMsgFifo30[1];               /* 0x00008078 */
+   u32 RxPktMsgFifo31[1];               /* 0x0000807c */
+   u32 RxPktMsgFifo32[1];               /* 0x00008080 */
+   u32 RxPktMsgFifo33[1];               /* 0x00008084 */
+   u32 RxPktMsgFifo34[1];               /* 0x00008088 */
+   u32 RxPktMsgFifo35[1];               /* 0x0000808c */
+   u32 RxPktMsgFifo36[1];               /* 0x00008090 */
+   u32 RxPktMsgFifo37[1];               /* 0x00008094 */
+   u32 RxPktMsgFifo38[1];               /* 0x00008098 */
+   u32 RxPktMsgFifo39[1];               /* 0x0000809c */
+   u32 RxPktMsgFifo40[1];               /* 0x000080a0 */
+   u32 RxPktMsgFifo41[1];               /* 0x000080a4 */
+   u32 RxPktMsgFifo42[1];               /* 0x000080a8 */
+   u32 RxPktMsgFifo43[1];               /* 0x000080ac */
+   u32 RxPktMsgFifo44[1];               /* 0x000080b0 */
+   u32 RxPktMsgFifo45[1];               /* 0x000080b4 */
+   u32 RxPktMsgFifo46[1];               /* 0x000080b8 */
+   u32 RxPktMsgFifo47[1];               /* 0x000080bc */
+   u32 RxPktMsgFifo48[1];               /* 0x000080c0 */
+   u32 RxPktMsgFifo49[1];               /* 0x000080c4 */
+   u32 RxPktMsgFifo50[1];               /* 0x000080c8 */
+   u32 RxPktMsgFifo51[1];               /* 0x000080cc */
+   u32 RxPktMsgFifo52[1];               /* 0x000080d0 */
+   u32 RxPktMsgFifo53[1];               /* 0x000080d4 */
+   u32 RxPktMsgFifo54[1];               /* 0x000080d8 */
+   u32 RxPktMsgFifo55[1];               /* 0x000080dc */
+   u32 RxPktMsgFifo56[1];               /* 0x000080e0 */
+   u32 RxPktMsgFifo57[1];               /* 0x000080e4 */
+   u32 RxPktMsgFifo58[1];               /* 0x000080e8 */
+   u32 RxPktMsgFifo59[1];               /* 0x000080ec */
+   u32 RxPktMsgFifo60[1];               /* 0x000080f0 */
+   u32 RxPktMsgFifo61[1];               /* 0x000080f4 */
+   u32 RxPktMsgFifo62[1];               /* 0x000080f8 */
+   u32 RxPktMsgFifo63[1];               /* 0x000080fc */
+   u32 RxPktMsgFifo64[1];               /* 0x00008100 */
+   u32 RxPktMsgFifo65[1];               /* 0x00008104 */
+   u32 RxPktMsgFifo66[1];               /* 0x00008108 */
+   u32 RxPktMsgFifo67[1];               /* 0x0000810c */
+   u32 RxPktMsgFifo68[1];               /* 0x00008110 */
+   u32 RxPktMsgFifo69[1];               /* 0x00008114 */
+   u32 RxPktMsgFifo70[1];               /* 0x00008118 */
+   u32 RxPktMsgFifo71[1];               /* 0x0000811c */
+   u32 RxPktMsgFifo72[1];               /* 0x00008120 */
+   u32 RxPktMsgFifo73[1];               /* 0x00008124 */
+   u32 RxPktMsgFifo74[1];               /* 0x00008128 */
+   u32 RxPktMsgFifo75[1];               /* 0x0000812c */
+   u32 RxPktMsgFifo76[1];               /* 0x00008130 */
+   u32 RxPktMsgFifo77[1];               /* 0x00008134 */
+   u32 RxPktMsgFifo78[1];               /* 0x00008138 */
+   u32 RxPktMsgFifo79[1];               /* 0x0000813c */
+   u32 RxPktMsgFifo80[1];               /* 0x00008140 */
+   u32 RxPktMsgFifo81[1];               /* 0x00008144 */
+   u32 RxPktMsgFifo82[1];               /* 0x00008148 */
+   u32 RxPktMsgFifo83[1];               /* 0x0000814c */
+   u32 RxPktMsgFifo84[1];               /* 0x00008150 */
+   u32 RxPktMsgFifo85[1];               /* 0x00008154 */
+   u32 RxPktMsgFifo86[1];               /* 0x00008158 */
+   u32 RxPktMsgFifo87[1];               /* 0x0000815c */
+   u32 RxPktMsgFifo88[1];               /* 0x00008160 */
+   u32 RxPktMsgFifo89[1];               /* 0x00008164 */
+   u32 RxPktMsgFifo90[1];               /* 0x00008168 */
+   u32 RxPktMsgFifo91[1];               /* 0x0000816c */
+   u32 RxPktMsgFifo92[1];               /* 0x00008170 */
+   u32 RxPktMsgFifo93[1];               /* 0x00008174 */
+   u32 RxPktMsgFifo94[1];               /* 0x00008178 */
+   u32 RxPktMsgFifo95[1];               /* 0x0000817c */
+   u32 RxPktMsgFifo96[1];               /* 0x00008180 */
+   u32 RxPktMsgFifo97[1];               /* 0x00008184 */
+   u32 RxPktMsgFifo98[1];               /* 0x00008188 */
+   u32 RxPktMsgFifo99[1];               /* 0x0000818c */
+   u32 RxPktMsgFifo100[1];              /* 0x00008190 */
+   u32 RxPktMsgFifo101[1];              /* 0x00008194 */
+   u32 RxPktMsgFifo102[1];              /* 0x00008198 */
+   u32 RxPktMsgFifo103[1];              /* 0x0000819c */
+   u32 RxPktMsgFifo104[1];              /* 0x000081a0 */
+   u32 RxPktMsgFifo105[1];              /* 0x000081a4 */
+   u32 RxPktMsgFifo106[1];              /* 0x000081a8 */
+   u32 RxPktMsgFifo107[1];              /* 0x000081ac */
+   u32 RxPktMsgFifo108[1];              /* 0x000081b0 */
+   u32 RxPktMsgFifo109[1];              /* 0x000081b4 */
+   u32 RxPktMsgFifo110[1];              /* 0x000081b8 */
+   u32 RxPktMsgFifo111[1];              /* 0x000081bc */
+   u32 RxPktMsgFifo112[1];              /* 0x000081c0 */
+   u32 RxPktMsgFifo113[1];              /* 0x000081c4 */
+   u32 RxPktMsgFifo114[1];              /* 0x000081c8 */
+   u32 RxPktMsgFifo115[1];              /* 0x000081cc */
+   u32 RxPktMsgFifo116[1];              /* 0x000081d0 */
+   u32 RxPktMsgFifo117[1];              /* 0x000081d4 */
+   u32 RxPktMsgFifo118[1];              /* 0x000081d8 */
+   u32 RxPktMsgFifo119[1];              /* 0x000081dc */
+   u32 RxPktMsgFifo120[1];              /* 0x000081e0 */
+   u32 RxPktMsgFifo121[1];              /* 0x000081e4 */
+   u32 RxPktMsgFifo122[1];              /* 0x000081e8 */
+   u32 RxPktMsgFifo123[1];              /* 0x000081ec */
+   u32 RxPktMsgFifo124[1];              /* 0x000081f0 */
+   u32 RxPktMsgFifo125[1];              /* 0x000081f4 */
+   u32 RxPktMsgFifo126[1];              /* 0x000081f8 */
+   u32 RxPktMsgFifo127[1];              /* 0x000081fc */
+   u32 RxPktMsgFifo128[1];              /* 0x00008200 */
+   u32 RxPktMsgFifo129[1];              /* 0x00008204 */
+   u32 RxPktMsgFifo130[1];              /* 0x00008208 */
+   u32 RxPktMsgFifo131[1];              /* 0x0000820c */
+   u32 RxPktMsgFifo132[1];              /* 0x00008210 */
+   u32 RxPktMsgFifo133[1];              /* 0x00008214 */
+   u32 RxPktMsgFifo134[1];              /* 0x00008218 */
+   u32 RxPktMsgFifo135[1];              /* 0x0000821c */
+   u32 RxPktMsgFifo136[1];              /* 0x00008220 */
+   u32 RxPktMsgFifo137[1];              /* 0x00008224 */
+   u32 RxPktMsgFifo138[1];              /* 0x00008228 */
+   u32 RxPktMsgFifo139[1];              /* 0x0000822c */
+   u32 RxPktMsgFifo140[1];              /* 0x00008230 */
+   u32 RxPktMsgFifo141[1];              /* 0x00008234 */
+   u32 RxPktMsgFifo142[1];              /* 0x00008238 */
+   u32 RxPktMsgFifo143[1];              /* 0x0000823c */
+   u32 RxPktMsgFifo144[1];              /* 0x00008240 */
+   u32 RxPktMsgFifo145[1];              /* 0x00008244 */
+   u32 RxPktMsgFifo146[1];              /* 0x00008248 */
+   u32 RxPktMsgFifo147[1];              /* 0x0000824c */
+   u32 RxPktMsgFifo148[1];              /* 0x00008250 */
+   u32 RxPktMsgFifo149[1];              /* 0x00008254 */
+   u32 RxPktMsgFifo150[1];              /* 0x00008258 */
+   u32 RxPktMsgFifo151[1];              /* 0x0000825c */
+   u32 RxPktMsgFifo152[1];              /* 0x00008260 */
+   u32 RxPktMsgFifo153[1];              /* 0x00008264 */
+   u32 RxPktMsgFifo154[1];              /* 0x00008268 */
+   u32 RxPktMsgFifo155[1];              /* 0x0000826c */
+   u32 RxPktMsgFifo156[1];              /* 0x00008270 */
+   u32 RxPktMsgFifo157[1];              /* 0x00008274 */
+   u32 RxPktMsgFifo158[1];              /* 0x00008278 */
+   u32 RxPktMsgFifo159[1];              /* 0x0000827c */
+   u32 RxPktMsgFifo160[1];              /* 0x00008280 */
+   u32 RxPktMsgFifo161[1];              /* 0x00008284 */
+   u32 RxPktMsgFifo162[1];              /* 0x00008288 */
+   u32 RxPktMsgFifo163[1];              /* 0x0000828c */
+   u32 RxPktMsgFifo164[1];              /* 0x00008290 */
+   u32 RxPktMsgFifo165[1];              /* 0x00008294 */
+   u32 RxPktMsgFifo166[1];              /* 0x00008298 */
+   u32 RxPktMsgFifo167[1];              /* 0x0000829c */
+   u32 RxPktMsgFifo168[1];              /* 0x000082a0 */
+   u32 RxPktMsgFifo169[1];              /* 0x000082a4 */
+   u32 RxPktMsgFifo170[1];              /* 0x000082a8 */
+   u32 RxPktMsgFifo171[1];              /* 0x000082ac */
+   u32 RxPktMsgFifo172[1];              /* 0x000082b0 */
+   u32 RxPktMsgFifo173[1];              /* 0x000082b4 */
+   u32 RxPktMsgFifo174[1];              /* 0x000082b8 */
+   u32 RxPktMsgFifo175[1];              /* 0x000082bc */
+   u32 RxPktMsgFifo176[1];              /* 0x000082c0 */
+   u32 RxPktMsgFifo177[1];              /* 0x000082c4 */
+   u32 RxPktMsgFifo178[1];              /* 0x000082c8 */
+   u32 RxPktMsgFifo179[1];              /* 0x000082cc */
+   u32 RxPktMsgFifo180[1];              /* 0x000082d0 */
+   u32 RxPktMsgFifo181[1];              /* 0x000082d4 */
+   u32 RxPktMsgFifo182[1];              /* 0x000082d8 */
+   u32 RxPktMsgFifo183[1];              /* 0x000082dc */
+   u32 RxPktMsgFifo184[1];              /* 0x000082e0 */
+   u32 RxPktMsgFifo185[1];              /* 0x000082e4 */
+   u32 RxPktMsgFifo186[1];              /* 0x000082e8 */
+   u32 RxPktMsgFifo187[1];              /* 0x000082ec */
+   u32 RxPktMsgFifo188[1];              /* 0x000082f0 */
+   u32 RxPktMsgFifo189[1];              /* 0x000082f4 */
+   u32 RxPktMsgFifo190[1];              /* 0x000082f8 */
+   u32 RxPktMsgFifo191[1];              /* 0x000082fc */
+   u32 RxPktMsgFifo192[1];              /* 0x00008300 */
+   u32 RxPktMsgFifo193[1];              /* 0x00008304 */
+   u32 RxPktMsgFifo194[1];              /* 0x00008308 */
+   u32 RxPktMsgFifo195[1];              /* 0x0000830c */
+   u32 RxPktMsgFifo196[1];              /* 0x00008310 */
+   u32 RxPktMsgFifo197[1];              /* 0x00008314 */
+   u32 RxPktMsgFifo198[1];              /* 0x00008318 */
+   u32 RxPktMsgFifo199[1];              /* 0x0000831c */
+   u32 RxPktMsgFifo200[1];              /* 0x00008320 */
+   u32 RxPktMsgFifo201[1];              /* 0x00008324 */
+   u32 RxPktMsgFifo202[1];              /* 0x00008328 */
+   u32 RxPktMsgFifo203[1];              /* 0x0000832c */
+   u32 RxPktMsgFifo204[1];              /* 0x00008330 */
+   u32 RxPktMsgFifo205[1];              /* 0x00008334 */
+   u32 RxPktMsgFifo206[1];              /* 0x00008338 */
+   u32 RxPktMsgFifo207[1];              /* 0x0000833c */
+   u32 RxPktMsgFifo208[1];              /* 0x00008340 */
+   u32 RxPktMsgFifo209[1];              /* 0x00008344 */
+   u32 RxPktMsgFifo210[1];              /* 0x00008348 */
+   u32 RxPktMsgFifo211[1];              /* 0x0000834c */
+   u32 RxPktMsgFifo212[1];              /* 0x00008350 */
+   u32 RxPktMsgFifo213[1];              /* 0x00008354 */
+   u32 RxPktMsgFifo214[1];              /* 0x00008358 */
+   u32 RxPktMsgFifo215[1];              /* 0x0000835c */
+   u32 RxPktMsgFifo216[1];              /* 0x00008360 */
+   u32 RxPktMsgFifo217[1];              /* 0x00008364 */
+   u32 RxPktMsgFifo218[1];              /* 0x00008368 */
+   u32 RxPktMsgFifo219[1];              /* 0x0000836c */
+   u32 RxPktMsgFifo220[1];              /* 0x00008370 */
+   u32 RxPktMsgFifo221[1];              /* 0x00008374 */
+   u32 RxPktMsgFifo222[1];              /* 0x00008378 */
+   u32 RxPktMsgFifo223[1];              /* 0x0000837c */
+   u32 RxPktMsgFifo224[1];              /* 0x00008380 */
+   u32 RxPktMsgFifo225[1];              /* 0x00008384 */
+   u32 RxPktMsgFifo226[1];              /* 0x00008388 */
+   u32 RxPktMsgFifo227[1];              /* 0x0000838c */
+   u32 RxPktMsgFifo228[1];              /* 0x00008390 */
+   u32 RxPktMsgFifo229[1];              /* 0x00008394 */
+   u32 RxPktMsgFifo230[1];              /* 0x00008398 */
+   u32 RxPktMsgFifo231[1];              /* 0x0000839c */
+   u32 RxPktMsgFifo232[1];              /* 0x000083a0 */
+   u32 RxPktMsgFifo233[1];              /* 0x000083a4 */
+   u32 RxPktMsgFifo234[1];              /* 0x000083a8 */
+   u32 RxPktMsgFifo235[1];              /* 0x000083ac */
+   u32 RxPktMsgFifo236[1];              /* 0x000083b0 */
+   u32 RxPktMsgFifo237[1];              /* 0x000083b4 */
+   u32 RxPktMsgFifo238[1];              /* 0x000083b8 */
+   u32 RxPktMsgFifo239[1];              /* 0x000083bc */
+   u32 RxPktMsgFifo240[1];              /* 0x000083c0 */
+   u32 RxPktMsgFifo241[1];              /* 0x000083c4 */
+   u32 RxPktMsgFifo242[1];              /* 0x000083c8 */
+   u32 RxPktMsgFifo243[1];              /* 0x000083cc */
+   u32 RxPktMsgFifo244[1];              /* 0x000083d0 */
+   u32 RxPktMsgFifo245[1];              /* 0x000083d4 */
+   u32 RxPktMsgFifo246[1];              /* 0x000083d8 */
+   u32 RxPktMsgFifo247[1];              /* 0x000083dc */
+   u32 RxPktMsgFifo248[1];              /* 0x000083e0 */
+   u32 RxPktMsgFifo249[1];              /* 0x000083e4 */
+   u32 RxPktMsgFifo250[1];              /* 0x000083e8 */
+   u32 RxPktMsgFifo251[1];              /* 0x000083ec */
+   u32 RxPktMsgFifo252[1];              /* 0x000083f0 */
+   u32 RxPktMsgFifo253[1];              /* 0x000083f4 */
+   u32 RxPktMsgFifo254[1];              /* 0x000083f8 */
+   u32 RxPktMsgFifo255[1];              /* 0x000083fc */
+   u32 RxPktMsgFifo256[1];              /* 0x00008400 */
+   u32 RxPktMsgFifo257[1];              /* 0x00008404 */
+   u32 RxPktMsgFifo258[1];              /* 0x00008408 */
+   u32 RxPktMsgFifo259[1];              /* 0x0000840c */
+   u32 RxPktMsgFifo260[1];              /* 0x00008410 */
+   u32 RxPktMsgFifo261[1];              /* 0x00008414 */
+   u32 RxPktMsgFifo262[1];              /* 0x00008418 */
+   u32 RxPktMsgFifo263[1];              /* 0x0000841c */
+   u32 RxPktMsgFifo264[1];              /* 0x00008420 */
+   u32 RxPktMsgFifo265[1];              /* 0x00008424 */
+   u32 RxPktMsgFifo266[1];              /* 0x00008428 */
+   u32 RxPktMsgFifo267[1];              /* 0x0000842c */
+   u32 RxPktMsgFifo268[1];              /* 0x00008430 */
+   u32 RxPktMsgFifo269[1];              /* 0x00008434 */
+   u32 RxPktMsgFifo270[1];              /* 0x00008438 */
+   u32 RxPktMsgFifo271[1];              /* 0x0000843c */
+   u32 RxPktMsgFifo272[1];              /* 0x00008440 */
+   u32 RxPktMsgFifo273[1];              /* 0x00008444 */
+   u32 RxPktMsgFifo274[1];              /* 0x00008448 */
+   u32 RxPktMsgFifo275[1];              /* 0x0000844c */
+   u32 RxPktMsgFifo276[1];              /* 0x00008450 */
+   u32 RxPktMsgFifo277[1];              /* 0x00008454 */
+   u32 RxPktMsgFifo278[1];              /* 0x00008458 */
+   u32 RxPktMsgFifo279[1];              /* 0x0000845c */
+   u32 RxPktMsgFifo280[1];              /* 0x00008460 */
+   u32 RxPktMsgFifo281[1];              /* 0x00008464 */
+   u32 RxPktMsgFifo282[1];              /* 0x00008468 */
+   u32 RxPktMsgFifo283[1];              /* 0x0000846c */
+   u32 RxPktMsgFifo284[1];              /* 0x00008470 */
+   u32 RxPktMsgFifo285[1];              /* 0x00008474 */
+   u32 RxPktMsgFifo286[1];              /* 0x00008478 */
+   u32 RxPktMsgFifo287[1];              /* 0x0000847c */
+   u32 RxPktMsgFifo288[1];              /* 0x00008480 */
+   u32 RxPktMsgFifo289[1];              /* 0x00008484 */
+   u32 RxPktMsgFifo290[1];              /* 0x00008488 */
+   u32 RxPktMsgFifo291[1];              /* 0x0000848c */
+   u32 RxPktMsgFifo292[1];              /* 0x00008490 */
+   u32 RxPktMsgFifo293[1];              /* 0x00008494 */
+   u32 RxPktMsgFifo294[1];              /* 0x00008498 */
+   u32 RxPktMsgFifo295[1];              /* 0x0000849c */
+   u32 RxPktMsgFifo296[1];              /* 0x000084a0 */
+   u32 RxPktMsgFifo297[1];              /* 0x000084a4 */
+   u32 RxPktMsgFifo298[1];              /* 0x000084a8 */
+   u32 RxPktMsgFifo299[1];              /* 0x000084ac */
+   u32 RxPktMsgFifo300[1];              /* 0x000084b0 */
+   u32 RxPktMsgFifo301[1];              /* 0x000084b4 */
+   u32 RxPktMsgFifo302[1];              /* 0x000084b8 */
+   u32 RxPktMsgFifo303[1];              /* 0x000084bc */
+   u32 RxPktMsgFifo304[1];              /* 0x000084c0 */
+   u32 RxPktMsgFifo305[1];              /* 0x000084c4 */
+   u32 RxPktMsgFifo306[1];              /* 0x000084c8 */
+   u32 RxPktMsgFifo307[1];              /* 0x000084cc */
+   u32 RxPktMsgFifo308[1];              /* 0x000084d0 */
+   u32 RxPktMsgFifo309[1];              /* 0x000084d4 */
+   u32 RxPktMsgFifo310[1];              /* 0x000084d8 */
+   u32 RxPktMsgFifo311[1];              /* 0x000084dc */
+   u32 RxPktMsgFifo312[1];              /* 0x000084e0 */
+   u32 RxPktMsgFifo313[1];              /* 0x000084e4 */
+   u32 RxPktMsgFifo314[1];              /* 0x000084e8 */
+   u32 RxPktMsgFifo315[1];              /* 0x000084ec */
+   u32 RxPktMsgFifo316[1];              /* 0x000084f0 */
+   u32 RxPktMsgFifo317[1];              /* 0x000084f4 */
+   u32 RxPktMsgFifo318[1];              /* 0x000084f8 */
+   u32 RxPktMsgFifo319[1];              /* 0x000084fc */
+   u32 RxPktMsgFifo320[1];              /* 0x00008500 */
+   u32 RxPktMsgFifo321[1];              /* 0x00008504 */
+   u32 RxPktMsgFifo322[1];              /* 0x00008508 */
+   u32 RxPktMsgFifo323[1];              /* 0x0000850c */
+   u32 RxPktMsgFifo324[1];              /* 0x00008510 */
+   u32 rsv8517;
+   u32 rsv8518;
+   u32 rsv8519;
+   u32 rsv8520;
+   u32 rsv8521;
+   u32 rsv8522;
+   u32 rsv8523;
+   u32 rsv8524;
+   u32 rsv8525;
+   u32 rsv8526;
+   u32 rsv8527;
+   u32 rsv8528;
+   u32 rsv8529;
+   u32 rsv8530;
+   u32 rsv8531;
+   u32 rsv8532;
+   u32 rsv8533;
+   u32 rsv8534;
+   u32 rsv8535;
+   u32 rsv8536;
+   u32 rsv8537;
+   u32 rsv8538;
+   u32 rsv8539;
+   u32 rsv8540;
+   u32 rsv8541;
+   u32 rsv8542;
+   u32 rsv8543;
+   u32 rsv8544;
+   u32 rsv8545;
+   u32 rsv8546;
+   u32 rsv8547;
+   u32 rsv8548;
+   u32 rsv8549;
+   u32 rsv8550;
+   u32 rsv8551;
+   u32 rsv8552;
+   u32 rsv8553;
+   u32 rsv8554;
+   u32 rsv8555;
+   u32 rsv8556;
+   u32 rsv8557;
+   u32 rsv8558;
+   u32 rsv8559;
+   u32 rsv8560;
+   u32 rsv8561;
+   u32 rsv8562;
+   u32 rsv8563;
+   u32 rsv8564;
+   u32 rsv8565;
+   u32 rsv8566;
+   u32 rsv8567;
+   u32 rsv8568;
+   u32 rsv8569;
+   u32 rsv8570;
+   u32 rsv8571;
+   u32 rsv8572;
+   u32 rsv8573;
+   u32 rsv8574;
+   u32 rsv8575;
+   u32 rsv8576;
+   u32 rsv8577;
+   u32 rsv8578;
+   u32 rsv8579;
+   u32 rsv8580;
+   u32 rsv8581;
+   u32 rsv8582;
+   u32 rsv8583;
+   u32 rsv8584;
+   u32 rsv8585;
+   u32 rsv8586;
+   u32 rsv8587;
+   u32 rsv8588;
+   u32 rsv8589;
+   u32 rsv8590;
+   u32 rsv8591;
+   u32 rsv8592;
+   u32 rsv8593;
+   u32 rsv8594;
+   u32 rsv8595;
+   u32 rsv8596;
+   u32 rsv8597;
+   u32 rsv8598;
+   u32 rsv8599;
+   u32 rsv8600;
+   u32 rsv8601;
+   u32 rsv8602;
+   u32 rsv8603;
+   u32 rsv8604;
+   u32 rsv8605;
+   u32 rsv8606;
+   u32 rsv8607;
+   u32 rsv8608;
+   u32 rsv8609;
+   u32 rsv8610;
+   u32 rsv8611;
+   u32 rsv8612;
+   u32 rsv8613;
+   u32 rsv8614;
+   u32 rsv8615;
+   u32 rsv8616;
+   u32 rsv8617;
+   u32 rsv8618;
+   u32 rsv8619;
+   u32 rsv8620;
+   u32 rsv8621;
+   u32 rsv8622;
+   u32 rsv8623;
+   u32 rsv8624;
+   u32 rsv8625;
+   u32 rsv8626;
+   u32 rsv8627;
+   u32 rsv8628;
+   u32 rsv8629;
+   u32 rsv8630;
+   u32 rsv8631;
+   u32 rsv8632;
+   u32 rsv8633;
+   u32 rsv8634;
+   u32 rsv8635;
+   u32 rsv8636;
+   u32 rsv8637;
+   u32 rsv8638;
+   u32 rsv8639;
+   u32 rsv8640;
+   u32 rsv8641;
+   u32 rsv8642;
+   u32 rsv8643;
+   u32 rsv8644;
+   u32 rsv8645;
+   u32 rsv8646;
+   u32 rsv8647;
+   u32 rsv8648;
+   u32 rsv8649;
+   u32 rsv8650;
+   u32 rsv8651;
+   u32 rsv8652;
+   u32 rsv8653;
+   u32 rsv8654;
+   u32 rsv8655;
+   u32 rsv8656;
+   u32 rsv8657;
+   u32 rsv8658;
+   u32 rsv8659;
+   u32 rsv8660;
+   u32 rsv8661;
+   u32 rsv8662;
+   u32 rsv8663;
+   u32 rsv8664;
+   u32 rsv8665;
+   u32 rsv8666;
+   u32 rsv8667;
+   u32 rsv8668;
+   u32 rsv8669;
+   u32 rsv8670;
+   u32 rsv8671;
+   u32 rsv8672;
+   u32 rsv8673;
+   u32 rsv8674;
+   u32 rsv8675;
+   u32 rsv8676;
+   u32 rsv8677;
+   u32 rsv8678;
+   u32 rsv8679;
+   u32 rsv8680;
+   u32 rsv8681;
+   u32 rsv8682;
+   u32 rsv8683;
+   u32 rsv8684;
+   u32 rsv8685;
+   u32 rsv8686;
+   u32 rsv8687;
+   u32 rsv8688;
+   u32 rsv8689;
+   u32 rsv8690;
+   u32 rsv8691;
+   u32 rsv8692;
+   u32 rsv8693;
+   u32 rsv8694;
+   u32 rsv8695;
+   u32 rsv8696;
+   u32 rsv8697;
+   u32 rsv8698;
+   u32 rsv8699;
+   u32 rsv8700;
+   u32 rsv8701;
+   u32 rsv8702;
+   u32 rsv8703;
+   u32 CpuMacStatsRam0[4];              /* 0x00008800 */
+   u32 CpuMacStatsRam1[4];              /* 0x00008810 */
+   u32 CpuMacStatsRam2[4];              /* 0x00008820 */
+   u32 CpuMacStatsRam3[4];              /* 0x00008830 */
+   u32 CpuMacStatsRam4[4];              /* 0x00008840 */
+   u32 CpuMacStatsRam5[4];              /* 0x00008850 */
+   u32 CpuMacStatsRam6[4];              /* 0x00008860 */
+   u32 CpuMacStatsRam7[4];              /* 0x00008870 */
+   u32 CpuMacStatsRam8[4];              /* 0x00008880 */
+   u32 CpuMacStatsRam9[4];              /* 0x00008890 */
+   u32 CpuMacStatsRam10[4];             /* 0x000088a0 */
+   u32 CpuMacStatsRam11[4];             /* 0x000088b0 */
+   u32 CpuMacStatsRam12[4];             /* 0x000088c0 */
+   u32 CpuMacStatsRam13[4];             /* 0x000088d0 */
+   u32 CpuMacStatsRam14[4];             /* 0x000088e0 */
+   u32 CpuMacStatsRam15[4];             /* 0x000088f0 */
+   u32 CpuMacStatsRam16[4];             /* 0x00008900 */
+   u32 CpuMacStatsRam17[4];             /* 0x00008910 */
+   u32 CpuMacStatsRam18[4];             /* 0x00008920 */
+   u32 CpuMacStatsRam19[4];             /* 0x00008930 */
+   u32 CpuMacStatsRam20[4];             /* 0x00008940 */
+   u32 CpuMacStatsRam21[4];             /* 0x00008950 */
+   u32 CpuMacStatsRam22[4];             /* 0x00008960 */
+   u32 CpuMacStatsRam23[4];             /* 0x00008970 */
+   u32 CpuMacStatsRam24[4];             /* 0x00008980 */
+   u32 CpuMacStatsRam25[4];             /* 0x00008990 */
+   u32 CpuMacStatsRam26[4];             /* 0x000089a0 */
+   u32 CpuMacStatsRam27[4];             /* 0x000089b0 */
+   u32 CpuMacStatsRam28[4];             /* 0x000089c0 */
+   u32 CpuMacStatsRam29[4];             /* 0x000089d0 */
+   u32 CpuMacStatsRam30[4];             /* 0x000089e0 */
+   u32 CpuMacStatsRam31[4];             /* 0x000089f0 */
+   u32 CpuMacStatsRam32[4];             /* 0x00008a00 */
+   u32 CpuMacStatsRam33[4];             /* 0x00008a10 */
+   u32 CpuMacStatsRam34[4];             /* 0x00008a20 */
+   u32 CpuMacStatsRam35[4];             /* 0x00008a30 */
+   u32 CpuMacStatsRam36[4];             /* 0x00008a40 */
+   u32 CpuMacStatsRam37[4];             /* 0x00008a50 */
+   u32 CpuMacStatsRam38[4];             /* 0x00008a60 */
+   u32 CpuMacStatsRam39[4];             /* 0x00008a70 */
+   u32 rsv8864;
+   u32 rsv8865;
+   u32 rsv8866;
+   u32 rsv8867;
+   u32 rsv8868;
+   u32 rsv8869;
+   u32 rsv8870;
+   u32 rsv8871;
+   u32 rsv8872;
+   u32 rsv8873;
+   u32 rsv8874;
+   u32 rsv8875;
+   u32 rsv8876;
+   u32 rsv8877;
+   u32 rsv8878;
+   u32 rsv8879;
+   u32 rsv8880;
+   u32 rsv8881;
+   u32 rsv8882;
+   u32 rsv8883;
+   u32 rsv8884;
+   u32 rsv8885;
+   u32 rsv8886;
+   u32 rsv8887;
+   u32 rsv8888;
+   u32 rsv8889;
+   u32 rsv8890;
+   u32 rsv8891;
+   u32 rsv8892;
+   u32 rsv8893;
+   u32 rsv8894;
+   u32 rsv8895;
+   u32 rsv8896;
+   u32 rsv8897;
+   u32 rsv8898;
+   u32 rsv8899;
+   u32 rsv8900;
+   u32 rsv8901;
+   u32 rsv8902;
+   u32 rsv8903;
+   u32 rsv8904;
+   u32 rsv8905;
+   u32 rsv8906;
+   u32 rsv8907;
+   u32 rsv8908;
+   u32 rsv8909;
+   u32 rsv8910;
+   u32 rsv8911;
+   u32 rsv8912;
+   u32 rsv8913;
+   u32 rsv8914;
+   u32 rsv8915;
+   u32 rsv8916;
+   u32 rsv8917;
+   u32 rsv8918;
+   u32 rsv8919;
+   u32 rsv8920;
+   u32 rsv8921;
+   u32 rsv8922;
+   u32 rsv8923;
+   u32 rsv8924;
+   u32 rsv8925;
+   u32 rsv8926;
+   u32 rsv8927;
+   u32 rsv8928;
+   u32 rsv8929;
+   u32 rsv8930;
+   u32 rsv8931;
+   u32 rsv8932;
+   u32 rsv8933;
+   u32 rsv8934;
+   u32 rsv8935;
+   u32 rsv8936;
+   u32 rsv8937;
+   u32 rsv8938;
+   u32 rsv8939;
+   u32 rsv8940;
+   u32 rsv8941;
+   u32 rsv8942;
+   u32 rsv8943;
+   u32 rsv8944;
+   u32 rsv8945;
+   u32 rsv8946;
+   u32 rsv8947;
+   u32 rsv8948;
+   u32 rsv8949;
+   u32 rsv8950;
+   u32 rsv8951;
+   u32 rsv8952;
+   u32 rsv8953;
+   u32 rsv8954;
+   u32 rsv8955;
+   u32 rsv8956;
+   u32 rsv8957;
+   u32 rsv8958;
+   u32 rsv8959;
+   u32 TxDescCfgFifo0[2];               /* 0x00008c00 */
+   u32 TxDescCfgFifo1[2];               /* 0x00008c08 */
+   u32 TxDescCfgFifo2[2];               /* 0x00008c10 */
+   u32 TxDescCfgFifo3[2];               /* 0x00008c18 */
+   u32 TxDescCfgFifo4[2];               /* 0x00008c20 */
+   u32 TxDescCfgFifo5[2];               /* 0x00008c28 */
+   u32 TxDescCfgFifo6[2];               /* 0x00008c30 */
+   u32 TxDescCfgFifo7[2];               /* 0x00008c38 */
+   u32 TxDescCfgFifo8[2];               /* 0x00008c40 */
+   u32 TxDescCfgFifo9[2];               /* 0x00008c48 */
+   u32 TxDescCfgFifo10[2];              /* 0x00008c50 */
+   u32 TxDescCfgFifo11[2];              /* 0x00008c58 */
+   u32 TxDescCfgFifo12[2];              /* 0x00008c60 */
+   u32 TxDescCfgFifo13[2];              /* 0x00008c68 */
+   u32 TxDescCfgFifo14[2];              /* 0x00008c70 */
+   u32 TxDescCfgFifo15[2];              /* 0x00008c78 */
+   u32 TxDescCfgFifo16[2];              /* 0x00008c80 */
+   u32 TxDescCfgFifo17[2];              /* 0x00008c88 */
+   u32 TxDescCfgFifo18[2];              /* 0x00008c90 */
+   u32 TxDescCfgFifo19[2];              /* 0x00008c98 */
+   u32 TxDescCfgFifo20[2];              /* 0x00008ca0 */
+   u32 TxDescCfgFifo21[2];              /* 0x00008ca8 */
+   u32 TxDescCfgFifo22[2];              /* 0x00008cb0 */
+   u32 TxDescCfgFifo23[2];              /* 0x00008cb8 */
+   u32 TxDescCfgFifo24[2];              /* 0x00008cc0 */
+   u32 TxDescCfgFifo25[2];              /* 0x00008cc8 */
+   u32 TxDescCfgFifo26[2];              /* 0x00008cd0 */
+   u32 TxDescCfgFifo27[2];              /* 0x00008cd8 */
+   u32 TxDescCfgFifo28[2];              /* 0x00008ce0 */
+   u32 TxDescCfgFifo29[2];              /* 0x00008ce8 */
+   u32 TxDescCfgFifo30[2];              /* 0x00008cf0 */
+   u32 TxDescCfgFifo31[2];              /* 0x00008cf8 */
+   u32 TxDescCfgFifo32[2];              /* 0x00008d00 */
+   u32 TxDescCfgFifo33[2];              /* 0x00008d08 */
+   u32 TxDescCfgFifo34[2];              /* 0x00008d10 */
+   u32 TxDescCfgFifo35[2];              /* 0x00008d18 */
+   u32 TxDescCfgFifo36[2];              /* 0x00008d20 */
+   u32 TxDescCfgFifo37[2];              /* 0x00008d28 */
+   u32 TxDescCfgFifo38[2];              /* 0x00008d30 */
+   u32 TxDescCfgFifo39[2];              /* 0x00008d38 */
+   u32 TxDescCfgFifo40[2];              /* 0x00008d40 */
+   u32 TxDescCfgFifo41[2];              /* 0x00008d48 */
+   u32 TxDescCfgFifo42[2];              /* 0x00008d50 */
+   u32 TxDescCfgFifo43[2];              /* 0x00008d58 */
+   u32 TxDescCfgFifo44[2];              /* 0x00008d60 */
+   u32 TxDescCfgFifo45[2];              /* 0x00008d68 */
+   u32 TxDescCfgFifo46[2];              /* 0x00008d70 */
+   u32 TxDescCfgFifo47[2];              /* 0x00008d78 */
+   u32 TxDescCfgFifo48[2];              /* 0x00008d80 */
+   u32 TxDescCfgFifo49[2];              /* 0x00008d88 */
+   u32 TxDescCfgFifo50[2];              /* 0x00008d90 */
+   u32 TxDescCfgFifo51[2];              /* 0x00008d98 */
+   u32 TxDescCfgFifo52[2];              /* 0x00008da0 */
+   u32 TxDescCfgFifo53[2];              /* 0x00008da8 */
+   u32 TxDescCfgFifo54[2];              /* 0x00008db0 */
+   u32 TxDescCfgFifo55[2];              /* 0x00008db8 */
+   u32 TxDescCfgFifo56[2];              /* 0x00008dc0 */
+   u32 TxDescCfgFifo57[2];              /* 0x00008dc8 */
+   u32 TxDescCfgFifo58[2];              /* 0x00008dd0 */
+   u32 TxDescCfgFifo59[2];              /* 0x00008dd8 */
+   u32 TxDescCfgFifo60[2];              /* 0x00008de0 */
+   u32 TxDescCfgFifo61[2];              /* 0x00008de8 */
+   u32 TxDescCfgFifo62[2];              /* 0x00008df0 */
+   u32 TxDescCfgFifo63[2];              /* 0x00008df8 */
+   u32 RxDesc0CfgFifo0[2];              /* 0x00008e00 */
+   u32 RxDesc0CfgFifo1[2];              /* 0x00008e08 */
+   u32 RxDesc0CfgFifo2[2];              /* 0x00008e10 */
+   u32 RxDesc0CfgFifo3[2];              /* 0x00008e18 */
+   u32 RxDesc0CfgFifo4[2];              /* 0x00008e20 */
+   u32 RxDesc0CfgFifo5[2];              /* 0x00008e28 */
+   u32 RxDesc0CfgFifo6[2];              /* 0x00008e30 */
+   u32 RxDesc0CfgFifo7[2];              /* 0x00008e38 */
+   u32 RxDesc0CfgFifo8[2];              /* 0x00008e40 */
+   u32 RxDesc0CfgFifo9[2];              /* 0x00008e48 */
+   u32 RxDesc0CfgFifo10[2];             /* 0x00008e50 */
+   u32 RxDesc0CfgFifo11[2];             /* 0x00008e58 */
+   u32 RxDesc0CfgFifo12[2];             /* 0x00008e60 */
+   u32 RxDesc0CfgFifo13[2];             /* 0x00008e68 */
+   u32 RxDesc0CfgFifo14[2];             /* 0x00008e70 */
+   u32 RxDesc0CfgFifo15[2];             /* 0x00008e78 */
+   u32 RxDesc0CfgFifo16[2];             /* 0x00008e80 */
+   u32 RxDesc0CfgFifo17[2];             /* 0x00008e88 */
+   u32 RxDesc0CfgFifo18[2];             /* 0x00008e90 */
+   u32 RxDesc0CfgFifo19[2];             /* 0x00008e98 */
+   u32 RxDesc0CfgFifo20[2];             /* 0x00008ea0 */
+   u32 RxDesc0CfgFifo21[2];             /* 0x00008ea8 */
+   u32 RxDesc0CfgFifo22[2];             /* 0x00008eb0 */
+   u32 RxDesc0CfgFifo23[2];             /* 0x00008eb8 */
+   u32 RxDesc0CfgFifo24[2];             /* 0x00008ec0 */
+   u32 RxDesc0CfgFifo25[2];             /* 0x00008ec8 */
+   u32 RxDesc0CfgFifo26[2];             /* 0x00008ed0 */
+   u32 RxDesc0CfgFifo27[2];             /* 0x00008ed8 */
+   u32 RxDesc0CfgFifo28[2];             /* 0x00008ee0 */
+   u32 RxDesc0CfgFifo29[2];             /* 0x00008ee8 */
+   u32 RxDesc0CfgFifo30[2];             /* 0x00008ef0 */
+   u32 RxDesc0CfgFifo31[2];             /* 0x00008ef8 */
+   u32 RxDesc0CfgFifo32[2];             /* 0x00008f00 */
+   u32 RxDesc0CfgFifo33[2];             /* 0x00008f08 */
+   u32 RxDesc0CfgFifo34[2];             /* 0x00008f10 */
+   u32 RxDesc0CfgFifo35[2];             /* 0x00008f18 */
+   u32 RxDesc0CfgFifo36[2];             /* 0x00008f20 */
+   u32 RxDesc0CfgFifo37[2];             /* 0x00008f28 */
+   u32 RxDesc0CfgFifo38[2];             /* 0x00008f30 */
+   u32 RxDesc0CfgFifo39[2];             /* 0x00008f38 */
+   u32 RxDesc0CfgFifo40[2];             /* 0x00008f40 */
+   u32 RxDesc0CfgFifo41[2];             /* 0x00008f48 */
+   u32 RxDesc0CfgFifo42[2];             /* 0x00008f50 */
+   u32 RxDesc0CfgFifo43[2];             /* 0x00008f58 */
+   u32 RxDesc0CfgFifo44[2];             /* 0x00008f60 */
+   u32 RxDesc0CfgFifo45[2];             /* 0x00008f68 */
+   u32 RxDesc0CfgFifo46[2];             /* 0x00008f70 */
+   u32 RxDesc0CfgFifo47[2];             /* 0x00008f78 */
+   u32 RxDesc0CfgFifo48[2];             /* 0x00008f80 */
+   u32 RxDesc0CfgFifo49[2];             /* 0x00008f88 */
+   u32 RxDesc0CfgFifo50[2];             /* 0x00008f90 */
+   u32 RxDesc0CfgFifo51[2];             /* 0x00008f98 */
+   u32 RxDesc0CfgFifo52[2];             /* 0x00008fa0 */
+   u32 RxDesc0CfgFifo53[2];             /* 0x00008fa8 */
+   u32 RxDesc0CfgFifo54[2];             /* 0x00008fb0 */
+   u32 RxDesc0CfgFifo55[2];             /* 0x00008fb8 */
+   u32 RxDesc0CfgFifo56[2];             /* 0x00008fc0 */
+   u32 RxDesc0CfgFifo57[2];             /* 0x00008fc8 */
+   u32 RxDesc0CfgFifo58[2];             /* 0x00008fd0 */
+   u32 RxDesc0CfgFifo59[2];             /* 0x00008fd8 */
+   u32 RxDesc0CfgFifo60[2];             /* 0x00008fe0 */
+   u32 RxDesc0CfgFifo61[2];             /* 0x00008fe8 */
+   u32 RxDesc0CfgFifo62[2];             /* 0x00008ff0 */
+   u32 RxDesc0CfgFifo63[2];             /* 0x00008ff8 */
+   u32 RxDesc1CfgFifo0[2];              /* 0x00009000 */
+   u32 RxDesc1CfgFifo1[2];              /* 0x00009008 */
+   u32 RxDesc1CfgFifo2[2];              /* 0x00009010 */
+   u32 RxDesc1CfgFifo3[2];              /* 0x00009018 */
+   u32 RxDesc1CfgFifo4[2];              /* 0x00009020 */
+   u32 RxDesc1CfgFifo5[2];              /* 0x00009028 */
+   u32 RxDesc1CfgFifo6[2];              /* 0x00009030 */
+   u32 RxDesc1CfgFifo7[2];              /* 0x00009038 */
+   u32 RxDesc1CfgFifo8[2];              /* 0x00009040 */
+   u32 RxDesc1CfgFifo9[2];              /* 0x00009048 */
+   u32 RxDesc1CfgFifo10[2];             /* 0x00009050 */
+   u32 RxDesc1CfgFifo11[2];             /* 0x00009058 */
+   u32 RxDesc1CfgFifo12[2];             /* 0x00009060 */
+   u32 RxDesc1CfgFifo13[2];             /* 0x00009068 */
+   u32 RxDesc1CfgFifo14[2];             /* 0x00009070 */
+   u32 RxDesc1CfgFifo15[2];             /* 0x00009078 */
+   u32 RxDesc1CfgFifo16[2];             /* 0x00009080 */
+   u32 RxDesc1CfgFifo17[2];             /* 0x00009088 */
+   u32 RxDesc1CfgFifo18[2];             /* 0x00009090 */
+   u32 RxDesc1CfgFifo19[2];             /* 0x00009098 */
+   u32 RxDesc1CfgFifo20[2];             /* 0x000090a0 */
+   u32 RxDesc1CfgFifo21[2];             /* 0x000090a8 */
+   u32 RxDesc1CfgFifo22[2];             /* 0x000090b0 */
+   u32 RxDesc1CfgFifo23[2];             /* 0x000090b8 */
+   u32 RxDesc1CfgFifo24[2];             /* 0x000090c0 */
+   u32 RxDesc1CfgFifo25[2];             /* 0x000090c8 */
+   u32 RxDesc1CfgFifo26[2];             /* 0x000090d0 */
+   u32 RxDesc1CfgFifo27[2];             /* 0x000090d8 */
+   u32 RxDesc1CfgFifo28[2];             /* 0x000090e0 */
+   u32 RxDesc1CfgFifo29[2];             /* 0x000090e8 */
+   u32 RxDesc1CfgFifo30[2];             /* 0x000090f0 */
+   u32 RxDesc1CfgFifo31[2];             /* 0x000090f8 */
+   u32 RxDesc1CfgFifo32[2];             /* 0x00009100 */
+   u32 RxDesc1CfgFifo33[2];             /* 0x00009108 */
+   u32 RxDesc1CfgFifo34[2];             /* 0x00009110 */
+   u32 RxDesc1CfgFifo35[2];             /* 0x00009118 */
+   u32 RxDesc1CfgFifo36[2];             /* 0x00009120 */
+   u32 RxDesc1CfgFifo37[2];             /* 0x00009128 */
+   u32 RxDesc1CfgFifo38[2];             /* 0x00009130 */
+   u32 RxDesc1CfgFifo39[2];             /* 0x00009138 */
+   u32 RxDesc1CfgFifo40[2];             /* 0x00009140 */
+   u32 RxDesc1CfgFifo41[2];             /* 0x00009148 */
+   u32 RxDesc1CfgFifo42[2];             /* 0x00009150 */
+   u32 RxDesc1CfgFifo43[2];             /* 0x00009158 */
+   u32 RxDesc1CfgFifo44[2];             /* 0x00009160 */
+   u32 RxDesc1CfgFifo45[2];             /* 0x00009168 */
+   u32 RxDesc1CfgFifo46[2];             /* 0x00009170 */
+   u32 RxDesc1CfgFifo47[2];             /* 0x00009178 */
+   u32 RxDesc1CfgFifo48[2];             /* 0x00009180 */
+   u32 RxDesc1CfgFifo49[2];             /* 0x00009188 */
+   u32 RxDesc1CfgFifo50[2];             /* 0x00009190 */
+   u32 RxDesc1CfgFifo51[2];             /* 0x00009198 */
+   u32 RxDesc1CfgFifo52[2];             /* 0x000091a0 */
+   u32 RxDesc1CfgFifo53[2];             /* 0x000091a8 */
+   u32 RxDesc1CfgFifo54[2];             /* 0x000091b0 */
+   u32 RxDesc1CfgFifo55[2];             /* 0x000091b8 */
+   u32 RxDesc1CfgFifo56[2];             /* 0x000091c0 */
+   u32 RxDesc1CfgFifo57[2];             /* 0x000091c8 */
+   u32 RxDesc1CfgFifo58[2];             /* 0x000091d0 */
+   u32 RxDesc1CfgFifo59[2];             /* 0x000091d8 */
+   u32 RxDesc1CfgFifo60[2];             /* 0x000091e0 */
+   u32 RxDesc1CfgFifo61[2];             /* 0x000091e8 */
+   u32 RxDesc1CfgFifo62[2];             /* 0x000091f0 */
+   u32 RxDesc1CfgFifo63[2];             /* 0x000091f8 */
+   u32 RxDesc0AckFifo0[1];              /* 0x00009200 */
+   u32 RxDesc0AckFifo1[1];              /* 0x00009204 */
+   u32 RxDesc0AckFifo2[1];              /* 0x00009208 */
+   u32 RxDesc0AckFifo3[1];              /* 0x0000920c */
+   u32 RxDesc0AckFifo4[1];              /* 0x00009210 */
+   u32 RxDesc0AckFifo5[1];              /* 0x00009214 */
+   u32 RxDesc0AckFifo6[1];              /* 0x00009218 */
+   u32 RxDesc0AckFifo7[1];              /* 0x0000921c */
+   u32 RxDesc0AckFifo8[1];              /* 0x00009220 */
+   u32 RxDesc0AckFifo9[1];              /* 0x00009224 */
+   u32 RxDesc0AckFifo10[1];             /* 0x00009228 */
+   u32 RxDesc0AckFifo11[1];             /* 0x0000922c */
+   u32 RxDesc0AckFifo12[1];             /* 0x00009230 */
+   u32 RxDesc0AckFifo13[1];             /* 0x00009234 */
+   u32 RxDesc0AckFifo14[1];             /* 0x00009238 */
+   u32 RxDesc0AckFifo15[1];             /* 0x0000923c */
+   u32 RxDesc0AckFifo16[1];             /* 0x00009240 */
+   u32 RxDesc0AckFifo17[1];             /* 0x00009244 */
+   u32 RxDesc0AckFifo18[1];             /* 0x00009248 */
+   u32 RxDesc0AckFifo19[1];             /* 0x0000924c */
+   u32 RxDesc0AckFifo20[1];             /* 0x00009250 */
+   u32 RxDesc0AckFifo21[1];             /* 0x00009254 */
+   u32 RxDesc0AckFifo22[1];             /* 0x00009258 */
+   u32 RxDesc0AckFifo23[1];             /* 0x0000925c */
+   u32 RxDesc0AckFifo24[1];             /* 0x00009260 */
+   u32 RxDesc0AckFifo25[1];             /* 0x00009264 */
+   u32 RxDesc0AckFifo26[1];             /* 0x00009268 */
+   u32 RxDesc0AckFifo27[1];             /* 0x0000926c */
+   u32 RxDesc0AckFifo28[1];             /* 0x00009270 */
+   u32 RxDesc0AckFifo29[1];             /* 0x00009274 */
+   u32 RxDesc0AckFifo30[1];             /* 0x00009278 */
+   u32 RxDesc0AckFifo31[1];             /* 0x0000927c */
+   u32 RxDesc0AckFifo32[1];             /* 0x00009280 */
+   u32 RxDesc0AckFifo33[1];             /* 0x00009284 */
+   u32 RxDesc0AckFifo34[1];             /* 0x00009288 */
+   u32 RxDesc0AckFifo35[1];             /* 0x0000928c */
+   u32 RxDesc0AckFifo36[1];             /* 0x00009290 */
+   u32 RxDesc0AckFifo37[1];             /* 0x00009294 */
+   u32 RxDesc0AckFifo38[1];             /* 0x00009298 */
+   u32 RxDesc0AckFifo39[1];             /* 0x0000929c */
+   u32 RxDesc0AckFifo40[1];             /* 0x000092a0 */
+   u32 RxDesc0AckFifo41[1];             /* 0x000092a4 */
+   u32 RxDesc0AckFifo42[1];             /* 0x000092a8 */
+   u32 RxDesc0AckFifo43[1];             /* 0x000092ac */
+   u32 RxDesc0AckFifo44[1];             /* 0x000092b0 */
+   u32 RxDesc0AckFifo45[1];             /* 0x000092b4 */
+   u32 RxDesc0AckFifo46[1];             /* 0x000092b8 */
+   u32 RxDesc0AckFifo47[1];             /* 0x000092bc */
+   u32 RxDesc0AckFifo48[1];             /* 0x000092c0 */
+   u32 RxDesc0AckFifo49[1];             /* 0x000092c4 */
+   u32 RxDesc0AckFifo50[1];             /* 0x000092c8 */
+   u32 RxDesc0AckFifo51[1];             /* 0x000092cc */
+   u32 RxDesc0AckFifo52[1];             /* 0x000092d0 */
+   u32 RxDesc0AckFifo53[1];             /* 0x000092d4 */
+   u32 RxDesc0AckFifo54[1];             /* 0x000092d8 */
+   u32 RxDesc0AckFifo55[1];             /* 0x000092dc */
+   u32 RxDesc0AckFifo56[1];             /* 0x000092e0 */
+   u32 RxDesc0AckFifo57[1];             /* 0x000092e4 */
+   u32 RxDesc0AckFifo58[1];             /* 0x000092e8 */
+   u32 RxDesc0AckFifo59[1];             /* 0x000092ec */
+   u32 RxDesc0AckFifo60[1];             /* 0x000092f0 */
+   u32 RxDesc0AckFifo61[1];             /* 0x000092f4 */
+   u32 RxDesc0AckFifo62[1];             /* 0x000092f8 */
+   u32 RxDesc0AckFifo63[1];             /* 0x000092fc */
+   u32 RxDesc1AckFifo0[1];              /* 0x00009300 */
+   u32 RxDesc1AckFifo1[1];              /* 0x00009304 */
+   u32 RxDesc1AckFifo2[1];              /* 0x00009308 */
+   u32 RxDesc1AckFifo3[1];              /* 0x0000930c */
+   u32 RxDesc1AckFifo4[1];              /* 0x00009310 */
+   u32 RxDesc1AckFifo5[1];              /* 0x00009314 */
+   u32 RxDesc1AckFifo6[1];              /* 0x00009318 */
+   u32 RxDesc1AckFifo7[1];              /* 0x0000931c */
+   u32 RxDesc1AckFifo8[1];              /* 0x00009320 */
+   u32 RxDesc1AckFifo9[1];              /* 0x00009324 */
+   u32 RxDesc1AckFifo10[1];             /* 0x00009328 */
+   u32 RxDesc1AckFifo11[1];             /* 0x0000932c */
+   u32 RxDesc1AckFifo12[1];             /* 0x00009330 */
+   u32 RxDesc1AckFifo13[1];             /* 0x00009334 */
+   u32 RxDesc1AckFifo14[1];             /* 0x00009338 */
+   u32 RxDesc1AckFifo15[1];             /* 0x0000933c */
+   u32 RxDesc1AckFifo16[1];             /* 0x00009340 */
+   u32 RxDesc1AckFifo17[1];             /* 0x00009344 */
+   u32 RxDesc1AckFifo18[1];             /* 0x00009348 */
+   u32 RxDesc1AckFifo19[1];             /* 0x0000934c */
+   u32 RxDesc1AckFifo20[1];             /* 0x00009350 */
+   u32 RxDesc1AckFifo21[1];             /* 0x00009354 */
+   u32 RxDesc1AckFifo22[1];             /* 0x00009358 */
+   u32 RxDesc1AckFifo23[1];             /* 0x0000935c */
+   u32 RxDesc1AckFifo24[1];             /* 0x00009360 */
+   u32 RxDesc1AckFifo25[1];             /* 0x00009364 */
+   u32 RxDesc1AckFifo26[1];             /* 0x00009368 */
+   u32 RxDesc1AckFifo27[1];             /* 0x0000936c */
+   u32 RxDesc1AckFifo28[1];             /* 0x00009370 */
+   u32 RxDesc1AckFifo29[1];             /* 0x00009374 */
+   u32 RxDesc1AckFifo30[1];             /* 0x00009378 */
+   u32 RxDesc1AckFifo31[1];             /* 0x0000937c */
+   u32 RxDesc1AckFifo32[1];             /* 0x00009380 */
+   u32 RxDesc1AckFifo33[1];             /* 0x00009384 */
+   u32 RxDesc1AckFifo34[1];             /* 0x00009388 */
+   u32 RxDesc1AckFifo35[1];             /* 0x0000938c */
+   u32 RxDesc1AckFifo36[1];             /* 0x00009390 */
+   u32 RxDesc1AckFifo37[1];             /* 0x00009394 */
+   u32 RxDesc1AckFifo38[1];             /* 0x00009398 */
+   u32 RxDesc1AckFifo39[1];             /* 0x0000939c */
+   u32 RxDesc1AckFifo40[1];             /* 0x000093a0 */
+   u32 RxDesc1AckFifo41[1];             /* 0x000093a4 */
+   u32 RxDesc1AckFifo42[1];             /* 0x000093a8 */
+   u32 RxDesc1AckFifo43[1];             /* 0x000093ac */
+   u32 RxDesc1AckFifo44[1];             /* 0x000093b0 */
+   u32 RxDesc1AckFifo45[1];             /* 0x000093b4 */
+   u32 RxDesc1AckFifo46[1];             /* 0x000093b8 */
+   u32 RxDesc1AckFifo47[1];             /* 0x000093bc */
+   u32 RxDesc1AckFifo48[1];             /* 0x000093c0 */
+   u32 RxDesc1AckFifo49[1];             /* 0x000093c4 */
+   u32 RxDesc1AckFifo50[1];             /* 0x000093c8 */
+   u32 RxDesc1AckFifo51[1];             /* 0x000093cc */
+   u32 RxDesc1AckFifo52[1];             /* 0x000093d0 */
+   u32 RxDesc1AckFifo53[1];             /* 0x000093d4 */
+   u32 RxDesc1AckFifo54[1];             /* 0x000093d8 */
+   u32 RxDesc1AckFifo55[1];             /* 0x000093dc */
+   u32 RxDesc1AckFifo56[1];             /* 0x000093e0 */
+   u32 RxDesc1AckFifo57[1];             /* 0x000093e4 */
+   u32 RxDesc1AckFifo58[1];             /* 0x000093e8 */
+   u32 RxDesc1AckFifo59[1];             /* 0x000093ec */
+   u32 RxDesc1AckFifo60[1];             /* 0x000093f0 */
+   u32 RxDesc1AckFifo61[1];             /* 0x000093f4 */
+   u32 RxDesc1AckFifo62[1];             /* 0x000093f8 */
+   u32 RxDesc1AckFifo63[1];             /* 0x000093fc */
+   u32 TxDescAckFifo0[1];               /* 0x00009400 */
+   u32 TxDescAckFifo1[1];               /* 0x00009404 */
+   u32 TxDescAckFifo2[1];               /* 0x00009408 */
+   u32 TxDescAckFifo3[1];               /* 0x0000940c */
+   u32 TxDescAckFifo4[1];               /* 0x00009410 */
+   u32 TxDescAckFifo5[1];               /* 0x00009414 */
+   u32 TxDescAckFifo6[1];               /* 0x00009418 */
+   u32 TxDescAckFifo7[1];               /* 0x0000941c */
+   u32 TxDescAckFifo8[1];               /* 0x00009420 */
+   u32 TxDescAckFifo9[1];               /* 0x00009424 */
+   u32 TxDescAckFifo10[1];              /* 0x00009428 */
+   u32 TxDescAckFifo11[1];              /* 0x0000942c */
+   u32 TxDescAckFifo12[1];              /* 0x00009430 */
+   u32 TxDescAckFifo13[1];              /* 0x00009434 */
+   u32 TxDescAckFifo14[1];              /* 0x00009438 */
+   u32 TxDescAckFifo15[1];              /* 0x0000943c */
+   u32 TxDescAckFifo16[1];              /* 0x00009440 */
+   u32 TxDescAckFifo17[1];              /* 0x00009444 */
+   u32 TxDescAckFifo18[1];              /* 0x00009448 */
+   u32 TxDescAckFifo19[1];              /* 0x0000944c */
+   u32 TxDescAckFifo20[1];              /* 0x00009450 */
+   u32 TxDescAckFifo21[1];              /* 0x00009454 */
+   u32 TxDescAckFifo22[1];              /* 0x00009458 */
+   u32 TxDescAckFifo23[1];              /* 0x0000945c */
+   u32 TxDescAckFifo24[1];              /* 0x00009460 */
+   u32 TxDescAckFifo25[1];              /* 0x00009464 */
+   u32 TxDescAckFifo26[1];              /* 0x00009468 */
+   u32 TxDescAckFifo27[1];              /* 0x0000946c */
+   u32 TxDescAckFifo28[1];              /* 0x00009470 */
+   u32 TxDescAckFifo29[1];              /* 0x00009474 */
+   u32 TxDescAckFifo30[1];              /* 0x00009478 */
+   u32 TxDescAckFifo31[1];              /* 0x0000947c */
+   u32 TxDescAckFifo32[1];              /* 0x00009480 */
+   u32 TxDescAckFifo33[1];              /* 0x00009484 */
+   u32 TxDescAckFifo34[1];              /* 0x00009488 */
+   u32 TxDescAckFifo35[1];              /* 0x0000948c */
+   u32 TxDescAckFifo36[1];              /* 0x00009490 */
+   u32 TxDescAckFifo37[1];              /* 0x00009494 */
+   u32 TxDescAckFifo38[1];              /* 0x00009498 */
+   u32 TxDescAckFifo39[1];              /* 0x0000949c */
+   u32 TxDescAckFifo40[1];              /* 0x000094a0 */
+   u32 TxDescAckFifo41[1];              /* 0x000094a4 */
+   u32 TxDescAckFifo42[1];              /* 0x000094a8 */
+   u32 TxDescAckFifo43[1];              /* 0x000094ac */
+   u32 TxDescAckFifo44[1];              /* 0x000094b0 */
+   u32 TxDescAckFifo45[1];              /* 0x000094b4 */
+   u32 TxDescAckFifo46[1];              /* 0x000094b8 */
+   u32 TxDescAckFifo47[1];              /* 0x000094bc */
+   u32 TxDescAckFifo48[1];              /* 0x000094c0 */
+   u32 TxDescAckFifo49[1];              /* 0x000094c4 */
+   u32 TxDescAckFifo50[1];              /* 0x000094c8 */
+   u32 TxDescAckFifo51[1];              /* 0x000094cc */
+   u32 TxDescAckFifo52[1];              /* 0x000094d0 */
+   u32 TxDescAckFifo53[1];              /* 0x000094d4 */
+   u32 TxDescAckFifo54[1];              /* 0x000094d8 */
+   u32 TxDescAckFifo55[1];              /* 0x000094dc */
+   u32 TxDescAckFifo56[1];              /* 0x000094e0 */
+   u32 TxDescAckFifo57[1];              /* 0x000094e4 */
+   u32 TxDescAckFifo58[1];              /* 0x000094e8 */
+   u32 TxDescAckFifo59[1];              /* 0x000094ec */
+   u32 TxDescAckFifo60[1];              /* 0x000094f0 */
+   u32 TxDescAckFifo61[1];              /* 0x000094f4 */
+   u32 TxDescAckFifo62[1];              /* 0x000094f8 */
+   u32 TxDescAckFifo63[1];              /* 0x000094fc */
+   u32 CpuMacDescIntf0[2];              /* 0x00009500 */
+   u32 CpuMacDescIntf1[2];              /* 0x00009508 */
+   u32 CpuMacDescIntf2[2];              /* 0x00009510 */
+};
+
+/* ################################################################################
+ * # TxPktFifo Definition
+ */
+#define TX_PKT_FIFO_W0_TX_PKT_FIFO_FIELD0                            BIT(0)
+#define TX_PKT_FIFO_W1_TX_PKT_FIFO_FIELD1                            BIT(0)
+#define TX_PKT_FIFO_W2_TX_PKT_FIFO_FIELD2                            BIT(0)
+
+#define TX_PKT_FIFO_W0_TX_PKT_FIFO_FIELD0_MASK                       0xffffffff
+#define TX_PKT_FIFO_W1_TX_PKT_FIFO_FIELD1_MASK                       0xffffffff
+#define TX_PKT_FIFO_W2_TX_PKT_FIFO_FIELD2_MASK                       0x0000000f
+
+/* ################################################################################
+ * # RxPktMsgFifo Definition
+ */
+#define RX_PKT_MSG_FIFO_W0_RX_PKT_MSG_FIFO_FIELD                     BIT(0)
+
+#define RX_PKT_MSG_FIFO_W0_RX_PKT_MSG_FIFO_FIELD_MASK                0x0000ffff
+
+/* ################################################################################
+ * # CpuMacStatsRam Definition
+ */
+#define CPU_MAC_STATS_RAM_W0_BYTE_CNT_31_0                           BIT(0)
+#define CPU_MAC_STATS_RAM_W1_BYTE_CNT_39_32                          BIT(0)
+#define CPU_MAC_STATS_RAM_W2_FRAME_CNT_31_0                          BIT(0)
+#define CPU_MAC_STATS_RAM_W3_FRAME_CNT_33_32                         BIT(0)
+
+#define CPU_MAC_STATS_RAM_W0_BYTE_CNT_31_0_MASK                      0xffffffff
+#define CPU_MAC_STATS_RAM_W1_BYTE_CNT_39_32_MASK                     0x000000ff
+#define CPU_MAC_STATS_RAM_W2_FRAME_CNT_31_0_MASK                     0xffffffff
+#define CPU_MAC_STATS_RAM_W3_FRAME_CNT_33_32_MASK                    0x00000003
+
+/* ################################################################################
+ * # TxDescCfgFifo Definition
+ */
+#define TX_DESC_CFG_FIFO_W0_TX_DESC_CFG_FIFO_FIELD0                  BIT(0)
+#define TX_DESC_CFG_FIFO_W1_TX_DESC_CFG_FIFO_FIELD1                  BIT(0)
+
+#define TX_DESC_CFG_FIFO_W0_TX_DESC_CFG_FIFO_FIELD0_MASK             0xffffffff
+#define TX_DESC_CFG_FIFO_W1_TX_DESC_CFG_FIFO_FIELD1_MASK             0x01ffffff
+
+/* ################################################################################
+ * # RxDesc0CfgFifo Definition
+ */
+#define RX_DESC0_CFG_FIFO_W0_RX_DESC0_CFG_FIFO_FIELD0                BIT(0)
+#define RX_DESC0_CFG_FIFO_W1_RX_DESC0_CFG_FIFO_FIELD1                BIT(0)
+
+#define RX_DESC0_CFG_FIFO_W0_RX_DESC0_CFG_FIFO_FIELD0_MASK           0xffffffff
+#define RX_DESC0_CFG_FIFO_W1_RX_DESC0_CFG_FIFO_FIELD1_MASK           0x01ffffff
+
+/* ################################################################################
+ * # RxDesc1CfgFifo Definition
+ */
+#define RX_DESC1_CFG_FIFO_W0_RX_DESC1_CFG_FIFO_FIELD0                BIT(0)
+#define RX_DESC1_CFG_FIFO_W1_RX_DESC1_CFG_FIFO_FIELD1                BIT(0)
+
+#define RX_DESC1_CFG_FIFO_W0_RX_DESC1_CFG_FIFO_FIELD0_MASK           0xffffffff
+#define RX_DESC1_CFG_FIFO_W1_RX_DESC1_CFG_FIFO_FIELD1_MASK           0x01ffffff
+
+/* ################################################################################
+ * # RxDesc0AckFifo Definition
+ */
+#define RX_DESC0_ACK_FIFO_W0_RX_DESC0_ACK_FIFO_FIELD                 BIT(0)
+
+#define RX_DESC0_ACK_FIFO_W0_RX_DESC0_ACK_FIFO_FIELD_MASK            0x0007ffff
+
+/* ################################################################################
+ * # RxDesc1AckFifo Definition
+ */
+#define RX_DESC1_ACK_FIFO_W0_RX_DESC1_ACK_FIFO_FIELD                 BIT(0)
+
+#define RX_DESC1_ACK_FIFO_W0_RX_DESC1_ACK_FIFO_FIELD_MASK            0x0007ffff
+
+/* ################################################################################
+ * # TxDescAckFifo Definition
+ */
+#define TX_DESC_ACK_FIFO_W0_TX_DESC_ACK_FIFO_FIELD                   BIT(0)
+
+#define TX_DESC_ACK_FIFO_W0_TX_DESC_ACK_FIFO_FIELD_MASK              0x00000001
+
+/* ################################################################################
+ * # CpuMacDescIntf Definition
+ */
+#define CPU_MAC_DESC_INTF_W0_DESC_ADDR_31_0                          BIT(0)
+#define CPU_MAC_DESC_INTF_W1_DESC_ADDR_39_32                         BIT(0)
+#define CPU_MAC_DESC_INTF_W1_DESC_SIZE                               BIT(8)
+#define CPU_MAC_DESC_INTF_W1_DESC_SOP                                BIT(22)
+#define CPU_MAC_DESC_INTF_W1_DESC_ERR_TYPE                           BIT(25)
+#define CPU_MAC_DESC_INTF_W1_DESC_EOP                                BIT(23)
+#define CPU_MAC_DESC_INTF_W1_DESC_ERR                                BIT(24)
+
+#define CPU_MAC_DESC_INTF_W0_DESC_ADDR_31_0_MASK                     0xffffffff
+#define CPU_MAC_DESC_INTF_W1_DESC_ADDR_39_32_MASK                    0x000000ff
+#define CPU_MAC_DESC_INTF_W1_DESC_SIZE_MASK                          0x003fff00
+#define CPU_MAC_DESC_INTF_W1_DESC_SOP_MASK                           0x00400000
+#define CPU_MAC_DESC_INTF_W1_DESC_ERR_TYPE_MASK                      0x0e000000
+#define CPU_MAC_DESC_INTF_W1_DESC_EOP_MASK                           0x00800000
+#define CPU_MAC_DESC_INTF_W1_DESC_ERR_MASK                           0x01000000
+
+/* defing MDIOSOC_REG_BASE   0x00000000 */
+
+struct MdioSoc_regs {
+   u32 MdioSocCmd0[2];                  /* 0x00000000 */
+   u32 MdioSocCmd1[2];                  /* 0x00000008 */
+   u32 MdioSocStatus1;                  /* 0x00000010 */
+   u32 MdioSocStatus0;                  /* 0x00000014 */
+   u32 MdioSocReserved;                 /* 0x00000018 */
+   u32 MdioSocCfg0;                     /* 0x0000001c */
+   u32 MdioSocCfg1;                     /* 0x00000020 */
+};
+
+/* ################################################################################
+ * # MdioSocCmd0 Definition
+ */
+#define MDIO_SOC_CMD0_W0_OP_CODE_CMD_LANE0                           BIT(26)
+#define MDIO_SOC_CMD0_W0_REG_ADD_CMD_LANE0                           BIT(16)
+#define MDIO_SOC_CMD0_W0_DATA_CMD_LANE0                              BIT(0)
+#define MDIO_SOC_CMD0_W0_PHY_ADD_CMD_LANE0                           BIT(21)
+#define MDIO_SOC_CMD0_W1_START_CMD_LANE0                             BIT(0)
+
+#define MDIO_SOC_CMD0_W0_OP_CODE_CMD_LANE0_MASK                      0x0c000000
+#define MDIO_SOC_CMD0_W0_REG_ADD_CMD_LANE0_MASK                      0x001f0000
+#define MDIO_SOC_CMD0_W0_DATA_CMD_LANE0_MASK                         0x0000ffff
+#define MDIO_SOC_CMD0_W0_PHY_ADD_CMD_LANE0_MASK                      0x03e00000
+#define MDIO_SOC_CMD0_W1_START_CMD_LANE0_MASK                        0x00000003
+
+/* ################################################################################
+ * # MdioSocCmd1 Definition
+ */
+#define MDIO_SOC_CMD1_W0_PHY_ADD_CMD_LANE1                           BIT(21)
+#define MDIO_SOC_CMD1_W0_OP_CODE_CMD_LANE1                           BIT(26)
+#define MDIO_SOC_CMD1_W0_DATA_CMD_LANE1                              BIT(0)
+#define MDIO_SOC_CMD1_W0_REG_ADD_CMD_LANE1                           BIT(16)
+#define MDIO_SOC_CMD1_W1_START_CMD_LANE1                             BIT(0)
+
+#define MDIO_SOC_CMD1_W0_PHY_ADD_CMD_LANE1_MASK                      0x03e00000
+#define MDIO_SOC_CMD1_W0_OP_CODE_CMD_LANE1_MASK                      0x0c000000
+#define MDIO_SOC_CMD1_W0_DATA_CMD_LANE1_MASK                         0x0000ffff
+#define MDIO_SOC_CMD1_W0_REG_ADD_CMD_LANE1_MASK                      0x001f0000
+#define MDIO_SOC_CMD1_W1_START_CMD_LANE1_MASK                        0x00000003
+
+/* ################################################################################
+ * # MdioSocStatus1 Definition
+ */
+#define MDIO_SOC_STATUS1_W0_MDIO_CMD_DONE_LANE1                      BIT(16)
+#define MDIO_SOC_STATUS1_W0_MDIO_READ_DATA_LANE1                     BIT(0)
+
+#define MDIO_SOC_STATUS1_W0_MDIO_CMD_DONE_LANE1_MASK                 0x00010000
+#define MDIO_SOC_STATUS1_W0_MDIO_READ_DATA_LANE1_MASK                0x0000ffff
+
+/* ################################################################################
+ * # MdioSocStatus0 Definition
+ */
+#define MDIO_SOC_STATUS0_W0_MDIO_CMD_DONE_LANE0                      BIT(16)
+#define MDIO_SOC_STATUS0_W0_MDIO_READ_DATA_LANE0                     BIT(0)
+
+#define MDIO_SOC_STATUS0_W0_MDIO_CMD_DONE_LANE0_MASK                 0x00010000
+#define MDIO_SOC_STATUS0_W0_MDIO_READ_DATA_LANE0_MASK                0x0000ffff
+
+/* ################################################################################
+ * # MdioSocReserved Definition
+ */
+#define MDIO_SOC_RESERVED_W0_RESERVED                                BIT(0)
+
+#define MDIO_SOC_RESERVED_W0_RESERVED_MASK                           0x0000ffff
+
+/* ################################################################################
+ * # MdioSocCfg0 Definition
+ */
+#define MDIO_SOC_CFG0_W0_MDIO_MAC_PRE_LANE0                          BIT(0)
+#define MDIO_SOC_CFG0_W0_MDIO_IN_DLY_LANE0                           BIT(8)
+
+#define MDIO_SOC_CFG0_W0_MDIO_MAC_PRE_LANE0_MASK                     0x0000003f
+#define MDIO_SOC_CFG0_W0_MDIO_IN_DLY_LANE0_MASK                      0x00000f00
+
+/* ################################################################################
+ * # MdioSocCfg1 Definition
+ */
+#define MDIO_SOC_CFG1_W0_MDIO_IN_DLY_LANE1                           BIT(8)
+#define MDIO_SOC_CFG1_W0_MDIO_MAC_PRE_LANE1                          BIT(0)
+
+#define MDIO_SOC_CFG1_W0_MDIO_IN_DLY_LANE1_MASK                      0x00000f00
+#define MDIO_SOC_CFG1_W0_MDIO_MAC_PRE_LANE1_MASK                     0x0000003f
+
+#define CPUMACUNIT_MEM_BASE   0x00000400
+#define CPUMACUNIT_REG_BASE   0x00000040
+
+struct CpuMacUnit_regs {
+   u32 CpuMacUnitHssMon[7];             /* 0x00000040 */
+   u32 rsv23;
+   u32 CpuMacHssRegAccTimingCfg[2];     /* 0x00000060 */
+   u32 CpuMacUnitResetCtl;              /* 0x00000068 */
+   u32 CpuMacUnitHssRegAccCtl;          /* 0x0000006c */
+   u32 CpuMacUnitHssRegAccResult;       /* 0x00000070 */
+   u32 CpuMacUnitAxiCfg;                /* 0x00000074 */
+   u32 CpuMacUnitTsCfg;                 /* 0x00000078 */
+   u32 CpuMacUnitFifoStatus;            /* 0x0000007c */
+   u32 CpuMacUnitTsMon[3];              /* 0x00000080 */
+   u32 rsv35;
+   u32 CpuMacUnitRefPulseCfg[4];        /* 0x00000090 */
+   u32 CpuMacUnitInterruptFunc[4];      /* 0x000000a0 */
+   u32 rsv44;
+   u32 rsv45;
+   u32 rsv46;
+   u32 rsv47;
+   u32 CpuMacUnitHssCfg[12];            /* 0x000000c0 */
+   u32 rsv60;
+   u32 rsv61;
+   u32 rsv62;
+   u32 rsv63;
+   u32 CpuMacUnitIpCamCfg[32];          /* 0x00000100 */
+   u32 CpuMacUnitMacCamCfg[32];         /* 0x00000180 */
+   u32 CpuMacUnitFilterCfg[6];          /* 0x00000200 */
+};
+
+/* ################################################################################
+ * # CpuMacUnitHssMon Definition
+ */
+#define CPU_MAC_UNIT_HSS_MON_W0_MON_HSS_CMU0_DBG_OBS                 BIT(0)
+#define CPU_MAC_UNIT_HSS_MON_W0_MON_HSS_CMU0_LOL                     BIT(16)
+#define CPU_MAC_UNIT_HSS_MON_W1_MON_HSS_L0_PMA2_PCS_TX_DET_RX_N      BIT(22)
+#define CPU_MAC_UNIT_HSS_MON_W1_MON_HSS_L0_PMA2_PCS_TX_DET_RX_P      BIT(23)
+#define CPU_MAC_UNIT_HSS_MON_W1_MON_HSS_L0_LOL_UDL                   BIT(20)
+#define CPU_MAC_UNIT_HSS_MON_W1_MON_HSS_L0_RX_EI                     BIT(18)
+#define CPU_MAC_UNIT_HSS_MON_W1_MON_HSS_L0_DBG_OBS                   BIT(0)
+#define CPU_MAC_UNIT_HSS_MON_W1_MON_HSS_L0_PMA_RST_DONE              BIT(17)
+#define CPU_MAC_UNIT_HSS_MON_W1_MON_HSS_L0_I_SCAN_DONE               BIT(21)
+#define CPU_MAC_UNIT_HSS_MON_W1_MON_HSS_L0_RX_EI_FILTERED            BIT(24)
+#define CPU_MAC_UNIT_HSS_MON_W1_MON_HSS_L0_LOL                       BIT(19)
+#define CPU_MAC_UNIT_HSS_MON_W1_MON_HSS_L0_DFE_RST_DONE              BIT(16)
+#define CPU_MAC_UNIT_HSS_MON_W2_MON_HSS_L0_I_SCAN_RESULTS_31_0       BIT(0)
+#define CPU_MAC_UNIT_HSS_MON_W3_MON_HSS_L0_I_SCAN_RESULTS_63_32      BIT(0)
+#define CPU_MAC_UNIT_HSS_MON_W4_MON_HSS_L1_PMA2_PCS_TX_DET_RX_P      BIT(23)
+#define CPU_MAC_UNIT_HSS_MON_W4_MON_HSS_L1_RX_EI_FILTERED            BIT(24)
+#define CPU_MAC_UNIT_HSS_MON_W4_MON_HSS_L1_I_SCAN_DONE               BIT(21)
+#define CPU_MAC_UNIT_HSS_MON_W4_MON_HSS_L1_PMA2_PCS_TX_DET_RX_N      BIT(22)
+#define CPU_MAC_UNIT_HSS_MON_W4_MON_HSS_L1_LOL                       BIT(19)
+#define CPU_MAC_UNIT_HSS_MON_W4_MON_HSS_L1_DFE_RST_DONE              BIT(16)
+#define CPU_MAC_UNIT_HSS_MON_W4_MON_HSS_L1_LOL_UDL                   BIT(20)
+#define CPU_MAC_UNIT_HSS_MON_W4_MON_HSS_L1_PMA_RST_DONE              BIT(17)
+#define CPU_MAC_UNIT_HSS_MON_W4_MON_HSS_L1_RX_EI                     BIT(18)
+#define CPU_MAC_UNIT_HSS_MON_W4_MON_HSS_L1_DBG_OBS                   BIT(0)
+#define CPU_MAC_UNIT_HSS_MON_W5_MON_HSS_L1_I_SCAN_RESULTS_31_0       BIT(0)
+#define CPU_MAC_UNIT_HSS_MON_W6_MON_HSS_L1_I_SCAN_RESULTS_63_32      BIT(0)
+
+#define CPU_MAC_UNIT_HSS_MON_W0_MON_HSS_CMU0_DBG_OBS_MASK            0x0000ffff
+#define CPU_MAC_UNIT_HSS_MON_W0_MON_HSS_CMU0_LOL_MASK                0x00010000
+#define CPU_MAC_UNIT_HSS_MON_W1_MON_HSS_L0_PMA2_PCS_TX_DET_RX_N_MASK 0x00400000
+#define CPU_MAC_UNIT_HSS_MON_W1_MON_HSS_L0_PMA2_PCS_TX_DET_RX_P_MASK 0x00800000
+#define CPU_MAC_UNIT_HSS_MON_W1_MON_HSS_L0_LOL_UDL_MASK              0x00100000
+#define CPU_MAC_UNIT_HSS_MON_W1_MON_HSS_L0_RX_EI_MASK                0x00040000
+#define CPU_MAC_UNIT_HSS_MON_W1_MON_HSS_L0_DBG_OBS_MASK              0x0000ffff
+#define CPU_MAC_UNIT_HSS_MON_W1_MON_HSS_L0_PMA_RST_DONE_MASK         0x00020000
+#define CPU_MAC_UNIT_HSS_MON_W1_MON_HSS_L0_I_SCAN_DONE_MASK          0x00200000
+#define CPU_MAC_UNIT_HSS_MON_W1_MON_HSS_L0_RX_EI_FILTERED_MASK       0x01000000
+#define CPU_MAC_UNIT_HSS_MON_W1_MON_HSS_L0_LOL_MASK                  0x00080000
+#define CPU_MAC_UNIT_HSS_MON_W1_MON_HSS_L0_DFE_RST_DONE_MASK         0x00010000
+#define CPU_MAC_UNIT_HSS_MON_W2_MON_HSS_L0_I_SCAN_RESULTS_31_0_MASK  0x00000001
+#define CPU_MAC_UNIT_HSS_MON_W3_MON_HSS_L0_I_SCAN_RESULTS_63_32_MASK 0x00000001
+#define CPU_MAC_UNIT_HSS_MON_W4_MON_HSS_L1_PMA2_PCS_TX_DET_RX_P_MASK 0x00800000
+#define CPU_MAC_UNIT_HSS_MON_W4_MON_HSS_L1_RX_EI_FILTERED_MASK       0x01000000
+#define CPU_MAC_UNIT_HSS_MON_W4_MON_HSS_L1_I_SCAN_DONE_MASK          0x00200000
+#define CPU_MAC_UNIT_HSS_MON_W4_MON_HSS_L1_PMA2_PCS_TX_DET_RX_N_MASK 0x00400000
+#define CPU_MAC_UNIT_HSS_MON_W4_MON_HSS_L1_LOL_MASK                  0x00080000
+#define CPU_MAC_UNIT_HSS_MON_W4_MON_HSS_L1_DFE_RST_DONE_MASK         0x00010000
+#define CPU_MAC_UNIT_HSS_MON_W4_MON_HSS_L1_LOL_UDL_MASK              0x00100000
+#define CPU_MAC_UNIT_HSS_MON_W4_MON_HSS_L1_PMA_RST_DONE_MASK         0x00020000
+#define CPU_MAC_UNIT_HSS_MON_W4_MON_HSS_L1_RX_EI_MASK                0x00040000
+#define CPU_MAC_UNIT_HSS_MON_W4_MON_HSS_L1_DBG_OBS_MASK              0x0000ffff
+#define CPU_MAC_UNIT_HSS_MON_W5_MON_HSS_L1_I_SCAN_RESULTS_31_0_MASK  0x00000001
+#define CPU_MAC_UNIT_HSS_MON_W6_MON_HSS_L1_I_SCAN_RESULTS_63_32_MASK 0x00000001
+
+/* ################################################################################
+ * # CpuMacHssRegAccTimingCfg Definition
+ */
+#define CPU_MAC_HSS_REG_ACC_TIMING_CFG_W0_CFG_ACTIVE_CYCLES          BIT(0)
+#define CPU_MAC_HSS_REG_ACC_TIMING_CFG_W0_CFG_HOLD_CYCLES            BIT(8)
+#define CPU_MAC_HSS_REG_ACC_TIMING_CFG_W1_CFG_RD_OUT_VALID_CYCLES    BIT(8)
+#define CPU_MAC_HSS_REG_ACC_TIMING_CFG_W1_CFG_SETUP_CYCLES           BIT(0)
+
+#define CPU_MAC_HSS_REG_ACC_TIMING_CFG_W0_CFG_ACTIVE_CYCLES_MASK     0x000000ff
+#define CPU_MAC_HSS_REG_ACC_TIMING_CFG_W0_CFG_HOLD_CYCLES_MASK       0x0000ff00
+#define CPU_MAC_HSS_REG_ACC_TIMING_CFG_W1_CFG_RD_OUT_VALID_CYCLES_MASK 0x0000ff00
+#define CPU_MAC_HSS_REG_ACC_TIMING_CFG_W1_CFG_SETUP_CYCLES_MASK      0x000000ff
+
+/* ################################################################################
+ * # CpuMacUnitResetCtl Definition
+ */
+#define CPU_MAC_UNIT_RESET_CTL_W0_RESET_CORE_CPU_MAC1                BIT(1)
+#define CPU_MAC_UNIT_RESET_CTL_W0_RESET_CORE_CPU_MAC0                BIT(2)
+#define CPU_MAC_UNIT_RESET_CTL_W0_RESET_CORE_BASE                    BIT(0)
+
+#define CPU_MAC_UNIT_RESET_CTL_W0_RESET_CORE_CPU_MAC1_MASK           0x00000002
+#define CPU_MAC_UNIT_RESET_CTL_W0_RESET_CORE_CPU_MAC0_MASK           0x00000004
+#define CPU_MAC_UNIT_RESET_CTL_W0_RESET_CORE_BASE_MASK               0x00000001
+
+/* ################################################################################
+ * # CpuMacUnitHssRegAccCtl Definition
+ */
+#define CPU_MAC_UNIT_HSS_REG_ACC_CTL_W0_HSS_ACC_WDATA                BIT(8)
+#define CPU_MAC_UNIT_HSS_REG_ACC_CTL_W0_HSS_ACC_VALID                BIT(31)
+#define CPU_MAC_UNIT_HSS_REG_ACC_CTL_W0_HSS_ACC_ADDR                 BIT(0)
+#define CPU_MAC_UNIT_HSS_REG_ACC_CTL_W0_HSS_ACC_IS_READ              BIT(16)
+#define CPU_MAC_UNIT_HSS_REG_ACC_CTL_W0_HSS_ACC_ID                   BIT(24)
+
+#define CPU_MAC_UNIT_HSS_REG_ACC_CTL_W0_HSS_ACC_WDATA_MASK           0x0000ff00
+#define CPU_MAC_UNIT_HSS_REG_ACC_CTL_W0_HSS_ACC_VALID_MASK           0x80000000
+#define CPU_MAC_UNIT_HSS_REG_ACC_CTL_W0_HSS_ACC_ADDR_MASK            0x000000ff
+#define CPU_MAC_UNIT_HSS_REG_ACC_CTL_W0_HSS_ACC_IS_READ_MASK         0x00010000
+#define CPU_MAC_UNIT_HSS_REG_ACC_CTL_W0_HSS_ACC_ID_MASK              0x0f000000
+
+/* ################################################################################
+ * # CpuMacUnitHssRegAccResult Definition
+ */
+#define CPU_MAC_UNIT_HSS_REG_ACC_RESULT_W0_HSS_ACC_ACK               BIT(31)
+#define CPU_MAC_UNIT_HSS_REG_ACC_RESULT_W0_HSS_ACC_ACK_DATA          BIT(0)
+
+#define CPU_MAC_UNIT_HSS_REG_ACC_RESULT_W0_HSS_ACC_ACK_MASK          0x80000000
+#define CPU_MAC_UNIT_HSS_REG_ACC_RESULT_W0_HSS_ACC_ACK_DATA_MASK     0x000000ff
+
+/* ################################################################################
+ * # CpuMacUnitAxiCfg Definition
+ */
+#define CPU_MAC_UNIT_AXI_CFG_W0_CFG_AXI0_ID                          BIT(0)
+#define CPU_MAC_UNIT_AXI_CFG_W0_CFG_AXI1_ID                          BIT(4)
+
+#define CPU_MAC_UNIT_AXI_CFG_W0_CFG_AXI0_ID_MASK                     0x0000000f
+#define CPU_MAC_UNIT_AXI_CFG_W0_CFG_AXI1_ID_MASK                     0x000000f0
+
+/* ################################################################################
+ * # CpuMacUnitTsCfg Definition
+ */
+#define CPU_MAC_UNIT_TS_CFG_W0_CFG_TX_CAPTURE_FIFO_INTR_THRD         BIT(0)
+#define CPU_MAC_UNIT_TS_CFG_W0_CFG_FORCE_S_AND_NS_EN                 BIT(31)
+
+#define CPU_MAC_UNIT_TS_CFG_W0_CFG_TX_CAPTURE_FIFO_INTR_THRD_MASK    0x0000000f
+#define CPU_MAC_UNIT_TS_CFG_W0_CFG_FORCE_S_AND_NS_EN_MASK            0x80000000
+
+/* ################################################################################
+ * # CpuMacUnitFifoStatus Definition
+ */
+#define CPU_MAC_UNIT_FIFO_STATUS_W0_CPU_MAC_UNIT_TX_TS_CAPTURE_FIFO_FIFO_DEPTH BIT(0)
+
+#define CPU_MAC_UNIT_FIFO_STATUS_W0_CPU_MAC_UNIT_TX_TS_CAPTURE_FIFO_FIFO_DEPTH_MASK 0x0000000f
+
+/* ################################################################################
+ * # CpuMacUnitTsMon Definition
+ */
+#define CPU_MAC_UNIT_TS_MON_W0_MON_ADJ_NS                            BIT(0)
+#define CPU_MAC_UNIT_TS_MON_W1_MON_ADJ_SECOND                        BIT(0)
+#define CPU_MAC_UNIT_TS_MON_W2_MON_TX_CAPTURE_FIFO_DROP_CNT          BIT(0)
+
+#define CPU_MAC_UNIT_TS_MON_W0_MON_ADJ_NS_MASK                       0x3fffffff
+#define CPU_MAC_UNIT_TS_MON_W1_MON_ADJ_SECOND_MASK                   0xffffffff
+#define CPU_MAC_UNIT_TS_MON_W2_MON_TX_CAPTURE_FIFO_DROP_CNT_MASK     0x0000000f
+
+/* ################################################################################
+ * # CpuMacUnitRefPulseCfg Definition
+ */
+#define CPU_MAC_UNIT_REF_PULSE_CFG_W0_REF_PAUSE_TIMER_PULSE_DIV      BIT(0)
+#define CPU_MAC_UNIT_REF_PULSE_CFG_W0_REF_PAUSE_TIMER_PULSE_RST      BIT(31)
+#define CPU_MAC_UNIT_REF_PULSE_CFG_W1_REF_LINK_PULSE_DIV             BIT(0)
+#define CPU_MAC_UNIT_REF_PULSE_CFG_W1_REF_LINK_PULSE_RST             BIT(31)
+#define CPU_MAC_UNIT_REF_PULSE_CFG_W2_REF_LINK_FILTER_PULSE_RST      BIT(31)
+#define CPU_MAC_UNIT_REF_PULSE_CFG_W2_REF_LINK_FILTER_PULSE_DIV      BIT(0)
+#define CPU_MAC_UNIT_REF_PULSE_CFG_W3_REF_EEE_PULSE_DIV              BIT(0)
+#define CPU_MAC_UNIT_REF_PULSE_CFG_W3_REF_EEE_PULSE_RST              BIT(31)
+
+#define CPU_MAC_UNIT_REF_PULSE_CFG_W0_REF_PAUSE_TIMER_PULSE_DIV_MASK 0x7fffffff
+#define CPU_MAC_UNIT_REF_PULSE_CFG_W0_REF_PAUSE_TIMER_PULSE_RST_MASK 0x80000000
+#define CPU_MAC_UNIT_REF_PULSE_CFG_W1_REF_LINK_PULSE_DIV_MASK        0x7fffffff
+#define CPU_MAC_UNIT_REF_PULSE_CFG_W1_REF_LINK_PULSE_RST_MASK        0x80000000
+#define CPU_MAC_UNIT_REF_PULSE_CFG_W2_REF_LINK_FILTER_PULSE_RST_MASK 0x80000000
+#define CPU_MAC_UNIT_REF_PULSE_CFG_W2_REF_LINK_FILTER_PULSE_DIV_MASK 0x7fffffff
+#define CPU_MAC_UNIT_REF_PULSE_CFG_W3_REF_EEE_PULSE_DIV_MASK         0x7fffffff
+#define CPU_MAC_UNIT_REF_PULSE_CFG_W3_REF_EEE_PULSE_RST_MASK         0x80000000
+
+/* ################################################################################
+ * # CpuMacUnitInterruptFunc Definition
+ */
+#define CPU_MAC_UNIT_INTERRUPT_FUNC_W0_VALUE_SET0_CPU_MAC_UNIT_INTERRUPT_FUNC BIT(0)
+#define CPU_MAC_UNIT_INTERRUPT_FUNC_W1_VALUE_RESET0_CPU_MAC_UNIT_INTERRUPT_FUNC BIT(0)
+#define CPU_MAC_UNIT_INTERRUPT_FUNC_W2_MASK_SET0_CPU_MAC_UNIT_INTERRUPT_FUNC BIT(0)
+#define CPU_MAC_UNIT_INTERRUPT_FUNC_W3_MASK_RESET0_CPU_MAC_UNIT_INTERRUPT_FUNC BIT(0)
+
+#define CPU_MAC_UNIT_INTERRUPT_FUNC_W0_VALUE_SET0_CPU_MAC_UNIT_INTERRUPT_FUNC_MASK 0x00000001
+#define CPU_MAC_UNIT_INTERRUPT_FUNC_W1_VALUE_RESET0_CPU_MAC_UNIT_INTERRUPT_FUNC_MASK 0x00000001
+#define CPU_MAC_UNIT_INTERRUPT_FUNC_W2_MASK_SET0_CPU_MAC_UNIT_INTERRUPT_FUNC_MASK 0x00000001
+#define CPU_MAC_UNIT_INTERRUPT_FUNC_W3_MASK_RESET0_CPU_MAC_UNIT_INTERRUPT_FUNC_MASK 0x00000001
+
+/* ################################################################################
+ * # CpuMacUnitHssCfg Definition
+ */
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_BCLK_RST_N_BIT               1
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_HWT_BIAS_DN_EN_BIT      13
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_HWT_BIAS_UP_EN_BIT      14
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_HWT_CFG_DIV_SEL_BIT     5
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_HWT_CK_TREE_PD_BIT      29
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_HWT_EN_TX_CK_DN_BIT     24
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_HWT_EN_TX_CK_UP_BIT     23
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_HWT_IBIAS_PD_BIT        26
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_HWT_LINK_BUF_EN_BIT     16
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_HWT_MULTI_LANE_MODE_BIT 12
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_HWT_PMA_TX_CK_PD_BIT    31
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_HWT_REFCK_PD_BIT        30
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_HWT_REFCK_TERM_EN_BIT   25
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_HWT_RST_TREE_PD_MA_BIT  27
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_HWT_VCO_DIV_SEL_BIT     2
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_HWT_VCO_PD_BIT          28
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_PCLK_GATING_BIT         15
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_PCS2_PMA_PHY_MODE_BIT   18
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_REXT10_K_BIT            11
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_RST_N_BIT               17
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_GLB_RST_N_BIT                0
+#define CPU_MAC_UNIT_HSS_CFG_W1_CFG_HSS_CMU0_HWT_CTRL_LOGIC_PD_BIT   28
+#define CPU_MAC_UNIT_HSS_CFG_W1_CFG_HSS_CMU0_HWT_EN_DUMMY_BIT        29
+#define CPU_MAC_UNIT_HSS_CFG_W1_CFG_HSS_CMU0_HWT_PD_DIV64_BIT        26
+#define CPU_MAC_UNIT_HSS_CFG_W1_CFG_HSS_CMU0_HWT_PD_DIV66_BIT        27
+#define CPU_MAC_UNIT_HSS_CFG_W1_CFG_HSS_CMU0_HWT_REF_CK_CENTER_SPREAD_BIT 25
+#define CPU_MAC_UNIT_HSS_CFG_W1_CFG_HSS_CMU0_HWT_REF_CK_MCNT_MAX_VAL_BIT 9
+#define CPU_MAC_UNIT_HSS_CFG_W1_CFG_HSS_CMU0_HWT_REF_CK_NCN_MAX_VAL_BIT 14
+#define CPU_MAC_UNIT_HSS_CFG_W1_CFG_HSS_CMU0_HWT_REF_CK_RES_EN_BIT   2
+#define CPU_MAC_UNIT_HSS_CFG_W1_CFG_HSS_CMU0_HWT_REF_CK_SRC_SEL_BIT  3
+#define CPU_MAC_UNIT_HSS_CFG_W1_CFG_HSS_CMU0_HWT_REF_CK_SSC_PI_BW_BIT 6
+#define CPU_MAC_UNIT_HSS_CFG_W1_CFG_HSS_CMU0_HWT_REF_CK_SSC_PI_STEP_BIT 4
+#define CPU_MAC_UNIT_HSS_CFG_W1_CFG_HSS_CMU0_HWT_REF_CK_SSC_RESET_N_BIT 1
+#define CPU_MAC_UNIT_HSS_CFG_W1_CFG_HSS_CMU0_HWT_REF_CK_SSC_RTL_CLK_SEL_BIT 0
+#define CPU_MAC_UNIT_HSS_CFG_W2_CFG_HSS_L0_AUX_RX_CK_SEL_BIT         2
+#define CPU_MAC_UNIT_HSS_CFG_W2_CFG_HSS_L0_AUX_TX_CK_SEL_BIT         1
+#define CPU_MAC_UNIT_HSS_CFG_W2_CFG_HSS_L0_DATA_WIDTH_SEL_BIT        7
+#define CPU_MAC_UNIT_HSS_CFG_W2_CFG_HSS_L0_HWT_MULTI_LANE_MODE_BIT   3
+#define CPU_MAC_UNIT_HSS_CFG_W2_CFG_HSS_L0_LANE_ID_BIT               4
+#define CPU_MAC_UNIT_HSS_CFG_W2_CFG_HSS_L0_PCS2_PMA_PHY_MODE_BIT     22
+#define CPU_MAC_UNIT_HSS_CFG_W2_CFG_HSS_L0_PCS2_PMA_TX_SWING_BIT     31
+#define CPU_MAC_UNIT_HSS_CFG_W2_CFG_HSS_L0_PCS2_PMA_VGA_CTRL_BIT     27
+#define CPU_MAC_UNIT_HSS_CFG_W2_CFG_HSS_L0_PMA_RX_DIV_SEL_BIT        19
+#define CPU_MAC_UNIT_HSS_CFG_W2_CFG_HSS_L0_PMA_TX_CK_SEL_BIT         13
+#define CPU_MAC_UNIT_HSS_CFG_W2_CFG_HSS_L0_RST_N_BIT                 0
+#define CPU_MAC_UNIT_HSS_CFG_W2_CFG_HSS_L0_RX_RATE_SEL_BIT           17
+#define CPU_MAC_UNIT_HSS_CFG_W2_CFG_HSS_L0_RX_RST_N_BIT              16
+#define CPU_MAC_UNIT_HSS_CFG_W2_CFG_HSS_L0_TX_RATE_SEL_BIT           11
+#define CPU_MAC_UNIT_HSS_CFG_W2_CFG_HSS_L0_TX_RST_N_BIT              10
+#define CPU_MAC_UNIT_HSS_CFG_W3_CFG_HSS_L0_HWT_FOM_SEL_BIT           19
+#define CPU_MAC_UNIT_HSS_CFG_W3_CFG_HSS_L0_PCS2_PMA_PI_EXT_DAC_BIT20_TO14_BIT 20
+#define CPU_MAC_UNIT_HSS_CFG_W3_CFG_HSS_L0_PCS2_PMA_PI_EXT_DAC_BIT23_TO21_BIT 27
+#define CPU_MAC_UNIT_HSS_CFG_W3_CFG_HSS_L0_PCS2_PMA_TX_EI_BIT        18
+#define CPU_MAC_UNIT_HSS_CFG_W3_CFG_HSS_L0_PCS_EN_ADV_BIT            9
+#define CPU_MAC_UNIT_HSS_CFG_W3_CFG_HSS_L0_PCS_EN_DLY_BIT            8
+#define CPU_MAC_UNIT_HSS_CFG_W3_CFG_HSS_L0_PCS_EN_MAIN_BIT           7
+#define CPU_MAC_UNIT_HSS_CFG_W3_CFG_HSS_L0_PCS_I_SCAN_EN_BIT         6
+#define CPU_MAC_UNIT_HSS_CFG_W3_CFG_HSS_L0_PCS_TAP_ADV_BIT           1
+#define CPU_MAC_UNIT_HSS_CFG_W3_CFG_HSS_L0_PCS_TAP_DLY_BIT           10
+#define CPU_MAC_UNIT_HSS_CFG_W3_CFG_HSS_L0_PCS_TAP_MAIN_BIT          0
+#define CPU_MAC_UNIT_HSS_CFG_W4_CFG_HSS_L0_PCS2_PMA_ITX_PREEMP_BASE_BIT 30
+#define CPU_MAC_UNIT_HSS_CFG_W4_CFG_HSS_L0_PCS2_PMA_MCNT_MAX_VAL_BIT 25
+#define CPU_MAC_UNIT_HSS_CFG_W4_CFG_HSS_L0_PCS2_PMA_PI_FLOOP_STEPS_BIT 23
+#define CPU_MAC_UNIT_HSS_CFG_W4_CFG_HSS_L0_PCS2_PMA_RX_SSC_LH_BIT    22
+#define CPU_MAC_UNIT_HSS_CFG_W4_CFG_HSS_L0_PCS2_PMA_SSC_EN_BIT       21
+#define CPU_MAC_UNIT_HSS_CFG_W4_CFG_HSS_L0_PCS2_PMA_SSC_PI_BW_BIT    17
+#define CPU_MAC_UNIT_HSS_CFG_W4_CFG_HSS_L0_PCS2_PMA_SSC_PI_STEP_BIT  15
+#define CPU_MAC_UNIT_HSS_CFG_W4_CFG_HSS_L0_PCS2_PMA_SSC_RESETB_BIT   14
+#define CPU_MAC_UNIT_HSS_CFG_W4_CFG_HSS_L0_PCS2_PMA_SSC_RTL_CLK_SEL_BIT 13
+#define CPU_MAC_UNIT_HSS_CFG_W4_CFG_HSS_L0_PCS2_PMA_TX_DET_RX_EN_BIT 12
+#define CPU_MAC_UNIT_HSS_CFG_W4_CFG_HSS_L0_PCS2_PMA_TX_DET_RX_STR_BIT 11
+#define CPU_MAC_UNIT_HSS_CFG_W4_CFG_HSS_L0_PCS2_PMANCNT_MAX_VAL_BIT  0
+#define CPU_MAC_UNIT_HSS_CFG_W5_CFG_HSS_L0_PCS2_PMA_EN_PRE_EMPH_BIT  31
+#define CPU_MAC_UNIT_HSS_CFG_W5_CFG_HSS_L0_PCS2_PMA_EQC_FORCE_BIT    27
+#define CPU_MAC_UNIT_HSS_CFG_W5_CFG_HSS_L0_PCS2_PMA_EQR_BYP_BIT      26
+#define CPU_MAC_UNIT_HSS_CFG_W5_CFG_HSS_L0_PCS2_PMA_ISCAN_EXT_DAC_BIT7_BIT 25
+#define CPU_MAC_UNIT_HSS_CFG_W5_CFG_HSS_L0_PCS2_PMA_POWER_CTRL_BIT   0
+#define CPU_MAC_UNIT_HSS_CFG_W6_CFG_HSS_L0_FORCE_SIGNAL_DETECT_BIT   31
+#define CPU_MAC_UNIT_HSS_CFG_W6_CFG_HSS_L0_PCLK_GATING_BIT           7
+#define CPU_MAC_UNIT_HSS_CFG_W6_CFG_HSS_L0_PCS2_PMA_CENTER_SPREADING_BIT 6
+#define CPU_MAC_UNIT_HSS_CFG_W6_CFG_HSS_L0_PCS2_PMA_CTLE_RSTN_BIT    17
+#define CPU_MAC_UNIT_HSS_CFG_W6_CFG_HSS_L0_PCS2_PMA_DIS2ND_ORDER_BIT 5
+#define CPU_MAC_UNIT_HSS_CFG_W6_CFG_HSS_L0_PCS2_PMA_EID_LP_BIT       18
+#define CPU_MAC_UNIT_HSS_CFG_W6_CFG_HSS_L0_PCS2_PMA_EN_DFE_DIG_BIT   4
+#define CPU_MAC_UNIT_HSS_CFG_W6_CFG_HSS_L0_PCS2_PMA_EQ_RES_BIT       0
+#define CPU_MAC_UNIT_HSS_CFG_W6_CFG_HSS_L0_PCS2_PMA_HOLD_DFE_BIT     22
+#define CPU_MAC_UNIT_HSS_CFG_W6_CFG_HSS_L0_PCS2_PMA_ISCAN_SEL_BIT    19
+#define CPU_MAC_UNIT_HSS_CFG_W6_CFG_HSS_L0_PCS2_PMA_PI_HOLD_BIT      20
+#define CPU_MAC_UNIT_HSS_CFG_W6_CFG_HSS_L0_PCS2_PMA_R50_EN_BIT       21
+#define CPU_MAC_UNIT_HSS_CFG_W6_CFG_HSS_L0_PCS2_PMA_TX_MARGIN_BIT    8
+#define CPU_MAC_UNIT_HSS_CFG_W7_CFG_HSS_L0_PCS2_PMA_DLEV_BIT         23
+#define CPU_MAC_UNIT_HSS_CFG_W7_CFG_HSS_L0_PCS2_PMA_DLEV_BYP_BIT     31
+#define CPU_MAC_UNIT_HSS_CFG_W7_CFG_HSS_L0_PCS2_PMA_H1_BIT           0
+#define CPU_MAC_UNIT_HSS_CFG_W7_CFG_HSS_L0_PCS2_PMA_H2_BIT           6
+#define CPU_MAC_UNIT_HSS_CFG_W7_CFG_HSS_L0_PCS2_PMA_H3_BIT           11
+#define CPU_MAC_UNIT_HSS_CFG_W7_CFG_HSS_L0_PCS2_PMA_H4_BIT           15
+#define CPU_MAC_UNIT_HSS_CFG_W7_CFG_HSS_L0_PCS2_PMA_H5_BIT           19
+#define CPU_MAC_UNIT_HSS_CFG_W7_CFG_HSS_L0_PCS2_PMA_H_BYP_BIT        30
+#define CPU_MAC_UNIT_HSS_CFG_W8_CFG_HSS_L1_AUX_RX_CK_SEL_BIT         2
+#define CPU_MAC_UNIT_HSS_CFG_W8_CFG_HSS_L1_AUX_TX_CK_SEL_BIT         1
+#define CPU_MAC_UNIT_HSS_CFG_W8_CFG_HSS_L1_DATA_WIDTH_SEL_BIT        7
+#define CPU_MAC_UNIT_HSS_CFG_W8_CFG_HSS_L1_HWT_MULTI_LANE_MODE_BIT   3
+#define CPU_MAC_UNIT_HSS_CFG_W8_CFG_HSS_L1_LANE_ID_BIT               4
+#define CPU_MAC_UNIT_HSS_CFG_W8_CFG_HSS_L1_PCS2_PMA_PHY_MODE_BIT     22
+#define CPU_MAC_UNIT_HSS_CFG_W8_CFG_HSS_L1_PCS2_PMA_TX_SWING_BIT     31
+#define CPU_MAC_UNIT_HSS_CFG_W8_CFG_HSS_L1_PCS2_PMA_VGA_CTRL_BIT     27
+#define CPU_MAC_UNIT_HSS_CFG_W8_CFG_HSS_L1_PMA_RX_DIV_SEL_BIT        19
+#define CPU_MAC_UNIT_HSS_CFG_W8_CFG_HSS_L1_PMA_TX_CK_SEL_BIT         13
+#define CPU_MAC_UNIT_HSS_CFG_W8_CFG_HSS_L1_RST_N_BIT                 0
+#define CPU_MAC_UNIT_HSS_CFG_W8_CFG_HSS_L1_RX_RATE_SEL_BIT           17
+#define CPU_MAC_UNIT_HSS_CFG_W8_CFG_HSS_L1_RX_RST_N_BIT              16
+#define CPU_MAC_UNIT_HSS_CFG_W8_CFG_HSS_L1_TX_RATE_SEL_BIT           11
+#define CPU_MAC_UNIT_HSS_CFG_W8_CFG_HSS_L1_TX_RST_N_BIT              10
+#define CPU_MAC_UNIT_HSS_CFG_W9_CFG_HSS_L1_HWT_FOM_SEL_BIT           19
+#define CPU_MAC_UNIT_HSS_CFG_W9_CFG_HSS_L1_PCS2_PMA_PI_EXT_DAC_BIT20_TO14_BIT 20
+#define CPU_MAC_UNIT_HSS_CFG_W9_CFG_HSS_L1_PCS2_PMA_PI_EXT_DAC_BIT23_TO21_BIT 27
+#define CPU_MAC_UNIT_HSS_CFG_W9_CFG_HSS_L1_PCS2_PMA_TX_EI_BIT        18
+#define CPU_MAC_UNIT_HSS_CFG_W9_CFG_HSS_L1_PCS_EN_ADV_BIT            9
+#define CPU_MAC_UNIT_HSS_CFG_W9_CFG_HSS_L1_PCS_EN_DLY_BIT            8
+#define CPU_MAC_UNIT_HSS_CFG_W9_CFG_HSS_L1_PCS_EN_MAIN_BIT           7
+#define CPU_MAC_UNIT_HSS_CFG_W9_CFG_HSS_L1_PCS_I_SCAN_EN_BIT         6
+#define CPU_MAC_UNIT_HSS_CFG_W9_CFG_HSS_L1_PCS_TAP_ADV_BIT           1
+#define CPU_MAC_UNIT_HSS_CFG_W9_CFG_HSS_L1_PCS_TAP_DLY_BIT           10
+#define CPU_MAC_UNIT_HSS_CFG_W9_CFG_HSS_L1_PCS_TAP_MAIN_BIT          0
+#define CPU_MAC_UNIT_HSS_CFG_W10_CFG_HSS_L1_PCS2_PMA_ITX_PREEMP_BASE_BIT 30
+#define CPU_MAC_UNIT_HSS_CFG_W10_CFG_HSS_L1_PCS2_PMA_MCNT_MAX_VAL_BIT 25
+#define CPU_MAC_UNIT_HSS_CFG_W10_CFG_HSS_L1_PCS2_PMA_PI_FLOOP_STEPS_BIT 23
+#define CPU_MAC_UNIT_HSS_CFG_W10_CFG_HSS_L1_PCS2_PMA_RX_SSC_LH_BIT   22
+#define CPU_MAC_UNIT_HSS_CFG_W10_CFG_HSS_L1_PCS2_PMA_SSC_EN_BIT      21
+#define CPU_MAC_UNIT_HSS_CFG_W10_CFG_HSS_L1_PCS2_PMA_SSC_PI_BW_BIT   17
+#define CPU_MAC_UNIT_HSS_CFG_W10_CFG_HSS_L1_PCS2_PMA_SSC_PI_STEP_BIT 15
+#define CPU_MAC_UNIT_HSS_CFG_W10_CFG_HSS_L1_PCS2_PMA_SSC_RESETB_BIT  14
+#define CPU_MAC_UNIT_HSS_CFG_W10_CFG_HSS_L1_PCS2_PMA_SSC_RTL_CLK_SEL_BIT 13
+#define CPU_MAC_UNIT_HSS_CFG_W10_CFG_HSS_L1_PCS2_PMA_TX_DET_RX_EN_BIT 12
+#define CPU_MAC_UNIT_HSS_CFG_W10_CFG_HSS_L1_PCS2_PMA_TX_DET_RX_STR_BIT 11
+#define CPU_MAC_UNIT_HSS_CFG_W10_CFG_HSS_L1_PCS2_PMANCNT_MAX_VAL_BIT 0
+#define CPU_MAC_UNIT_HSS_CFG_W11_CFG_HSS_L1_PCS2_PMA_EN_PRE_EMPH_BIT 31
+#define CPU_MAC_UNIT_HSS_CFG_W11_CFG_HSS_L1_PCS2_PMA_EQC_FORCE_BIT   27
+#define CPU_MAC_UNIT_HSS_CFG_W11_CFG_HSS_L1_PCS2_PMA_EQR_BYP_BIT     26
+#define CPU_MAC_UNIT_HSS_CFG_W11_CFG_HSS_L1_PCS2_PMA_ISCAN_EXT_DAC_BIT7_BIT 25
+#define CPU_MAC_UNIT_HSS_CFG_W11_CFG_HSS_L1_PCS2_PMA_POWER_CTRL_BIT  0
+#define CPU_MAC_UNIT_HSS_CFG_W12_CFG_HSS_L1_FORCE_SIGNAL_DETECT_BIT  31
+#define CPU_MAC_UNIT_HSS_CFG_W12_CFG_HSS_L1_PCLK_GATING_BIT          7
+#define CPU_MAC_UNIT_HSS_CFG_W12_CFG_HSS_L1_PCS2_PMA_CENTER_SPREADING_BIT 6
+#define CPU_MAC_UNIT_HSS_CFG_W12_CFG_HSS_L1_PCS2_PMA_CTLE_RSTN_BIT   17
+#define CPU_MAC_UNIT_HSS_CFG_W12_CFG_HSS_L1_PCS2_PMA_DIS2ND_ORDER_BIT 5
+#define CPU_MAC_UNIT_HSS_CFG_W12_CFG_HSS_L1_PCS2_PMA_EID_LP_BIT      18
+#define CPU_MAC_UNIT_HSS_CFG_W12_CFG_HSS_L1_PCS2_PMA_EN_DFE_DIG_BIT  4
+#define CPU_MAC_UNIT_HSS_CFG_W12_CFG_HSS_L1_PCS2_PMA_EQ_RES_BIT      0
+#define CPU_MAC_UNIT_HSS_CFG_W12_CFG_HSS_L1_PCS2_PMA_HOLD_DFE_BIT    22
+#define CPU_MAC_UNIT_HSS_CFG_W12_CFG_HSS_L1_PCS2_PMA_ISCAN_SEL_BIT   19
+#define CPU_MAC_UNIT_HSS_CFG_W12_CFG_HSS_L1_PCS2_PMA_PI_HOLD_BIT     20
+#define CPU_MAC_UNIT_HSS_CFG_W12_CFG_HSS_L1_PCS2_PMA_R50_EN_BIT      21
+#define CPU_MAC_UNIT_HSS_CFG_W12_CFG_HSS_L1_PCS2_PMA_TX_MARGIN_BIT   8
+#define CPU_MAC_UNIT_HSS_CFG_W13_CFG_HSS_L1_PCS2_PMA_DLEV_BIT        23
+#define CPU_MAC_UNIT_HSS_CFG_W13_CFG_HSS_L1_PCS2_PMA_DLEV_BYP_BIT    31
+#define CPU_MAC_UNIT_HSS_CFG_W13_CFG_HSS_L1_PCS2_PMA_H1_BIT          0
+#define CPU_MAC_UNIT_HSS_CFG_W13_CFG_HSS_L1_PCS2_PMA_H2_BIT          6
+#define CPU_MAC_UNIT_HSS_CFG_W13_CFG_HSS_L1_PCS2_PMA_H3_BIT          11
+#define CPU_MAC_UNIT_HSS_CFG_W13_CFG_HSS_L1_PCS2_PMA_H4_BIT          15
+#define CPU_MAC_UNIT_HSS_CFG_W13_CFG_HSS_L1_PCS2_PMA_H5_BIT          19
+#define CPU_MAC_UNIT_HSS_CFG_W13_CFG_HSS_L1_PCS2_PMA_H_BYP_BIT       30
+
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_BCLK_RST_N_MASK              0x00000002
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_HWT_BIAS_DN_EN_MASK     0x00002000
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_HWT_BIAS_UP_EN_MASK     0x00004000
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_HWT_CFG_DIV_SEL_MASK    0x000007e0
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_HWT_CK_TREE_PD_MASK     0x20000000
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_HWT_EN_TX_CK_DN_MASK    0x01000000
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_HWT_EN_TX_CK_UP_MASK    0x00800000
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_HWT_IBIAS_PD_MASK       0x04000000
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_HWT_LINK_BUF_EN_MASK    0x00010000
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_HWT_MULTI_LANE_MODE_MASK 0x00001000
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_HWT_PMA_TX_CK_PD_MASK   0x80000000
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_HWT_REFCK_PD_MASK       0x40000000
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_HWT_REFCK_TERM_EN_MASK  0x02000000
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_HWT_RST_TREE_PD_MA_MASK 0x08000000
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_HWT_VCO_DIV_SEL_MASK    0x0000001c
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_HWT_VCO_PD_MASK         0x10000000
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_PCLK_GATING_MASK        0x00008000
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_PCS2_PMA_PHY_MODE_MASK  0x007c0000
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_REXT10_K_MASK           0x00000800
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_CMU0_RST_N_MASK              0x00020000
+#define CPU_MAC_UNIT_HSS_CFG_W0_CFG_HSS_GLB_RST_N_MASK               0x00000001
+#define CPU_MAC_UNIT_HSS_CFG_W1_CFG_HSS_CMU0_HWT_CTRL_LOGIC_PD_MASK  0x10000000
+#define CPU_MAC_UNIT_HSS_CFG_W1_CFG_HSS_CMU0_HWT_EN_DUMMY_MASK       0x20000000
+#define CPU_MAC_UNIT_HSS_CFG_W1_CFG_HSS_CMU0_HWT_PD_DIV64_MASK       0x04000000
+#define CPU_MAC_UNIT_HSS_CFG_W1_CFG_HSS_CMU0_HWT_PD_DIV66_MASK       0x08000000
+#define CPU_MAC_UNIT_HSS_CFG_W1_CFG_HSS_CMU0_HWT_REF_CK_CENTER_SPREAD_MASK 0x02000000
+#define CPU_MAC_UNIT_HSS_CFG_W1_CFG_HSS_CMU0_HWT_REF_CK_MCNT_MAX_VAL_MASK 0x00003e00
+#define CPU_MAC_UNIT_HSS_CFG_W1_CFG_HSS_CMU0_HWT_REF_CK_NCN_MAX_VAL_MASK 0x01ffc000
+#define CPU_MAC_UNIT_HSS_CFG_W1_CFG_HSS_CMU0_HWT_REF_CK_RES_EN_MASK  0x00000004
+#define CPU_MAC_UNIT_HSS_CFG_W1_CFG_HSS_CMU0_HWT_REF_CK_SRC_SEL_MASK 0x00000008
+#define CPU_MAC_UNIT_HSS_CFG_W1_CFG_HSS_CMU0_HWT_REF_CK_SSC_PI_BW_MASK 0x000001c0
+#define CPU_MAC_UNIT_HSS_CFG_W1_CFG_HSS_CMU0_HWT_REF_CK_SSC_PI_STEP_MASK 0x00000030
+#define CPU_MAC_UNIT_HSS_CFG_W1_CFG_HSS_CMU0_HWT_REF_CK_SSC_RESET_N_MASK 0x00000002
+#define CPU_MAC_UNIT_HSS_CFG_W1_CFG_HSS_CMU0_HWT_REF_CK_SSC_RTL_CLK_SEL_MASK 0x00000001
+#define CPU_MAC_UNIT_HSS_CFG_W2_CFG_HSS_L0_AUX_RX_CK_SEL_MASK        0x00000004
+#define CPU_MAC_UNIT_HSS_CFG_W2_CFG_HSS_L0_AUX_TX_CK_SEL_MASK        0x00000002
+#define CPU_MAC_UNIT_HSS_CFG_W2_CFG_HSS_L0_DATA_WIDTH_SEL_MASK       0x00000380
+#define CPU_MAC_UNIT_HSS_CFG_W2_CFG_HSS_L0_HWT_MULTI_LANE_MODE_MASK  0x00000008
+#define CPU_MAC_UNIT_HSS_CFG_W2_CFG_HSS_L0_LANE_ID_MASK              0x00000070
+#define CPU_MAC_UNIT_HSS_CFG_W2_CFG_HSS_L0_PCS2_PMA_PHY_MODE_MASK    0x07c00000
+#define CPU_MAC_UNIT_HSS_CFG_W2_CFG_HSS_L0_PCS2_PMA_TX_SWING_MASK    0x80000000
+#define CPU_MAC_UNIT_HSS_CFG_W2_CFG_HSS_L0_PCS2_PMA_VGA_CTRL_MASK    0x78000000
+#define CPU_MAC_UNIT_HSS_CFG_W2_CFG_HSS_L0_PMA_RX_DIV_SEL_MASK       0x00380000
+#define CPU_MAC_UNIT_HSS_CFG_W2_CFG_HSS_L0_PMA_TX_CK_SEL_MASK        0x0000e000
+#define CPU_MAC_UNIT_HSS_CFG_W2_CFG_HSS_L0_RST_N_MASK                0x00000001
+#define CPU_MAC_UNIT_HSS_CFG_W2_CFG_HSS_L0_RX_RATE_SEL_MASK          0x00060000
+#define CPU_MAC_UNIT_HSS_CFG_W2_CFG_HSS_L0_RX_RST_N_MASK             0x00010000
+#define CPU_MAC_UNIT_HSS_CFG_W2_CFG_HSS_L0_TX_RATE_SEL_MASK          0x00001800
+#define CPU_MAC_UNIT_HSS_CFG_W2_CFG_HSS_L0_TX_RST_N_MASK             0x00000400
+#define CPU_MAC_UNIT_HSS_CFG_W3_CFG_HSS_L0_HWT_FOM_SEL_MASK          0x00080000
+#define CPU_MAC_UNIT_HSS_CFG_W3_CFG_HSS_L0_PCS2_PMA_PI_EXT_DAC_BIT20_TO14_MASK 0x07f00000
+#define CPU_MAC_UNIT_HSS_CFG_W3_CFG_HSS_L0_PCS2_PMA_PI_EXT_DAC_BIT23_TO21_MASK 0x38000000
+#define CPU_MAC_UNIT_HSS_CFG_W3_CFG_HSS_L0_PCS2_PMA_TX_EI_MASK       0x00040000
+#define CPU_MAC_UNIT_HSS_CFG_W3_CFG_HSS_L0_PCS_EN_ADV_MASK           0x00000200
+#define CPU_MAC_UNIT_HSS_CFG_W3_CFG_HSS_L0_PCS_EN_DLY_MASK           0x00000100
+#define CPU_MAC_UNIT_HSS_CFG_W3_CFG_HSS_L0_PCS_EN_MAIN_MASK          0x00000080
+#define CPU_MAC_UNIT_HSS_CFG_W3_CFG_HSS_L0_PCS_I_SCAN_EN_MASK        0x00000040
+#define CPU_MAC_UNIT_HSS_CFG_W3_CFG_HSS_L0_PCS_TAP_ADV_MASK          0x0000003e
+#define CPU_MAC_UNIT_HSS_CFG_W3_CFG_HSS_L0_PCS_TAP_DLY_MASK          0x00007c00
+#define CPU_MAC_UNIT_HSS_CFG_W3_CFG_HSS_L0_PCS_TAP_MAIN_MASK         0x00000001
+#define CPU_MAC_UNIT_HSS_CFG_W4_CFG_HSS_L0_PCS2_PMA_ITX_PREEMP_BASE_MASK 0xc0000000
+#define CPU_MAC_UNIT_HSS_CFG_W4_CFG_HSS_L0_PCS2_PMA_MCNT_MAX_VAL_MASK 0x3e000000
+#define CPU_MAC_UNIT_HSS_CFG_W4_CFG_HSS_L0_PCS2_PMA_PI_FLOOP_STEPS_MASK 0x01800000
+#define CPU_MAC_UNIT_HSS_CFG_W4_CFG_HSS_L0_PCS2_PMA_RX_SSC_LH_MASK   0x00400000
+#define CPU_MAC_UNIT_HSS_CFG_W4_CFG_HSS_L0_PCS2_PMA_SSC_EN_MASK      0x00200000
+#define CPU_MAC_UNIT_HSS_CFG_W4_CFG_HSS_L0_PCS2_PMA_SSC_PI_BW_MASK   0x001e0000
+#define CPU_MAC_UNIT_HSS_CFG_W4_CFG_HSS_L0_PCS2_PMA_SSC_PI_STEP_MASK 0x00018000
+#define CPU_MAC_UNIT_HSS_CFG_W4_CFG_HSS_L0_PCS2_PMA_SSC_RESETB_MASK  0x00004000
+#define CPU_MAC_UNIT_HSS_CFG_W4_CFG_HSS_L0_PCS2_PMA_SSC_RTL_CLK_SEL_MASK 0x00002000
+#define CPU_MAC_UNIT_HSS_CFG_W4_CFG_HSS_L0_PCS2_PMA_TX_DET_RX_EN_MASK 0x00001000
+#define CPU_MAC_UNIT_HSS_CFG_W4_CFG_HSS_L0_PCS2_PMA_TX_DET_RX_STR_MASK 0x00000800
+#define CPU_MAC_UNIT_HSS_CFG_W4_CFG_HSS_L0_PCS2_PMANCNT_MAX_VAL_MASK 0x000007ff
+#define CPU_MAC_UNIT_HSS_CFG_W5_CFG_HSS_L0_PCS2_PMA_EN_PRE_EMPH_MASK 0x80000000
+#define CPU_MAC_UNIT_HSS_CFG_W5_CFG_HSS_L0_PCS2_PMA_EQC_FORCE_MASK   0x78000000
+#define CPU_MAC_UNIT_HSS_CFG_W5_CFG_HSS_L0_PCS2_PMA_EQR_BYP_MASK     0x04000000
+#define CPU_MAC_UNIT_HSS_CFG_W5_CFG_HSS_L0_PCS2_PMA_ISCAN_EXT_DAC_BIT7_MASK 0x02000000
+#define CPU_MAC_UNIT_HSS_CFG_W5_CFG_HSS_L0_PCS2_PMA_POWER_CTRL_MASK  0x01ffffff
+#define CPU_MAC_UNIT_HSS_CFG_W6_CFG_HSS_L0_FORCE_SIGNAL_DETECT_MASK  0x80000000
+#define CPU_MAC_UNIT_HSS_CFG_W6_CFG_HSS_L0_PCLK_GATING_MASK          0x00000080
+#define CPU_MAC_UNIT_HSS_CFG_W6_CFG_HSS_L0_PCS2_PMA_CENTER_SPREADING_MASK 0x00000040
+#define CPU_MAC_UNIT_HSS_CFG_W6_CFG_HSS_L0_PCS2_PMA_CTLE_RSTN_MASK   0x00020000
+#define CPU_MAC_UNIT_HSS_CFG_W6_CFG_HSS_L0_PCS2_PMA_DIS2ND_ORDER_MASK 0x00000020
+#define CPU_MAC_UNIT_HSS_CFG_W6_CFG_HSS_L0_PCS2_PMA_EID_LP_MASK      0x00040000
+#define CPU_MAC_UNIT_HSS_CFG_W6_CFG_HSS_L0_PCS2_PMA_EN_DFE_DIG_MASK  0x00000010
+#define CPU_MAC_UNIT_HSS_CFG_W6_CFG_HSS_L0_PCS2_PMA_EQ_RES_MASK      0x0000000f
+#define CPU_MAC_UNIT_HSS_CFG_W6_CFG_HSS_L0_PCS2_PMA_HOLD_DFE_MASK    0x00400000
+#define CPU_MAC_UNIT_HSS_CFG_W6_CFG_HSS_L0_PCS2_PMA_ISCAN_SEL_MASK   0x00080000
+#define CPU_MAC_UNIT_HSS_CFG_W6_CFG_HSS_L0_PCS2_PMA_PI_HOLD_MASK     0x00100000
+#define CPU_MAC_UNIT_HSS_CFG_W6_CFG_HSS_L0_PCS2_PMA_R50_EN_MASK      0x00200000
+#define CPU_MAC_UNIT_HSS_CFG_W6_CFG_HSS_L0_PCS2_PMA_TX_MARGIN_MASK   0x0001ff00
+#define CPU_MAC_UNIT_HSS_CFG_W7_CFG_HSS_L0_PCS2_PMA_DLEV_MASK        0x3f800000
+#define CPU_MAC_UNIT_HSS_CFG_W7_CFG_HSS_L0_PCS2_PMA_DLEV_BYP_MASK    0x80000000
+#define CPU_MAC_UNIT_HSS_CFG_W7_CFG_HSS_L0_PCS2_PMA_H1_MASK          0x0000003f
+#define CPU_MAC_UNIT_HSS_CFG_W7_CFG_HSS_L0_PCS2_PMA_H2_MASK          0x000007c0
+#define CPU_MAC_UNIT_HSS_CFG_W7_CFG_HSS_L0_PCS2_PMA_H3_MASK          0x00007800
+#define CPU_MAC_UNIT_HSS_CFG_W7_CFG_HSS_L0_PCS2_PMA_H4_MASK          0x00078000
+#define CPU_MAC_UNIT_HSS_CFG_W7_CFG_HSS_L0_PCS2_PMA_H5_MASK          0x00780000
+#define CPU_MAC_UNIT_HSS_CFG_W7_CFG_HSS_L0_PCS2_PMA_H_BYP_MASK       0x40000000
+#define CPU_MAC_UNIT_HSS_CFG_W8_CFG_HSS_L1_AUX_RX_CK_SEL_MASK        0x00000004
+#define CPU_MAC_UNIT_HSS_CFG_W8_CFG_HSS_L1_AUX_TX_CK_SEL_MASK        0x00000002
+#define CPU_MAC_UNIT_HSS_CFG_W8_CFG_HSS_L1_DATA_WIDTH_SEL_MASK       0x00000380
+#define CPU_MAC_UNIT_HSS_CFG_W8_CFG_HSS_L1_HWT_MULTI_LANE_MODE_MASK  0x00000008
+#define CPU_MAC_UNIT_HSS_CFG_W8_CFG_HSS_L1_LANE_ID_MASK              0x00000070
+#define CPU_MAC_UNIT_HSS_CFG_W8_CFG_HSS_L1_PCS2_PMA_PHY_MODE_MASK    0x07c00000
+#define CPU_MAC_UNIT_HSS_CFG_W8_CFG_HSS_L1_PCS2_PMA_TX_SWING_MASK    0x80000000
+#define CPU_MAC_UNIT_HSS_CFG_W8_CFG_HSS_L1_PCS2_PMA_VGA_CTRL_MASK    0x78000000
+#define CPU_MAC_UNIT_HSS_CFG_W8_CFG_HSS_L1_PMA_RX_DIV_SEL_MASK       0x00380000
+#define CPU_MAC_UNIT_HSS_CFG_W8_CFG_HSS_L1_PMA_TX_CK_SEL_MASK        0x0000e000
+#define CPU_MAC_UNIT_HSS_CFG_W8_CFG_HSS_L1_RST_N_MASK                0x00000001
+#define CPU_MAC_UNIT_HSS_CFG_W8_CFG_HSS_L1_RX_RATE_SEL_MASK          0x00060000
+#define CPU_MAC_UNIT_HSS_CFG_W8_CFG_HSS_L1_RX_RST_N_MASK             0x00010000
+#define CPU_MAC_UNIT_HSS_CFG_W8_CFG_HSS_L1_TX_RATE_SEL_MASK          0x00001800
+#define CPU_MAC_UNIT_HSS_CFG_W8_CFG_HSS_L1_TX_RST_N_MASK             0x00000400
+#define CPU_MAC_UNIT_HSS_CFG_W9_CFG_HSS_L1_HWT_FOM_SEL_MASK          0x00080000
+#define CPU_MAC_UNIT_HSS_CFG_W9_CFG_HSS_L1_PCS2_PMA_PI_EXT_DAC_BIT20_TO14_MASK 0x07f00000
+#define CPU_MAC_UNIT_HSS_CFG_W9_CFG_HSS_L1_PCS2_PMA_PI_EXT_DAC_BIT23_TO21_MASK 0x38000000
+#define CPU_MAC_UNIT_HSS_CFG_W9_CFG_HSS_L1_PCS2_PMA_TX_EI_MASK       0x00040000
+#define CPU_MAC_UNIT_HSS_CFG_W9_CFG_HSS_L1_PCS_EN_ADV_MASK           0x00000200
+#define CPU_MAC_UNIT_HSS_CFG_W9_CFG_HSS_L1_PCS_EN_DLY_MASK           0x00000100
+#define CPU_MAC_UNIT_HSS_CFG_W9_CFG_HSS_L1_PCS_EN_MAIN_MASK          0x00000080
+#define CPU_MAC_UNIT_HSS_CFG_W9_CFG_HSS_L1_PCS_I_SCAN_EN_MASK        0x00000040
+#define CPU_MAC_UNIT_HSS_CFG_W9_CFG_HSS_L1_PCS_TAP_ADV_MASK          0x0000003e
+#define CPU_MAC_UNIT_HSS_CFG_W9_CFG_HSS_L1_PCS_TAP_DLY_MASK          0x00007c00
+#define CPU_MAC_UNIT_HSS_CFG_W9_CFG_HSS_L1_PCS_TAP_MAIN_MASK         0x00000001
+#define CPU_MAC_UNIT_HSS_CFG_W10_CFG_HSS_L1_PCS2_PMA_ITX_PREEMP_BASE_MASK 0xc0000000
+#define CPU_MAC_UNIT_HSS_CFG_W10_CFG_HSS_L1_PCS2_PMA_MCNT_MAX_VAL_MASK 0x3e000000
+#define CPU_MAC_UNIT_HSS_CFG_W10_CFG_HSS_L1_PCS2_PMA_PI_FLOOP_STEPS_MASK 0x01800000
+#define CPU_MAC_UNIT_HSS_CFG_W10_CFG_HSS_L1_PCS2_PMA_RX_SSC_LH_MASK  0x00400000
+#define CPU_MAC_UNIT_HSS_CFG_W10_CFG_HSS_L1_PCS2_PMA_SSC_EN_MASK     0x00200000
+#define CPU_MAC_UNIT_HSS_CFG_W10_CFG_HSS_L1_PCS2_PMA_SSC_PI_BW_MASK  0x001e0000
+#define CPU_MAC_UNIT_HSS_CFG_W10_CFG_HSS_L1_PCS2_PMA_SSC_PI_STEP_MASK 0x00018000
+#define CPU_MAC_UNIT_HSS_CFG_W10_CFG_HSS_L1_PCS2_PMA_SSC_RESETB_MASK 0x00004000
+#define CPU_MAC_UNIT_HSS_CFG_W10_CFG_HSS_L1_PCS2_PMA_SSC_RTL_CLK_SEL_MASK 0x00002000
+#define CPU_MAC_UNIT_HSS_CFG_W10_CFG_HSS_L1_PCS2_PMA_TX_DET_RX_EN_MASK 0x00001000
+#define CPU_MAC_UNIT_HSS_CFG_W10_CFG_HSS_L1_PCS2_PMA_TX_DET_RX_STR_MASK 0x00000800
+#define CPU_MAC_UNIT_HSS_CFG_W10_CFG_HSS_L1_PCS2_PMANCNT_MAX_VAL_MASK 0x000007ff
+#define CPU_MAC_UNIT_HSS_CFG_W11_CFG_HSS_L1_PCS2_PMA_EN_PRE_EMPH_MASK 0x80000000
+#define CPU_MAC_UNIT_HSS_CFG_W11_CFG_HSS_L1_PCS2_PMA_EQC_FORCE_MASK  0x78000000
+#define CPU_MAC_UNIT_HSS_CFG_W11_CFG_HSS_L1_PCS2_PMA_EQR_BYP_MASK    0x04000000
+#define CPU_MAC_UNIT_HSS_CFG_W11_CFG_HSS_L1_PCS2_PMA_ISCAN_EXT_DAC_BIT7_MASK 0x02000000
+#define CPU_MAC_UNIT_HSS_CFG_W11_CFG_HSS_L1_PCS2_PMA_POWER_CTRL_MASK 0x01ffffff
+#define CPU_MAC_UNIT_HSS_CFG_W12_CFG_HSS_L1_FORCE_SIGNAL_DETECT_MASK 0x80000000
+#define CPU_MAC_UNIT_HSS_CFG_W12_CFG_HSS_L1_PCLK_GATING_MASK         0x00000080
+#define CPU_MAC_UNIT_HSS_CFG_W12_CFG_HSS_L1_PCS2_PMA_CENTER_SPREADING_MASK 0x00000040
+#define CPU_MAC_UNIT_HSS_CFG_W12_CFG_HSS_L1_PCS2_PMA_CTLE_RSTN_MASK  0x00020000
+#define CPU_MAC_UNIT_HSS_CFG_W12_CFG_HSS_L1_PCS2_PMA_DIS2ND_ORDER_MASK 0x00000020
+#define CPU_MAC_UNIT_HSS_CFG_W12_CFG_HSS_L1_PCS2_PMA_EID_LP_MASK     0x00040000
+#define CPU_MAC_UNIT_HSS_CFG_W12_CFG_HSS_L1_PCS2_PMA_EN_DFE_DIG_MASK 0x00000010
+#define CPU_MAC_UNIT_HSS_CFG_W12_CFG_HSS_L1_PCS2_PMA_EQ_RES_MASK     0x0000000f
+#define CPU_MAC_UNIT_HSS_CFG_W12_CFG_HSS_L1_PCS2_PMA_HOLD_DFE_MASK   0x00400000
+#define CPU_MAC_UNIT_HSS_CFG_W12_CFG_HSS_L1_PCS2_PMA_ISCAN_SEL_MASK  0x00080000
+#define CPU_MAC_UNIT_HSS_CFG_W12_CFG_HSS_L1_PCS2_PMA_PI_HOLD_MASK    0x00100000
+#define CPU_MAC_UNIT_HSS_CFG_W12_CFG_HSS_L1_PCS2_PMA_R50_EN_MASK     0x00200000
+#define CPU_MAC_UNIT_HSS_CFG_W12_CFG_HSS_L1_PCS2_PMA_TX_MARGIN_MASK  0x0001ff00
+#define CPU_MAC_UNIT_HSS_CFG_W13_CFG_HSS_L1_PCS2_PMA_DLEV_MASK       0x3f800000
+#define CPU_MAC_UNIT_HSS_CFG_W13_CFG_HSS_L1_PCS2_PMA_DLEV_BYP_MASK   0x80000000
+#define CPU_MAC_UNIT_HSS_CFG_W13_CFG_HSS_L1_PCS2_PMA_H1_MASK         0x0000003f
+#define CPU_MAC_UNIT_HSS_CFG_W13_CFG_HSS_L1_PCS2_PMA_H2_MASK         0x000007c0
+#define CPU_MAC_UNIT_HSS_CFG_W13_CFG_HSS_L1_PCS2_PMA_H3_MASK         0x00007800
+#define CPU_MAC_UNIT_HSS_CFG_W13_CFG_HSS_L1_PCS2_PMA_H4_MASK         0x00078000
+#define CPU_MAC_UNIT_HSS_CFG_W13_CFG_HSS_L1_PCS2_PMA_H5_MASK         0x00780000
+#define CPU_MAC_UNIT_HSS_CFG_W13_CFG_HSS_L1_PCS2_PMA_H_BYP_MASK      0x40000000
+/* ################################################################################
+ * # CpuMacUnitIpCamCfg Definition
+ */
+#define CPU_MAC_UNIT_IP_CAM_CFG_W0_CFG_IP_CAM_VALUE0_31_0            BIT(0)
+#define CPU_MAC_UNIT_IP_CAM_CFG_W1_CFG_IP_CAM_VALUE0_63_32           BIT(0)
+#define CPU_MAC_UNIT_IP_CAM_CFG_W2_CFG_IP_CAM_VALUE0_95_64           BIT(0)
+#define CPU_MAC_UNIT_IP_CAM_CFG_W3_CFG_IP_CAM_VALUE0_127_96          BIT(0)
+#define CPU_MAC_UNIT_IP_CAM_CFG_W4_CFG_IP_CAM_VALUE1_31_0            BIT(0)
+#define CPU_MAC_UNIT_IP_CAM_CFG_W5_CFG_IP_CAM_VALUE1_63_32           BIT(0)
+#define CPU_MAC_UNIT_IP_CAM_CFG_W6_CFG_IP_CAM_VALUE1_95_64           BIT(0)
+#define CPU_MAC_UNIT_IP_CAM_CFG_W7_CFG_IP_CAM_VALUE1_127_96          BIT(0)
+#define CPU_MAC_UNIT_IP_CAM_CFG_W8_CFG_IP_CAM_VALUE2_31_0            BIT(0)
+#define CPU_MAC_UNIT_IP_CAM_CFG_W9_CFG_IP_CAM_VALUE2_63_32           BIT(0)
+#define CPU_MAC_UNIT_IP_CAM_CFG_W10_CFG_IP_CAM_VALUE2_95_64          BIT(0)
+#define CPU_MAC_UNIT_IP_CAM_CFG_W11_CFG_IP_CAM_VALUE2_127_96         BIT(0)
+#define CPU_MAC_UNIT_IP_CAM_CFG_W12_CFG_IP_CAM_VALUE3_31_0           BIT(0)
+#define CPU_MAC_UNIT_IP_CAM_CFG_W13_CFG_IP_CAM_VALUE3_63_32          BIT(0)
+#define CPU_MAC_UNIT_IP_CAM_CFG_W14_CFG_IP_CAM_VALUE3_95_64          BIT(0)
+#define CPU_MAC_UNIT_IP_CAM_CFG_W15_CFG_IP_CAM_VALUE3_127_96         BIT(0)
+#define CPU_MAC_UNIT_IP_CAM_CFG_W16_CFG_IP_CAM_MASK0_31_0            BIT(0)
+#define CPU_MAC_UNIT_IP_CAM_CFG_W17_CFG_IP_CAM_MASK0_63_32           BIT(0)
+#define CPU_MAC_UNIT_IP_CAM_CFG_W18_CFG_IP_CAM_MASK0_95_64           BIT(0)
+#define CPU_MAC_UNIT_IP_CAM_CFG_W19_CFG_IP_CAM_MASK0_127_96          BIT(0)
+#define CPU_MAC_UNIT_IP_CAM_CFG_W20_CFG_IP_CAM_MASK1_31_0            BIT(0)
+#define CPU_MAC_UNIT_IP_CAM_CFG_W21_CFG_IP_CAM_MASK1_63_32           BIT(0)
+#define CPU_MAC_UNIT_IP_CAM_CFG_W22_CFG_IP_CAM_MASK1_95_64           BIT(0)
+#define CPU_MAC_UNIT_IP_CAM_CFG_W23_CFG_IP_CAM_MASK1_127_96          BIT(0)
+#define CPU_MAC_UNIT_IP_CAM_CFG_W24_CFG_IP_CAM_MASK2_31_0            BIT(0)
+#define CPU_MAC_UNIT_IP_CAM_CFG_W25_CFG_IP_CAM_MASK2_63_32           BIT(0)
+#define CPU_MAC_UNIT_IP_CAM_CFG_W26_CFG_IP_CAM_MASK2_95_64           BIT(0)
+#define CPU_MAC_UNIT_IP_CAM_CFG_W27_CFG_IP_CAM_MASK2_127_96          BIT(0)
+#define CPU_MAC_UNIT_IP_CAM_CFG_W28_CFG_IP_CAM_MASK3_31_0            BIT(0)
+#define CPU_MAC_UNIT_IP_CAM_CFG_W29_CFG_IP_CAM_MASK3_63_32           BIT(0)
+#define CPU_MAC_UNIT_IP_CAM_CFG_W30_CFG_IP_CAM_MASK3_95_64           BIT(0)
+#define CPU_MAC_UNIT_IP_CAM_CFG_W31_CFG_IP_CAM_MASK3_127_96          BIT(0)
+
+#define CPU_MAC_UNIT_IP_CAM_CFG_W0_CFG_IP_CAM_VALUE0_31_0_MASK       0x00000001
+#define CPU_MAC_UNIT_IP_CAM_CFG_W1_CFG_IP_CAM_VALUE0_63_32_MASK      0x00000001
+#define CPU_MAC_UNIT_IP_CAM_CFG_W2_CFG_IP_CAM_VALUE0_95_64_MASK      0x00000001
+#define CPU_MAC_UNIT_IP_CAM_CFG_W3_CFG_IP_CAM_VALUE0_127_96_MASK     0x00000001
+#define CPU_MAC_UNIT_IP_CAM_CFG_W4_CFG_IP_CAM_VALUE1_31_0_MASK       0x00000001
+#define CPU_MAC_UNIT_IP_CAM_CFG_W5_CFG_IP_CAM_VALUE1_63_32_MASK      0x00000001
+#define CPU_MAC_UNIT_IP_CAM_CFG_W6_CFG_IP_CAM_VALUE1_95_64_MASK      0x00000001
+#define CPU_MAC_UNIT_IP_CAM_CFG_W7_CFG_IP_CAM_VALUE1_127_96_MASK     0x00000001
+#define CPU_MAC_UNIT_IP_CAM_CFG_W8_CFG_IP_CAM_VALUE2_31_0_MASK       0x00000001
+#define CPU_MAC_UNIT_IP_CAM_CFG_W9_CFG_IP_CAM_VALUE2_63_32_MASK      0x00000001
+#define CPU_MAC_UNIT_IP_CAM_CFG_W10_CFG_IP_CAM_VALUE2_95_64_MASK     0x00000001
+#define CPU_MAC_UNIT_IP_CAM_CFG_W11_CFG_IP_CAM_VALUE2_127_96_MASK    0x00000001
+#define CPU_MAC_UNIT_IP_CAM_CFG_W12_CFG_IP_CAM_VALUE3_31_0_MASK      0x00000001
+#define CPU_MAC_UNIT_IP_CAM_CFG_W13_CFG_IP_CAM_VALUE3_63_32_MASK     0x00000001
+#define CPU_MAC_UNIT_IP_CAM_CFG_W14_CFG_IP_CAM_VALUE3_95_64_MASK     0x00000001
+#define CPU_MAC_UNIT_IP_CAM_CFG_W15_CFG_IP_CAM_VALUE3_127_96_MASK    0x00000001
+#define CPU_MAC_UNIT_IP_CAM_CFG_W16_CFG_IP_CAM_MASK0_31_0_MASK       0x00000001
+#define CPU_MAC_UNIT_IP_CAM_CFG_W17_CFG_IP_CAM_MASK0_63_32_MASK      0x00000001
+#define CPU_MAC_UNIT_IP_CAM_CFG_W18_CFG_IP_CAM_MASK0_95_64_MASK      0x00000001
+#define CPU_MAC_UNIT_IP_CAM_CFG_W19_CFG_IP_CAM_MASK0_127_96_MASK     0x00000001
+#define CPU_MAC_UNIT_IP_CAM_CFG_W20_CFG_IP_CAM_MASK1_31_0_MASK       0x00000001
+#define CPU_MAC_UNIT_IP_CAM_CFG_W21_CFG_IP_CAM_MASK1_63_32_MASK      0x00000001
+#define CPU_MAC_UNIT_IP_CAM_CFG_W22_CFG_IP_CAM_MASK1_95_64_MASK      0x00000001
+#define CPU_MAC_UNIT_IP_CAM_CFG_W23_CFG_IP_CAM_MASK1_127_96_MASK     0x00000001
+#define CPU_MAC_UNIT_IP_CAM_CFG_W24_CFG_IP_CAM_MASK2_31_0_MASK       0x00000001
+#define CPU_MAC_UNIT_IP_CAM_CFG_W25_CFG_IP_CAM_MASK2_63_32_MASK      0x00000001
+#define CPU_MAC_UNIT_IP_CAM_CFG_W26_CFG_IP_CAM_MASK2_95_64_MASK      0x00000001
+#define CPU_MAC_UNIT_IP_CAM_CFG_W27_CFG_IP_CAM_MASK2_127_96_MASK     0x00000001
+#define CPU_MAC_UNIT_IP_CAM_CFG_W28_CFG_IP_CAM_MASK3_31_0_MASK       0x00000001
+#define CPU_MAC_UNIT_IP_CAM_CFG_W29_CFG_IP_CAM_MASK3_63_32_MASK      0x00000001
+#define CPU_MAC_UNIT_IP_CAM_CFG_W30_CFG_IP_CAM_MASK3_95_64_MASK      0x00000001
+#define CPU_MAC_UNIT_IP_CAM_CFG_W31_CFG_IP_CAM_MASK3_127_96_MASK     0x00000001
+
+/* ################################################################################
+ * # CpuMacUnitMacCamCfg Definition
+ */
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W0_CFG_MAC_CAM_VALUE0_31_0          BIT(0)
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W1_CFG_MAC_CAM_VALUE0_47_32         BIT(0)
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W2_CFG_MAC_CAM_VALUE1_31_0          BIT(0)
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W3_CFG_MAC_CAM_VALUE1_47_32         BIT(0)
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W4_CFG_MAC_CAM_VALUE2_31_0          BIT(0)
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W5_CFG_MAC_CAM_VALUE2_47_32         BIT(0)
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W6_CFG_MAC_CAM_VALUE3_31_0          BIT(0)
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W7_CFG_MAC_CAM_VALUE3_47_32         BIT(0)
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W8_CFG_MAC_CAM_VALUE4_31_0          BIT(0)
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W9_CFG_MAC_CAM_VALUE4_47_32         BIT(0)
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W10_CFG_MAC_CAM_VALUE5_31_0         BIT(0)
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W11_CFG_MAC_CAM_VALUE5_47_32        BIT(0)
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W12_CFG_MAC_CAM_VALUE6_31_0         BIT(0)
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W13_CFG_MAC_CAM_VALUE6_47_32        BIT(0)
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W14_CFG_MAC_CAM_VALUE7_31_0         BIT(0)
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W15_CFG_MAC_CAM_VALUE7_47_32        BIT(0)
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W16_CFG_MAC_CAM_MASK0_31_0          BIT(0)
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W17_CFG_MAC_CAM_MASK0_47_32         BIT(0)
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W18_CFG_MAC_CAM_MASK1_31_0          BIT(0)
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W19_CFG_MAC_CAM_MASK1_47_32         BIT(0)
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W20_CFG_MAC_CAM_MASK2_31_0          BIT(0)
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W21_CFG_MAC_CAM_MASK2_47_32         BIT(0)
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W22_CFG_MAC_CAM_MASK3_31_0          BIT(0)
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W23_CFG_MAC_CAM_MASK3_47_32         BIT(0)
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W24_CFG_MAC_CAM_MASK4_31_0          BIT(0)
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W25_CFG_MAC_CAM_MASK4_47_32         BIT(0)
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W26_CFG_MAC_CAM_MASK5_31_0          BIT(0)
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W27_CFG_MAC_CAM_MASK5_47_32         BIT(0)
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W28_CFG_MAC_CAM_MASK6_31_0          BIT(0)
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W29_CFG_MAC_CAM_MASK6_47_32         BIT(0)
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W30_CFG_MAC_CAM_MASK7_31_0          BIT(0)
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W31_CFG_MAC_CAM_MASK7_47_32         BIT(0)
+
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W0_CFG_MAC_CAM_VALUE0_31_0_MASK     0x00000001
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W1_CFG_MAC_CAM_VALUE0_47_32_MASK    0x00000001
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W2_CFG_MAC_CAM_VALUE1_31_0_MASK     0x00000001
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W3_CFG_MAC_CAM_VALUE1_47_32_MASK    0x00000001
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W4_CFG_MAC_CAM_VALUE2_31_0_MASK     0x00000001
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W5_CFG_MAC_CAM_VALUE2_47_32_MASK    0x00000001
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W6_CFG_MAC_CAM_VALUE3_31_0_MASK     0x00000001
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W7_CFG_MAC_CAM_VALUE3_47_32_MASK    0x00000001
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W8_CFG_MAC_CAM_VALUE4_31_0_MASK     0x00000001
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W9_CFG_MAC_CAM_VALUE4_47_32_MASK    0x00000001
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W10_CFG_MAC_CAM_VALUE5_31_0_MASK    0x00000001
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W11_CFG_MAC_CAM_VALUE5_47_32_MASK   0x00000001
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W12_CFG_MAC_CAM_VALUE6_31_0_MASK    0x00000001
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W13_CFG_MAC_CAM_VALUE6_47_32_MASK   0x00000001
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W14_CFG_MAC_CAM_VALUE7_31_0_MASK    0x00000001
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W15_CFG_MAC_CAM_VALUE7_47_32_MASK   0x00000001
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W16_CFG_MAC_CAM_MASK0_31_0_MASK     0x00000001
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W17_CFG_MAC_CAM_MASK0_47_32_MASK    0x00000001
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W18_CFG_MAC_CAM_MASK1_31_0_MASK     0x00000001
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W19_CFG_MAC_CAM_MASK1_47_32_MASK    0x00000001
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W20_CFG_MAC_CAM_MASK2_31_0_MASK     0x00000001
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W21_CFG_MAC_CAM_MASK2_47_32_MASK    0x00000001
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W22_CFG_MAC_CAM_MASK3_31_0_MASK     0x00000001
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W23_CFG_MAC_CAM_MASK3_47_32_MASK    0x00000001
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W24_CFG_MAC_CAM_MASK4_31_0_MASK     0x00000001
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W25_CFG_MAC_CAM_MASK4_47_32_MASK    0x00000001
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W26_CFG_MAC_CAM_MASK5_31_0_MASK     0x00000001
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W27_CFG_MAC_CAM_MASK5_47_32_MASK    0x00000001
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W28_CFG_MAC_CAM_MASK6_31_0_MASK     0x00000001
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W29_CFG_MAC_CAM_MASK6_47_32_MASK    0x00000001
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W30_CFG_MAC_CAM_MASK7_31_0_MASK     0x00000001
+#define CPU_MAC_UNIT_MAC_CAM_CFG_W31_CFG_MAC_CAM_MASK7_47_32_MASK    0x00000001
+
+/* ################################################################################
+ * # CpuMacUnitFilterCfg Definition
+ */
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_IP_ADDR_IS_SA0                BIT(17)
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_MAC_ADDR_IS_SA0               BIT(9)
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_IP_ADDR_IS_SA3                BIT(20)
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_MAC_ADDR_IS_SA6               BIT(15)
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_IP_ADDR_IS_SA1                BIT(18)
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_FILTER_IS_LOOSE               BIT(5)
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_MAC_ADDR_IS_SA7               BIT(16)
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_IP_ADDR_FILTER_EN             BIT(2)
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_BLOCK_SUPPRESSION_TRAFFIC     BIT(6)
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_IP_ADDR_IS_SA2                BIT(19)
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_IP_CAM3_IS_V6                 BIT(24)
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_MAC_ADDR_IS_SA5               BIT(14)
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_MAC_ADDR_IS_SA2               BIT(11)
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_MAC_ADDR_IS_SA4               BIT(13)
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_IP_CAM_IS_BLACK_LIST          BIT(4)
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_MAC_CAM_IS_BLACK_LIST         BIT(3)
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_MAC_FILTER_EN                 BIT(0)
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_IP_CAM2_IS_V6                 BIT(23)
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_IP_CAM1_IS_V6                 BIT(22)
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_ETHER_TYPE_FILTER_EN          BIT(1)
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_MAC_ADDR_IS_SA1               BIT(10)
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_MAC_ADDR_IS_SA3               BIT(12)
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_IP_CAM0_IS_V6                 BIT(21)
+#define CPU_MAC_UNIT_FILTER_CFG_W1_CFG_SUPPRESSION_ETHER_TYPE0       BIT(16)
+#define CPU_MAC_UNIT_FILTER_CFG_W1_CFG_VLAN_TPID                     BIT(0)
+#define CPU_MAC_UNIT_FILTER_CFG_W2_CFG_SUPPRESSION_ETHER_TYPE1       BIT(0)
+#define CPU_MAC_UNIT_FILTER_CFG_W2_CFG_SUPPRESSION_ETHER_TYPE2       BIT(16)
+#define CPU_MAC_UNIT_FILTER_CFG_W3_CFG_CONFIRM_ETHER_TYPE0           BIT(0)
+#define CPU_MAC_UNIT_FILTER_CFG_W3_CFG_CONFIRM_ETHER_TYPE1           BIT(16)
+#define CPU_MAC_UNIT_FILTER_CFG_W4_CFG_CONFIRM_ETHER_TYPE2           BIT(0)
+#define CPU_MAC_UNIT_FILTER_CFG_W5_CFG_METER_TOKEN_UPD_INTERVAL      BIT(0)
+#define CPU_MAC_UNIT_FILTER_CFG_W5_CFG_METER_TOKEN_UPD_VALUE         BIT(16)
+
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_IP_ADDR_IS_SA0_MASK           0x00020000
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_MAC_ADDR_IS_SA0_MASK          0x00000200
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_IP_ADDR_IS_SA3_MASK           0x00100000
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_MAC_ADDR_IS_SA6_MASK          0x00008000
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_IP_ADDR_IS_SA1_MASK           0x00040000
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_FILTER_IS_LOOSE_MASK          0x00000020
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_MAC_ADDR_IS_SA7_MASK          0x00010000
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_IP_ADDR_FILTER_EN_MASK        0x00000004
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_BLOCK_SUPPRESSION_TRAFFIC_MASK 0x000001c0
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_IP_ADDR_IS_SA2_MASK           0x00080000
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_IP_CAM3_IS_V6_MASK            0x01000000
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_MAC_ADDR_IS_SA5_MASK          0x00004000
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_MAC_ADDR_IS_SA2_MASK          0x00000800
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_MAC_ADDR_IS_SA4_MASK          0x00002000
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_IP_CAM_IS_BLACK_LIST_MASK     0x00000010
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_MAC_CAM_IS_BLACK_LIST_MASK    0x00000008
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_MAC_FILTER_EN_MASK            0x00000001
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_IP_CAM2_IS_V6_MASK            0x00800000
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_IP_CAM1_IS_V6_MASK            0x00400000
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_ETHER_TYPE_FILTER_EN_MASK     0x00000002
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_MAC_ADDR_IS_SA1_MASK          0x00000400
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_MAC_ADDR_IS_SA3_MASK          0x00001000
+#define CPU_MAC_UNIT_FILTER_CFG_W0_CFG_IP_CAM0_IS_V6_MASK            0x00200000
+#define CPU_MAC_UNIT_FILTER_CFG_W1_CFG_SUPPRESSION_ETHER_TYPE0_MASK  0xffff0000
+#define CPU_MAC_UNIT_FILTER_CFG_W1_CFG_VLAN_TPID_MASK                0x0000ffff
+#define CPU_MAC_UNIT_FILTER_CFG_W2_CFG_SUPPRESSION_ETHER_TYPE1_MASK  0x0000ffff
+#define CPU_MAC_UNIT_FILTER_CFG_W2_CFG_SUPPRESSION_ETHER_TYPE2_MASK  0xffff0000
+#define CPU_MAC_UNIT_FILTER_CFG_W3_CFG_CONFIRM_ETHER_TYPE0_MASK      0x0000ffff
+#define CPU_MAC_UNIT_FILTER_CFG_W3_CFG_CONFIRM_ETHER_TYPE1_MASK      0xffff0000
+#define CPU_MAC_UNIT_FILTER_CFG_W4_CFG_CONFIRM_ETHER_TYPE2_MASK      0x0000ffff
+#define CPU_MAC_UNIT_FILTER_CFG_W5_CFG_METER_TOKEN_UPD_INTERVAL_MASK 0x0000ffff
+#define CPU_MAC_UNIT_FILTER_CFG_W5_CFG_METER_TOKEN_UPD_VALUE_MASK    0xffff0000
+
+
+struct CpuMacUnit_mems {
+   u32 CpuMacUnitTxTsCaptureFifo0[3];   /* 0x00000400 */
+   u32 CpuMacUnitTxTsCaptureFifo0_rsv3;
+   u32 CpuMacUnitTxTsCaptureFifo1[3];   /* 0x00000410 */
+   u32 CpuMacUnitTxTsCaptureFifo1_rsv3;
+   u32 CpuMacUnitTxTsCaptureFifo2[3];   /* 0x00000420 */
+   u32 CpuMacUnitTxTsCaptureFifo2_rsv3;
+   u32 CpuMacUnitTxTsCaptureFifo3[3];   /* 0x00000430 */
+   u32 CpuMacUnitTxTsCaptureFifo3_rsv3;
+   u32 CpuMacUnitTxTsCaptureFifo4[3];   /* 0x00000440 */
+   u32 CpuMacUnitTxTsCaptureFifo4_rsv3;
+   u32 CpuMacUnitTxTsCaptureFifo5[3];   /* 0x00000450 */
+   u32 CpuMacUnitTxTsCaptureFifo5_rsv3;
+   u32 CpuMacUnitTxTsCaptureFifo6[3];   /* 0x00000460 */
+   u32 CpuMacUnitTxTsCaptureFifo6_rsv3;
+   u32 CpuMacUnitTxTsCaptureFifo7[3];   /* 0x00000470 */
+   u32 CpuMacUnitTxTsCaptureFifo7_rsv3;
+   u32 CpuMacUnitTxCaptureTs0[3];       /* 0x00000480 */
+   u32 CpuMacUnitTxCaptureTs0_rsv3;
+};
+
+/* ################################################################################
+ * # CpuMacUnitTxTsCaptureFifo Definition
+ */
+#define CPU_MAC_UNIT_TX_TS_CAPTURE_FIFO_W0_CPU_MAC_UNIT_TX_TS_CAPTURE_FIFO_FIELD0 BIT(0)
+#define CPU_MAC_UNIT_TX_TS_CAPTURE_FIFO_W1_CPU_MAC_UNIT_TX_TS_CAPTURE_FIFO_FIELD1 BIT(0)
+#define CPU_MAC_UNIT_TX_TS_CAPTURE_FIFO_W2_CPU_MAC_UNIT_TX_TS_CAPTURE_FIFO_FIELD2 BIT(0)
+
+#define CPU_MAC_UNIT_TX_TS_CAPTURE_FIFO_W0_CPU_MAC_UNIT_TX_TS_CAPTURE_FIFO_FIELD0_MASK 0xffffffff
+#define CPU_MAC_UNIT_TX_TS_CAPTURE_FIFO_W1_CPU_MAC_UNIT_TX_TS_CAPTURE_FIFO_FIELD1_MASK 0xffffffff
+#define CPU_MAC_UNIT_TX_TS_CAPTURE_FIFO_W2_CPU_MAC_UNIT_TX_TS_CAPTURE_FIFO_FIELD2_MASK 0x0000000f
+
+/* ################################################################################
+ * # CpuMacUnitTxCaptureTs Definition
+ */
+#define CPU_MAC_UNIT_TX_CAPTURE_TS_W0_CPU_MAC1_TX_SEQ_ID             BIT(5)
+#define CPU_MAC_UNIT_TX_CAPTURE_TS_W0_CPU_MAC1_TX_SFD                BIT(4)
+#define CPU_MAC_UNIT_TX_CAPTURE_TS_W0_CPU_MAC0_TX_SEQ_ID             BIT(1)
+#define CPU_MAC_UNIT_TX_CAPTURE_TS_W0_CPU_MAC0_TX_SFD                BIT(0)
+#define CPU_MAC_UNIT_TX_CAPTURE_TS_W1_ADJ_RC_SECOND                  BIT(0)
+#define CPU_MAC_UNIT_TX_CAPTURE_TS_W2_ADJ_RC_NS                      BIT(0)
+
+#define CPU_MAC_UNIT_TX_CAPTURE_TS_W0_CPU_MAC1_TX_SEQ_ID_MASK        0x00000060
+#define CPU_MAC_UNIT_TX_CAPTURE_TS_W0_CPU_MAC1_TX_SFD_MASK           0x00000010
+#define CPU_MAC_UNIT_TX_CAPTURE_TS_W0_CPU_MAC0_TX_SEQ_ID_MASK        0x00000006
+#define CPU_MAC_UNIT_TX_CAPTURE_TS_W0_CPU_MAC0_TX_SFD_MASK           0x00000001
+#define CPU_MAC_UNIT_TX_CAPTURE_TS_W1_ADJ_RC_SECOND_MASK             0xffffffff
+#define CPU_MAC_UNIT_TX_CAPTURE_TS_W2_ADJ_RC_NS_MASK                 0x3fffffff
+
+#define CTCMAC_NUM 2
+#define TX_BUF_CNT 2
+
+#define CTCMAC_MDIO_BASE 0x33620000 
+#define CTCMAC_0_BASE      0x33410000
+#define CTCMAC_1_BASE      0x33420000
+
+#define CTCMAC_MDIO_CMD_STCODE(V) (V<<0)
+#define CTCMAC_MDIO_CMD_OPCODE(V) (V<<26)
+#define CTCMAC_MDIO_CMD_PHYAD(V)  (V<<21)
+#define CTCMAC_MDIO_CMD_REGAD(V)  (V<<16)
+#define CTCMAC_MDIO_CMD_DATA(V)   (V<<0)
+
+#define CTCMAC_MDIO_STAT(V)       (V<<16)
+
+#endif
+
+
diff --git a/drivers/net/ethernet/centec/ctcmac_test.c b/drivers/net/ethernet/centec/ctcmac_test.c
new file mode 100644
index 0000000..3ae603a
--- /dev/null
+++ b/drivers/net/ethernet/centec/ctcmac_test.c
@@ -0,0 +1,2101 @@
+/*
+ * Centec CpuMac Ethernet Driver For Test -- CpuMac controller implementation
+ * Provides Bus interface for MIIM regs
+ *
+ * Author: liuht <liuht@centecnetworks.com>
+ *
+ * Copyright 2002-2018, Centec Networks (Suzhou) Co., Ltd.
+ *
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/unistd.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/if_vlan.h>
+#include <linux/spinlock.h>
+#include <linux/mm.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_mdio.h>
+#include <linux/of_platform.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/udp.h>
+#include <linux/in.h>
+#include <linux/net_tstamp.h>
+
+#include <asm/io.h>
+#include <dt-bindings/pinctrl/pinctrl-ctc.h>
+#include <soc/ctc/sysctl.h>
+#include <linux/regmap.h>
+#include <linux/mfd/syscon.h>
+#include <linux/iopoll.h>
+
+#include "ctcmac.h"
+#include "ctcmac_reg.h"
+
+enum ctcmac_test_field {
+	CTCMAC_RING_SIZE = 0,
+	CTCMAC_PAYLOAD_SIZE = 1,
+	CTCMAC_RXTS_EN = 2,
+	CTCMAC_RXTS_DUMP = 3,
+	CTCMAC_TXTS_EN = 4,
+	CTCMAC_TXTS_DUMP = 5,
+	CTCMAC_TXINFO_VAL1 = 6,
+	CTCMAC_TXINFO_VAL2 = 7,
+	CTCMAC_TXINFO_VAL3 = 8,
+	CTCMAC_TXINFO_VAL4 = 9,
+};
+
+struct ctcmac_ptp_info{
+	u32 val1;
+	u32 val2;
+	u32 val3;
+	u32 val4;
+};
+
+
+struct ctcmac_test_param {
+	u32 ring_size;
+	u32 payload_size;
+	u32 rxts_en;
+	u32 rxts_dump;
+	u32 txts_en;
+	u32 txts_dump;
+	struct ctcmac_ptp_info ptp_info;
+};
+
+static int ctcmac_alloc_skb_resources(struct net_device *ndev);
+static int ctcmac_free_skb_resources(struct ctcmac_private *priv);
+static void cpumac_start(struct ctcmac_private *priv);
+static void cpumac_halt(struct ctcmac_private *priv);
+static void ctcmac_hw_init(struct ctcmac_private *priv) ;
+static spinlock_t global_reglock __aligned(SMP_CACHE_BYTES);
+static int g_reglock_init_done = 0;
+static int g_mac_unit_init_done=0;
+static struct ctcmac_test_param test_param[2];
+static struct ctcmac_pkt_stats pkt_stats[2];
+static int cpumac_unit_irq_installed = 0;
+static struct regmap *regmap_base;
+struct CpuMacUnit_regs *g_cpumacu_reg;
+/* get cpumac register : just for test */
+static int ctcmac_ethtool_get_eeprom(struct net_device *netdev,
+				       struct ethtool_eeprom *ee, u8 *data)
+{
+	u8 *iobase;
+	u32 val;
+	unsigned long flags;
+	struct ctcmac_private *priv =  netdev_priv(netdev);
+
+
+	if(ee->offset >= 0x00010000){
+		iobase = (u8 *)priv->cpumacu_reg;
+		ee->offset -= (0x00010000 + CPUMACUNIT_REG_BASE);
+	}else  if(ee->offset >= 0x00004000){
+		iobase = (u8 *)priv->cpumac_mem;
+		ee->offset -= 0x00004000;
+	}else{
+		iobase = (u8 *)priv->cpumac_reg;
+	}
+
+	spin_lock_irqsave(&priv->reglock, flags);
+	val = readl((unsigned __iomem *)(iobase + ee->offset));
+	printk(KERN_ERR "0x%llx : 0x%x\n", (u64)(iobase + ee->offset), val);
+	memcpy(data, (u8 *)&val, 4);
+
+	spin_unlock_irqrestore(&priv->reglock, flags);
+
+	return 0;
+
+}
+
+static int ctcmac_fill_test_param(u32 index, u32 field, u32 val)
+{
+
+	if(field == CTCMAC_RING_SIZE){
+		test_param[index].ring_size = val;
+	}else if(field == CTCMAC_PAYLOAD_SIZE){
+		test_param[index].payload_size = val;
+	}else if(field == CTCMAC_RXTS_EN){
+		test_param[index].rxts_en = val;
+	}else if(field == CTCMAC_RXTS_DUMP){
+		test_param[index].rxts_dump = val;
+	}else if(field == CTCMAC_TXTS_EN){
+		test_param[index].txts_en = val;
+	}else if(field == CTCMAC_TXTS_DUMP){
+		test_param[index].txts_dump = val;
+	}else if(field == CTCMAC_TXINFO_VAL1){
+		test_param[index].ptp_info.val1= val;
+	}else if(field == CTCMAC_TXINFO_VAL2){
+		test_param[index].ptp_info.val2= val;
+	}else if(field == CTCMAC_TXINFO_VAL3){
+		test_param[index].ptp_info.val3= val;
+	}else if(field == CTCMAC_TXINFO_VAL4){
+		test_param[index].ptp_info.val4= val;
+	}
+
+	printk(KERN_ERR "test param:\n");
+	printk(KERN_ERR "ring size : %d\n", test_param[index].ring_size);
+	printk(KERN_ERR "payload size : %d\n", test_param[index].payload_size);
+	printk(KERN_ERR "rxts en : %d\n", test_param[index].rxts_en);
+	printk(KERN_ERR "rxts dump : %d\n", test_param[index].rxts_dump);
+	printk(KERN_ERR "txts en : %d\n", test_param[index].txts_en);
+	printk(KERN_ERR "txts dump : %d\n", test_param[index].txts_dump);
+	printk(KERN_ERR "ptp info : 0x%x 0x%x 0x%x 0x%x\n", 
+	test_param[index].ptp_info.val1,
+	test_param[index].ptp_info.val2,
+	test_param[index].ptp_info.val3,
+	test_param[index].ptp_info.val4);
+    
+	return 0;
+}
+
+/* set cpumac register : just for test */
+static int ctcmac_ethtool_set_eeprom(struct net_device *netdev,
+				       struct ethtool_eeprom *ee, u8 *data)
+{
+	u8 *iobase;
+	u32 val=0;
+	unsigned long flags;
+	struct ctcmac_private *priv =  netdev_priv(netdev);
+
+
+	if(ee->offset >= 0x00030000){
+		memset(&pkt_stats[priv->index], 0, sizeof(struct ctcmac_pkt_stats ));
+		return 0;
+	}else if(ee->offset >= 0x00020000){
+		val = data[0] | (data[1]<<8)|(data[2]<<16)|(data[3]<<24);
+		ctcmac_fill_test_param(priv->index, ee->offset - 0x00020000, val);
+		return 0;
+	}else if(ee->offset >= 0x00010000){
+		iobase = (u8 *)priv->cpumacu_reg;
+		ee->offset -= (0x00010000 + CPUMACUNIT_REG_BASE);
+	}else  if(ee->offset >= 0x00004000){
+		iobase = (u8 *)priv->cpumac_mem;
+		ee->offset -= 0x00004000;
+	}else{
+		iobase = (u8 *)priv->cpumac_reg;
+	}
+
+	val = data[0] | (data[1]<<8)|(data[2]<<16)|(data[3]<<24);
+	printk(KERN_ERR "0x%llx : 0x%x\n", (u64)(iobase + ee->offset), val);
+	spin_lock_irqsave(&priv->reglock, flags);
+	writel(val, (unsigned __iomem *)(iobase + ee->offset));
+	spin_unlock_irqrestore(&priv->reglock, flags);
+
+	return 0;
+}
+
+#if 0
+static void ctcmac_ethtool_dump_stats(struct ctcmac_pkt_stats *stats, int index)
+{
+	printk("eth%d RX packet stats:\n", index);
+	printk("###############################################\n");
+	printk("RX bytes good ucast %lld\n",   stats->rx_good_ucast_bytes            );
+	printk("RX frame good ucast %lld\n",   stats->rx_good_ucast_pkt              );
+	printk("RX bytes good mcast %lld\n",   stats->rx_good_mcast_bytes            );
+	printk("RX frame good mcast %lld\n",   stats->rx_good_mcast_pkt              );
+	printk("RX bytes good bcast %lld\n",   stats->rx_good_bcast_bytes            );
+	printk("RX frame good bcast %lld\n",   stats->rx_good_bcast_pkt              );
+	printk("RX bytes good pause %lld\n",   stats->rx_good_pause_bytes            );
+	printk("RX frame good pause %lld\n",   stats->rx_good_pause_pkt              );
+	printk("RX bytes pfc ucast %lld\n",    stats->rx_good_pfc_bytes             );
+	printk("RX frame pfc ucast %lld\n",    stats->rx_good_pfc_pkt               );
+	printk("RX bytes good control %lld\n", stats->rx_good_control_bytes              );
+	printk("RX frame good control %lld\n", stats->rx_good_control_pkt              );
+	printk("RX bytes fcs error %lld\n",    stats->rx_fcs_error_bytes            );
+	printk("RX frame fcs error %lld\n",    stats->rx_fcs_error_pkt              );
+	printk("RX bytes mac overrun %lld\n",  stats->rx_mac_overrun_bytes             );
+	printk("RX frame mac overrun %lld\n",  stats->rx_mac_overrun_pkt              );
+	printk("RX bytes good 63B %lld\n",     stats->rx_good_63B_bytes            );
+	printk("RX frame good 63B %lld\n",     stats->rx_good_63B_pkt              );
+	printk("RX bytes bad 63B %lld\n",      stats->rx_bad_63B_bytes            );
+	printk("RX frame bad 63B %lld\n",      stats->rx_bad_63B_pkt              );
+	printk("RX bytes good 9216B %lld\n",   stats->rx_good_9216B_bytes            );
+	printk("RX frame good 9216B %lld\n",   stats->rx_good_9216B_pkt              );
+	printk("RX bytes bad 9216B %lld\n",    stats->rx_bad_9216B_bytes            );
+	printk("RX frame bad 9216B %lld\n",    stats->rx_bad_9216B_pkt              );
+	printk("RX bytes good jumbo %lld\n",   stats->rx_good_jumbo_bytes            );
+	printk("RX frame good jumbo %lld\n",   stats->rx_good_jumbo_pkt              );
+	printk("RX bytes bad jumbo %lld\n",    stats->rx_bad_jumbo_bytes            );
+	printk("RX frame bad jumbo %lld\n",    stats->rx_bad_jumbo_pkt              );
+	printk("RX bytes 64B %lld\n",          stats->rx_64B_bytes            );
+	printk("RX frame 64B %lld\n",          stats->rx_64B_pkt              );
+	printk("RX bytes 127B %lld\n",         stats->rx_127B_bytes            );
+	printk("RX frame 127B %lld\n",         stats->rx_127B_pkt              );
+	printk("RX bytes 255B %lld\n",         stats->rx_255B_bytes            );
+	printk("RX frame 255B %lld\n",         stats->rx_255B_pkt              );
+	printk("RX bytes 511B %lld\n",         stats->rx_511B_bytes            );
+	printk("RX frame 511B %lld\n",         stats->rx_511B_pkt              );
+	printk("RX bytes 1023B %lld\n",        stats->rx_1023B_bytes            );
+	printk("RX frame 1023B %lld\n",        stats->rx_1023B_pkt              );
+	printk("RX bytes 1518B %lld\n",        stats->rx_1518B_bytes            );
+	printk("RX frame 1518B %lld\n",        stats->rx_1518B_pkt              );
+	printk("###############################################\n\n");
+
+	printk("TX packet stats:\n");
+	printk("###############################################\n");
+	printk("TX bytes ucast %lld\n",    stats->tx_ucast_bytes               );
+	printk("TX frame ucast %lld\n",    stats->tx_ucast_pkt                 );
+	printk("TX bytes mcast %lld\n",    stats->tx_mcast_bytes               );
+	printk("TX frame mcast %lld\n",    stats->tx_mcast_pkt                 );
+	printk("TX bytes bcast %lld\n",    stats->tx_bcast_bytes               );
+	printk("TX frame bcast %lld\n",    stats->tx_bcast_pkt                 );
+	printk("TX bytes pause %lld\n",    stats->tx_pause_bytes               );
+	printk("TX frame pause %lld\n",    stats->tx_pause_pkt                 );
+	printk("TX bytes control %lld\n",  stats->tx_control_bytes               );
+	printk("TX frame control %lld\n",  stats->tx_control_pkt                 );
+	printk("TX bytes fcs error %lld\n",stats->tx_fcs_error_bytes               );
+	printk("TX frame fcs error %lld\n",stats->tx_fcs_error_pkt                 );
+	printk("TX bytes underrun %lld\n", stats->tx_underrun_bytes               );
+	printk("TX frame underrun %lld\n", stats->tx_underrun_pkt                 );
+	printk("TX bytes 63B %lld\n",      stats->tx_63B_bytes               );
+	printk("TX frame 63B %lld\n",      stats->tx_63B_pkt                 );
+	printk("TX bytes 64B %lld\n",      stats->tx_64B_bytes               );
+	printk("TX frame 64B %lld\n",      stats->tx_64B_pkt                 );
+	printk("TX bytes 127B %lld\n",     stats->tx_127B_bytes               );
+	printk("TX frame 127B %lld\n",     stats->tx_127B_pkt                 );
+	printk("TX bytes 255B %lld\n",     stats->tx_255B_bytes               );
+	printk("TX frame 255B %lld\n",     stats->tx_255B_pkt                 );
+	printk("TX bytes 511B %lld\n",     stats->tx_511B_bytes               );
+	printk("TX frame 511B %lld\n",     stats->tx_511B_pkt                 );
+	printk("TX bytes 1023B %lld\n",    stats->tx_1023B_bytes               );
+	printk("TX frame 1023B %lld\n",    stats->tx_1023B_pkt                 );
+	printk("TX bytes 1518B %lld\n",    stats->tx_1518B_bytes               );
+	printk("TX frame 1518B %lld\n",    stats->tx_1518B_pkt                 );
+	printk("TX bytes 1519B %lld\n",    stats->tx_1519B_bytes               );
+	printk("TX frame 1519B %lld\n",    stats->tx_1519B_pkt                 );
+	printk("TX bytes jumbo %lld\n",    stats->tx_jumbo_bytes               );
+	printk("TX frame jumbo %lld\n",    stats->tx_jumbo_pkt                 );
+	printk("###############################################\n\n");
+    
+}
+#endif
+
+static void ctcmac_ethtool_get_stats(struct net_device *netdev, struct ethtool_regs *regs, void *regbuf)
+{
+	u32 mtu;
+	unsigned long flags;
+	struct ctcmac_pkt_stats *stats;
+	struct ctcmac_private *priv =  netdev_priv(netdev);
+
+	spin_lock_irqsave(&priv->reglock, flags);
+	stats = &pkt_stats[priv->index];
+	stats->rx_good_ucast_bytes      +=   readq(&priv->cpumac_mem->CpuMacStatsRam0[0]);
+	stats->rx_good_ucast_pkt        +=   readq(&priv->cpumac_mem->CpuMacStatsRam0[2]);
+	stats->rx_good_mcast_bytes      +=   readq(&priv->cpumac_mem->CpuMacStatsRam1[0]);
+	stats->rx_good_mcast_pkt        +=   readq(&priv->cpumac_mem->CpuMacStatsRam1[2]);
+	stats->rx_good_bcast_bytes      +=   readq(&priv->cpumac_mem->CpuMacStatsRam2[0]);
+	stats->rx_good_bcast_pkt        +=   readq(&priv->cpumac_mem->CpuMacStatsRam2[2]);
+	stats->rx_good_pause_bytes      +=   readq(&priv->cpumac_mem->CpuMacStatsRam3[0]) ;
+	stats->rx_good_pause_pkt        +=   readq(&priv->cpumac_mem->CpuMacStatsRam3[2]) ;
+	stats->rx_good_pfc_bytes        +=   readq(&priv->cpumac_mem->CpuMacStatsRam4[0]) ;
+	stats->rx_good_pfc_pkt          +=   readq(&priv->cpumac_mem->CpuMacStatsRam4[2]) ;
+	stats->rx_good_control_bytes    +=   readq(&priv->cpumac_mem->CpuMacStatsRam5[0]) ;
+	stats->rx_good_control_pkt      +=   readq(&priv->cpumac_mem->CpuMacStatsRam5[2]) ;
+	stats->rx_fcs_error_bytes       +=   readq(&priv->cpumac_mem->CpuMacStatsRam6[0]) ;
+	stats->rx_fcs_error_pkt         +=   readq(&priv->cpumac_mem->CpuMacStatsRam6[2]) ;
+	stats->rx_mac_overrun_bytes     +=   readq(&priv->cpumac_mem->CpuMacStatsRam7[0]) ;
+	stats->rx_mac_overrun_pkt       +=   readq(&priv->cpumac_mem->CpuMacStatsRam7[2]) ;
+	stats->rx_good_63B_bytes        +=   readq(&priv->cpumac_mem->CpuMacStatsRam8[0]) ;
+	stats->rx_good_63B_pkt          +=   readq(&priv->cpumac_mem->CpuMacStatsRam8[2]) ;
+	stats->rx_bad_63B_bytes         +=   readq(&priv->cpumac_mem->CpuMacStatsRam9[0]) ;
+	stats->rx_bad_63B_pkt           +=   readq(&priv->cpumac_mem->CpuMacStatsRam9[2]) ;
+	stats->rx_good_mtu2B_bytes      +=   readq(&priv->cpumac_mem->CpuMacStatsRam10[0]);
+	stats->rx_good_mtu2B_pkt        +=   readq(&priv->cpumac_mem->CpuMacStatsRam10[2]);
+	stats->rx_bad_mtu2B_bytes       +=   readq(&priv->cpumac_mem->CpuMacStatsRam11[0]);
+	stats->rx_bad_mtu2B_pkt         +=   readq(&priv->cpumac_mem->CpuMacStatsRam11[2]);
+	stats->rx_good_jumbo_bytes      +=   readq(&priv->cpumac_mem->CpuMacStatsRam12[0]);
+	stats->rx_good_jumbo_pkt        +=   readq(&priv->cpumac_mem->CpuMacStatsRam12[2]);
+	stats->rx_bad_jumbo_bytes       +=   readq(&priv->cpumac_mem->CpuMacStatsRam13[0]);
+	stats->rx_bad_jumbo_pkt         +=   readq(&priv->cpumac_mem->CpuMacStatsRam13[2]);
+	stats->rx_64B_bytes             +=   readq(&priv->cpumac_mem->CpuMacStatsRam14[0]);
+	stats->rx_64B_pkt               +=   readq(&priv->cpumac_mem->CpuMacStatsRam14[2]);
+	stats->rx_127B_bytes            +=   readq(&priv->cpumac_mem->CpuMacStatsRam15[0]);
+	stats->rx_127B_pkt              +=   readq(&priv->cpumac_mem->CpuMacStatsRam15[2]);
+	stats->rx_255B_bytes            +=   readq(&priv->cpumac_mem->CpuMacStatsRam16[0]);
+	stats->rx_255B_pkt              +=   readq(&priv->cpumac_mem->CpuMacStatsRam16[2]);
+	stats->rx_511B_bytes            +=   readq(&priv->cpumac_mem->CpuMacStatsRam17[0]);
+	stats->rx_511B_pkt              +=   readq(&priv->cpumac_mem->CpuMacStatsRam17[2]);
+	stats->rx_1023B_bytes           +=   readq(&priv->cpumac_mem->CpuMacStatsRam18[0]);
+	stats->rx_1023B_pkt             +=   readq(&priv->cpumac_mem->CpuMacStatsRam18[2]);
+	stats->rx_mtu1B_bytes           +=   readq(&priv->cpumac_mem->CpuMacStatsRam19[0]);
+	stats->rx_mtu1B_pkt             +=   readq(&priv->cpumac_mem->CpuMacStatsRam19[2]);
+	stats->tx_ucast_bytes           +=   readq(&priv->cpumac_mem->CpuMacStatsRam20[0]);
+	stats->tx_ucast_pkt             +=   readq(&priv->cpumac_mem->CpuMacStatsRam20[2]);
+	stats->tx_mcast_bytes           +=   readq(&priv->cpumac_mem->CpuMacStatsRam21[0]);
+	stats->tx_mcast_pkt             +=   readq(&priv->cpumac_mem->CpuMacStatsRam21[2]);
+	stats->tx_bcast_bytes           +=   readq(&priv->cpumac_mem->CpuMacStatsRam22[0]);
+	stats->tx_bcast_pkt             +=   readq(&priv->cpumac_mem->CpuMacStatsRam22[2]);
+	stats->tx_pause_bytes           +=   readq(&priv->cpumac_mem->CpuMacStatsRam23[0]);
+	stats->tx_pause_pkt             +=   readq(&priv->cpumac_mem->CpuMacStatsRam23[2]);
+	stats->tx_control_bytes         +=   readq(&priv->cpumac_mem->CpuMacStatsRam24[0]);
+	stats->tx_control_pkt           +=   readq(&priv->cpumac_mem->CpuMacStatsRam24[2]);
+	stats->tx_fcs_error_bytes       +=   readq(&priv->cpumac_mem->CpuMacStatsRam25[0]);
+	stats->tx_fcs_error_pkt         +=   readq(&priv->cpumac_mem->CpuMacStatsRam25[2]);
+	stats->tx_underrun_bytes        +=   readq(&priv->cpumac_mem->CpuMacStatsRam26[0]);
+	stats->tx_underrun_pkt          +=   readq(&priv->cpumac_mem->CpuMacStatsRam26[2]);
+	stats->tx_63B_bytes             +=   readq(&priv->cpumac_mem->CpuMacStatsRam27[0]);
+	stats->tx_63B_pkt               +=   readq(&priv->cpumac_mem->CpuMacStatsRam27[2]);
+	stats->tx_64B_bytes             +=   readq(&priv->cpumac_mem->CpuMacStatsRam28[0]);
+	stats->tx_64B_pkt               +=   readq(&priv->cpumac_mem->CpuMacStatsRam28[2]);
+	stats->tx_127B_bytes            +=   readq(&priv->cpumac_mem->CpuMacStatsRam29[0]);
+	stats->tx_127B_pkt              +=   readq(&priv->cpumac_mem->CpuMacStatsRam29[2]);
+	stats->tx_255B_bytes            +=   readq(&priv->cpumac_mem->CpuMacStatsRam30[0]);
+	stats->tx_255B_pkt              +=   readq(&priv->cpumac_mem->CpuMacStatsRam30[2]);
+	stats->tx_511B_bytes            +=   readq(&priv->cpumac_mem->CpuMacStatsRam31[0]);
+	stats->tx_511B_pkt              +=   readq(&priv->cpumac_mem->CpuMacStatsRam31[2]);
+	stats->tx_1023B_bytes           +=   readq(&priv->cpumac_mem->CpuMacStatsRam32[0]);
+	stats->tx_1023B_pkt             +=   readq(&priv->cpumac_mem->CpuMacStatsRam32[2]);
+	stats->tx_mtu1_bytes           +=   readq(&priv->cpumac_mem->CpuMacStatsRam33[0]);
+	stats->tx_mtu1_pkt             +=   readq(&priv->cpumac_mem->CpuMacStatsRam33[2]);
+	stats->tx_mtu2_bytes           +=   readq(&priv->cpumac_mem->CpuMacStatsRam34[0]);
+	stats->tx_mtu2_pkt             +=   readq(&priv->cpumac_mem->CpuMacStatsRam34[2]);
+	stats->tx_jumbo_bytes           +=   readq(&priv->cpumac_mem->CpuMacStatsRam35[0]);
+	stats->tx_jumbo_pkt             +=   readq(&priv->cpumac_mem->CpuMacStatsRam35[2]);
+	mtu                                      =   readl(&priv->cpumac_reg->CpuMacStatsCfg[1]);
+	stats->mtu1                         =  mtu & 0x3fff;
+	stats->mtu2                         =  (mtu>>16) & 0x3fff;
+	spin_unlock_irqrestore(&priv->reglock, flags);
+
+	memcpy(regbuf, (void *)stats, sizeof(struct ctcmac_pkt_stats));
+
+	//ctcmac_ethtool_dump_stats(stats, priv->index);
+}
+
+static int ctcmac_ethtool_get_eeprom_len(struct net_device *netdev)
+{
+	return 0x40000;
+}
+
+static int ctcmac_ethtool_get_regs_len(struct net_device *netdev)
+{
+	return sizeof(struct ctcmac_pkt_stats);
+}
+
+const struct ethtool_ops ctcmac_ethtool_test_ops = {
+	.get_eeprom	       = ctcmac_ethtool_get_eeprom,
+	.set_eeprom	       = ctcmac_ethtool_set_eeprom,
+	.get_eeprom_len    = ctcmac_ethtool_get_eeprom_len,
+	.get_regs		       = ctcmac_ethtool_get_stats,
+	.get_regs_len		 = ctcmac_ethtool_get_regs_len,
+};
+
+static void clrsetbits(unsigned __iomem *addr, u32 clr, u32 set)
+{
+	writel((readl(addr) & ~(clr)) | (set) , addr);
+}
+
+static u32 ctcmac_regr(unsigned __iomem *addr)
+{
+	u32 val;
+	val = readl(addr);
+	return val;
+}
+
+static void ctcmac_regw(unsigned __iomem *addr, u32 val)
+{
+	writel(val, addr);
+}
+
+static inline int ctcmac_rxbd_unused(struct ctcmac_priv_rx_q *rxq)
+{
+	if (rxq->next_to_clean > rxq->next_to_use)
+		return rxq->next_to_clean - rxq->next_to_use - 1;
+
+	return rxq->rx_ring_size + rxq->next_to_clean - rxq->next_to_use - 1;
+}
+
+static int ctcmac_alloc_tx_queues(struct ctcmac_private *priv)
+{
+	int i;
+
+	for (i = 0; i < priv->num_tx_queues; i++) {
+		priv->tx_queue[i] = kzalloc(sizeof(struct ctcmac_priv_tx_q),
+				    GFP_KERNEL);
+		if (!priv->tx_queue[i])
+			return -ENOMEM;
+
+		priv->tx_queue[i]->tx_skbuff = NULL;
+		priv->tx_queue[i]->qindex = i;
+		priv->tx_queue[i]->dev = priv->ndev;
+		spin_lock_init(&(priv->tx_queue[i]->txlock));
+	}
+	return 0;
+}
+
+static int ctcmac_alloc_rx_queues(struct ctcmac_private *priv)
+{
+	int i;
+
+	for (i = 0; i < priv->num_rx_queues; i++) {
+	    priv->rx_queue[i] = kzalloc(sizeof(struct ctcmac_priv_rx_q),
+	        	    GFP_KERNEL);
+	    if (!priv->rx_queue[i])
+		return -ENOMEM;
+
+	    priv->rx_queue[i]->qindex = i;
+	    priv->rx_queue[i]->ndev = priv->ndev;
+	}
+	return 0;
+}
+
+static void ctcmac_unmap_io_space(struct ctcmac_private *priv)
+{
+	if(priv->iobase)
+		iounmap(priv->iobase);
+}
+
+static void ctcmac_free_tx_queues(struct ctcmac_private *priv)
+{
+	int i;
+
+	for (i = 0; i < priv->num_tx_queues; i++){
+		if(priv->tx_queue[i])
+			kfree(priv->tx_queue[i]);
+	}   
+}
+
+static void ctcmac_free_rx_queues(struct ctcmac_private *priv)
+{
+	int i;
+
+	for (i = 0; i < priv->num_rx_queues; i++){
+		if(priv->rx_queue[i])
+			kfree(priv->rx_queue[i]);
+	}
+}
+
+static void ctcmac_free_dev(struct ctcmac_private *priv)
+{
+	if(priv->ndev)
+		free_netdev(priv->ndev);
+}
+ 
+static int ctcmac_of_init(struct platform_device *ofdev, struct net_device **pdev)
+{
+	int err = 0, index;
+	const char *ctype;
+	struct net_device *dev = NULL;
+	struct ctcmac_private *priv = NULL;
+	unsigned int num_tx_qs, num_rx_qs;
+	struct device_node *np = ofdev->dev.of_node;
+
+	num_tx_qs = CTCMAC_TX_QUEUE_MAX;
+	num_rx_qs = CTCMAC_RX_QUEUE_MAX;
+
+	*pdev = alloc_etherdev_mq(sizeof(*priv), num_tx_qs);
+	dev = *pdev;
+	if (NULL == dev)
+		return -ENOMEM;
+
+	priv = netdev_priv(dev);
+	priv->ndev = dev;
+	priv->ofdev = ofdev;
+	priv->dev = &ofdev->dev;
+	priv->dev->coherent_dma_mask = DMA_BIT_MASK(64);
+	priv->num_tx_queues = num_tx_qs;
+	netif_set_real_num_rx_queues(dev, num_rx_qs);
+	priv->num_rx_queues = num_rx_qs;
+
+	priv->iobase = of_iomap(np, 0);
+	priv->cpumac_reg = priv->iobase + CPUMAC_REG_BASE;
+	priv->cpumac_mem = priv->iobase + CPUMAC_MEM_BASE;
+	priv->cpumacu_reg = of_iomap(np, 1) + CPUMACUNIT_REG_BASE;
+	g_cpumacu_reg = priv->cpumacu_reg;
+
+	err = of_property_read_u32(np, "index", &index);
+	if((err == 0))
+		priv->index = index;
+	else
+		priv->index = 0;
+
+	err = of_property_read_string(np, "phy-connection-type", &ctype);
+	if((err == 0) && !strncmp(ctype, "sgmii", 5))
+		priv->interface = PHY_INTERFACE_MODE_SGMII;
+	else
+		priv->interface = PHY_INTERFACE_MODE_MII;
+
+	priv->supported = SUPPORTED_10baseT_Full | SUPPORTED_10baseT_Half;
+	err = of_property_read_string(np, "capability-100M", &ctype);
+	if((err == 0) && !strncmp(ctype, "support", 7))
+		priv->supported |= SUPPORTED_100baseT_Full | SUPPORTED_100baseT_Half;
+
+	err = of_property_read_string(np, "capability-1000M", &ctype);
+	if((err == 0) && !strncmp(ctype, "support", 7))
+		priv->supported |= SUPPORTED_1000baseT_Full;
+
+	priv->phy_node = of_parse_phandle(np, "phy-handle", 0);
+
+	priv->irqinfo[CTCMAC_NORMAL].irq = irq_of_parse_and_map(np, 0);
+	priv->irqinfo[CTCMAC_FUNC].irq = irq_of_parse_and_map(np, 1);
+	priv->irqinfo[CTCMAC_UNIT].irq = irq_of_parse_and_map(np, 2);
+
+	return 0;
+
+}
+
+static int startup_ctcmac(struct net_device *ndev)
+{
+	int i;
+	int err;
+	struct ctcmac_private *priv = netdev_priv(ndev);
+
+	if(ctcmac_alloc_tx_queues(priv))
+		return -1;
+
+	if(ctcmac_alloc_rx_queues(priv))
+		return -1;
+
+	/* Initializing some of the rx/tx queue level parameters */
+	for (i = 0; i < priv->num_tx_queues; i++) {
+		priv->tx_queue[i]->tx_ring_size = test_param[priv->index].ring_size;
+		priv->tx_queue[i]->num_txbdfree = test_param[priv->index].ring_size;
+	}
+
+	for (i = 0; i < priv->num_rx_queues; i++) {
+		priv->rx_queue[i]->rx_ring_size = test_param[priv->index].ring_size;
+	}
+
+	ctcmac_hw_init(priv);
+
+	err = ctcmac_alloc_skb_resources(ndev);
+	if (err)
+		return err;
+
+	smp_mb__before_atomic();
+	clear_bit(CTCMAC_DOWN, &priv->state);
+	smp_mb__after_atomic();
+
+	cpumac_start(priv);
+	/* force link state update after mac reset */
+	priv->oldlink = 0;
+	priv->oldspeed = 0;
+	priv->oldduplex = -1;
+
+	phy_start(ndev->phydev);
+
+	napi_enable(&priv->napi_rx);
+	napi_enable(&priv->napi_tx);
+
+	netif_tx_wake_all_queues(ndev);
+
+	return 0;
+}
+
+static void stop_ctcmac(struct net_device *ndev)
+{
+	struct ctcmac_private *priv = netdev_priv(ndev);
+
+	/* disable ints and gracefully shut down Rx/Tx DMA */
+	cpumac_halt(priv);	
+
+	netif_tx_stop_all_queues(ndev);
+
+	smp_mb__before_atomic();
+	set_bit(CTCMAC_DOWN, &priv->state);
+	smp_mb__after_atomic();
+	napi_disable(&priv->napi_rx);
+	napi_disable(&priv->napi_tx);
+	phy_stop(ndev->phydev);
+	ctcmac_free_skb_resources(priv);
+}
+
+static void ctcmac_reset(struct net_device *ndev)
+{    
+	struct ctcmac_private *priv = netdev_priv(ndev);
+	while (test_and_set_bit_lock(CTCMAC_RESETTING, &priv->state))
+		cpu_relax();
+
+	stop_ctcmac(ndev);    
+	startup_ctcmac(ndev);    
+	clear_bit_unlock(CTCMAC_RESETTING, &priv->state);
+}
+
+/* ctcmac_reset_task gets scheduled when a packet has not been
+ * transmitted after a set amount of time.
+ * For now, assume that clearing out all the structures, and
+ * starting over will fix the problem.
+ */
+static void ctcmac_reset_task(struct work_struct *work)
+{
+	struct ctcmac_private *priv = container_of(work, struct ctcmac_private,
+						 reset_task);
+	ctcmac_reset(priv->ndev);
+}
+
+static int ctcmac_rxbd_used_untreated(struct ctcmac_private *priv, int qidx)
+{
+	u32 count;
+
+	if(qidx){
+		count = readl(&priv->cpumac_reg->CpuMacDescMon[2]);
+		return count & 0xffff;
+	}
+
+	count = readl(&priv->cpumac_reg->CpuMacDescMon[1]);
+
+	return (count >> 16 ) & 0xffff;
+}
+
+static int ctcmac_txbd_used_untreated(struct ctcmac_private *priv)
+{
+	u32 count;
+
+	count = readl(&priv->cpumac_reg->CpuMacDescMon[2]);
+
+	return (count >> 16 ) & 0xffff;
+}
+
+static bool ctcmac_add_rx_frag(struct ctcmac_rx_buff *rxb, u32 lstatus,
+			     struct sk_buff *skb, bool first)
+{
+	struct page *page = rxb->page;
+	unsigned int size = (lstatus & CPU_MAC_DESC_INTF_W1_DESC_SIZE_MASK)>>8;
+
+	if (likely(first)) {
+		skb_put(skb, size);
+	} else {
+		skb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page,
+				rxb->page_offset, size, CTCMAC_RXB_TRUESIZE);
+	}
+
+	/* try reuse page */
+	if (unlikely(page_count(page) != 1))
+		return false;
+
+	/* change offset to the other half */
+	rxb->page_offset ^= CTCMAC_RXB_TRUESIZE;
+
+	page_ref_inc(page);
+
+	return true;
+}
+
+static void ctcmac_reuse_rx_page(struct ctcmac_priv_rx_q *rxq,
+			       struct ctcmac_rx_buff *old_rxb)
+{
+	struct ctcmac_rx_buff *new_rxb;
+	u16 nta = rxq->next_to_alloc;
+
+	new_rxb = &rxq->rx_buff[nta];
+
+	/* find next buf that can reuse a page */
+	nta++;
+	rxq->next_to_alloc = (nta < rxq->rx_ring_size) ? nta : 0;
+
+	/* copy page reference */
+	*new_rxb = *old_rxb;
+
+	/* sync for use by the device */
+	dma_sync_single_range_for_device(rxq->dev, old_rxb->dma,
+					 old_rxb->page_offset,
+					 CTCMAC_RXB_TRUESIZE, DMA_FROM_DEVICE);
+}
+
+static struct sk_buff *ctcmac_get_next_rxbuff(struct ctcmac_priv_rx_q *rx_queue,
+					    u32 lstatus, struct sk_buff *skb)
+{
+	struct ctcmac_rx_buff *rxb = &rx_queue->rx_buff[rx_queue->next_to_clean];
+	struct page *page = rxb->page;
+	bool first = false;
+
+	if (likely(!skb)) {
+		void *buff_addr = page_address(page) + rxb->page_offset;
+		skb = build_skb(buff_addr, CTCMAC_SKBFRAG_SIZE);
+		if (unlikely(!skb)) {
+			return NULL;
+		}
+		first = true;
+	}
+
+	dma_sync_single_range_for_cpu(rx_queue->dev, rxb->dma, rxb->page_offset,
+				      CTCMAC_RXB_TRUESIZE, DMA_FROM_DEVICE);
+
+	if (ctcmac_add_rx_frag(rxb, lstatus, skb, first)) {
+		/* reuse the free half of the page */
+		ctcmac_reuse_rx_page(rx_queue, rxb);
+	} else {
+		/* page cannot be reused, unmap it */
+		dma_unmap_page(rx_queue->dev, rxb->dma,
+		            PAGE_SIZE, DMA_FROM_DEVICE);
+	}
+
+	/* clear rxb content */
+	rxb->page = NULL;
+
+    return skb;
+}
+
+static void ctcmac_process_frame(struct net_device *ndev, struct sk_buff *skb)
+{
+	struct ctcmac_private *priv = netdev_priv(ndev);
+
+	if (test_param[priv->index].rxts_en){
+		struct skb_shared_hwtstamps *shhwtstamps = skb_hwtstamps(skb);
+		u64 *ns = (u64 *) (skb->data + skb->len -8);
+
+		if (test_param[priv->index].rxts_dump){
+			printk(KERN_ERR "receive frame time stamp 0x%llx\n", *ns);
+		}
+
+		memset(shhwtstamps, 0, sizeof(*shhwtstamps));
+		shhwtstamps->hwtstamp = ns_to_ktime(be64_to_cpu(*ns));
+		skb_pull(skb, 8);
+		if (test_param[priv->index].rxts_dump){
+			printk(KERN_ERR "receive frame time stamp %lld\n", shhwtstamps->hwtstamp.tv64);
+		}
+	}
+
+	skb->protocol = eth_type_trans(skb, ndev);
+}
+
+static int ctc_mac_serdes_init(struct ctcmac_private *priv)
+{
+	int ret=0;
+	u32 status;
+	int delay_ms = 10;
+	
+	/* reset serdes */
+	writel(0x83806000, &priv->cpumacu_reg->CpuMacUnitHssCfg[0]);
+	writel(0x28061800, &priv->cpumacu_reg->CpuMacUnitHssCfg[2]);
+	writel(0x0026c03a, &priv->cpumacu_reg->CpuMacUnitHssCfg[6]);
+	writel(0x28061810, &priv->cpumacu_reg->CpuMacUnitHssCfg[8]);
+	writel(0x0026c03a, &priv->cpumacu_reg->CpuMacUnitHssCfg[12]);
+
+	/* offset0 bit1 BlkRstN */
+	writel(0x83806002, &priv->cpumacu_reg->CpuMacUnitHssCfg[0]);
+	mdelay(delay_ms);
+
+	writel(0x80002309, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x80000842, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x8000ea45, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+
+	/* serdes 0 init */
+	writel(0x83000a05, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x83002008, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x8300640f, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x83000214, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x83008015, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x83000116, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x83001817, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x83003018, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x83000e24, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x83008226, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x83001f27, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x83002028, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x83002829, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x8300302a, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x83002038, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x8300223a, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x8300523b, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x83002040, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x8300f141, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x8300014a, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x8300e693, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+
+	/* serdes 1 init */
+	writel(0x84000a05, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x84002008, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x8400640f, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x84000214, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x84008015, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x84000116, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x84001817, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x84003018, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x84000e24, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x84008226, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x84001f27, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x84002028, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x84002829, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x8400302a, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x84002038, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x8400223a, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x8400523b, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x84002040, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x8400f141, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x8400014a, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+	mdelay(delay_ms);
+	writel(0x8400e693, &priv->cpumacu_reg->CpuMacUnitHssRegAccCtl);
+
+	/* serdes post release */
+	writel(0x83806003, &priv->cpumacu_reg->CpuMacUnitHssCfg[0]);
+	writel(0x83826003, &priv->cpumacu_reg->CpuMacUnitHssCfg[0]);
+	
+	writel(0x28061801, &priv->cpumacu_reg->CpuMacUnitHssCfg[2]);
+	writel(0x28061c01, &priv->cpumacu_reg->CpuMacUnitHssCfg[2]);
+	writel(0x28071c01, &priv->cpumacu_reg->CpuMacUnitHssCfg[2]);
+	
+	writel(0x28061811, &priv->cpumacu_reg->CpuMacUnitHssCfg[8]);
+	writel(0x28061c11, &priv->cpumacu_reg->CpuMacUnitHssCfg[8]);
+	writel(0x28071c11, &priv->cpumacu_reg->CpuMacUnitHssCfg[8]);
+
+	ret = readl_poll_timeout(&priv->cpumacu_reg->CpuMacUnitHssMon[1], status, 
+		status & CPU_MAC_UNIT_HSS_MON_W1_MON_HSS_L0_DFE_RST_DONE, 1000, 2000000);
+	if(ret){
+		netdev_dbg(priv->ndev,"%s:wait for hss reset done fail with CpuMacUnitHssMon[1]:0x%x\n", 
+			priv->ndev->name, readl(&priv->cpumacu_reg->CpuMacUnitHssMon[1]));
+	}
+	mdelay(delay_ms);
+
+	return 0;
+}
+
+static void ctcmac_hw_init(struct ctcmac_private *priv)
+{
+	int i;
+	u32 val;
+	int use_extram = 0;
+	
+	/* two cpumac access the same cpumac unit register */
+	spin_lock_irq(&global_reglock);   
+	if(priv->index == 0){
+		clrsetbits(&priv->cpumacu_reg->CpuMacUnitResetCtl, 
+		    CPU_MAC_UNIT_RESET_CTL_W0_RESET_CORE_BASE, CPU_MAC_UNIT_RESET_CTL_W0_RESET_CORE_CPU_MAC0);
+		clrsetbits(&priv->cpumacu_reg->CpuMacUnitResetCtl, 
+		    CPU_MAC_UNIT_RESET_CTL_W0_RESET_CORE_CPU_MAC0, 0);
+	}else{
+		clrsetbits(&priv->cpumacu_reg->CpuMacUnitResetCtl, 
+		    CPU_MAC_UNIT_RESET_CTL_W0_RESET_CORE_BASE, CPU_MAC_UNIT_RESET_CTL_W0_RESET_CORE_CPU_MAC1);
+		clrsetbits(&priv->cpumacu_reg->CpuMacUnitResetCtl, 
+		    CPU_MAC_UNIT_RESET_CTL_W0_RESET_CORE_CPU_MAC1, 0);
+	}
+
+	clrsetbits(&priv->cpumacu_reg->CpuMacUnitTsCfg, 
+	            0, CPU_MAC_UNIT_TS_CFG_W0_CFG_FORCE_S_AND_NS_EN);
+
+	spin_unlock_irq(&global_reglock);
+	mdelay(10);
+	
+	clrsetbits(&priv->cpumac_reg->CpuMacInit, 0, CPU_MAC_INIT_DONE_W0_INIT_DONE);
+	udelay(1);
+	
+	if (priv->interface == PHY_INTERFACE_MODE_SGMII){
+		/* switch to sgmii and enable auto nego */
+		val = readl(&priv->cpumac_reg->CpuMacSgmiiAutoNegCfg);
+		val &= ~(CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_AN_ENABLE_MASK
+		              | CPU_MAC_SGMII_AUTO_NEG_CFG_W0_CFG_AN_MODE_MASK);
+		val |= (CSA_SGMII_MD_MASK | CSA_EN);
+		writel(val, &priv->cpumac_reg->CpuMacSgmiiAutoNegCfg);
+	}
+	
+	clrsetbits(&priv->cpumac_reg->CpuMacSgmiiCfg[0], 
+	    CPU_MAC_SGMII_CFG_W0_CFG_MII_RX_LINK_FILTER_EN, 0);
+	clrsetbits(&priv->cpumac_reg->CpuMacSgmiiCfg[0], 
+	    0, CPU_MAC_SGMII_CFG_W0_CFG_TX_EVEN_IGNORE);
+
+	clrsetbits(&priv->cpumac_reg->CpuMacAxiCfg, 
+	    0, CPU_MAC_AXI_CFG_W0_CFG_AXI_RD_D_WORD_SWAP_EN);
+	clrsetbits(&priv->cpumac_reg->CpuMacAxiCfg, 
+	    0, CPU_MAC_AXI_CFG_W0_CFG_AXI_WR_D_WORD_SWAP_EN);
+
+	clrsetbits(&priv->cpumac_reg->CpuMacGmacCfg[0], 
+	    0, CPU_MAC_GMAC_CFG_W0_CFG_RX_OVERRUN_DROP_EN
+	        |CPU_MAC_GMAC_CFG_W0_CFG_RX_OVERSIZE_DROP_EN);
+
+	clrsetbits(&priv->cpumac_reg->CpuMacGmacCfg[2], 
+	    CPU_MAC_GMAC_CFG_W2_CFG_TX_STRIP_CRC_EN, 0);
+
+	clrsetbits(&priv->cpumac_reg->CpuMacGmacCfg[2], 
+	    0, CPU_MAC_GMAC_CFG_W2_CFG_TX_CUT_THROUGH_EN);
+
+	for (i = 0; i < priv->num_tx_queues; i++) {
+		if(priv->tx_queue[i]->tx_ring_size > CTCMAC_INTERNAL_RING_SIZE){
+			use_extram = 1;
+			break;
+		}
+	}
+
+	for (i = 0; i < priv->num_rx_queues; i++) {
+		if(priv->rx_queue[i]->rx_ring_size > CTCMAC_INTERNAL_RING_SIZE){
+			use_extram = 1;
+			break;
+		}
+	}
+	    
+	if(use_extram){
+		spin_lock_irq(&global_reglock); 
+		//printk(KERN_ERR "ctcmac_hw_init enable extram %d\n", priv->index);
+		regmap_read(regmap_base, offsetof(struct SysCtl_regs, SysMemCtl), &val);
+		val |= SYS_MEM_CTL_W0_CFG_RAM_MUX_EN;
+		regmap_write(regmap_base, offsetof(struct SysCtl_regs, SysMemCtl), val);
+		spin_unlock_irq(&global_reglock); 
+		if(priv->index == 0){
+			ctcmac_regw(&priv->cpumac_reg->CpuMacExtRamCfg[1], CTCMAC0_EXSRAM_BASE);
+		}else{
+			ctcmac_regw(&priv->cpumac_reg->CpuMacExtRamCfg[1], CTCMAC1_EXSRAM_BASE);
+		}
+		ctcmac_regw(&priv->cpumac_reg->CpuMacExtRamCfg[0], test_param[priv->index].ring_size);
+		clrsetbits(&priv->cpumac_reg->CpuMacExtRamCfg[0], 
+		    0, CPU_MAC_EXT_RAM_CFG_W0_CFG_EXT_RAM_EN);
+		
+	}else{
+		//printk(KERN_ERR "ctcmac_hw_init disable extram %d\n", priv->index);
+		clrsetbits(&priv->cpumac_reg->CpuMacExtRamCfg[0], 
+		    CPU_MAC_EXT_RAM_CFG_W0_CFG_EXT_RAM_EN, 0);
+		spin_lock_irq(&global_reglock); 
+		regmap_read(regmap_base, offsetof(struct SysCtl_regs, SysMemCtl), &val);
+		val &= ~SYS_MEM_CTL_W0_CFG_RAM_MUX_EN;
+		regmap_write(regmap_base, offsetof(struct SysCtl_regs, SysMemCtl), val);
+		spin_unlock_irq(&global_reglock); 
+	}
+
+	if (test_param[priv->index].rxts_en){
+		clrsetbits(&priv->cpumac_reg->CpuMacGmacCfg[0], 
+		    0, CPU_MAC_GMAC_CFG_W0_CFG_RX_TS_EN);
+	}
+
+	if (test_param[priv->index].txts_en){
+		clrsetbits(&priv->cpumac_reg->CpuMacGmacCfg[2], 
+		    CPU_MAC_GMAC_CFG_W2_CFG_TX_WAIT_CAPTURE_TS,  
+		    CPU_MAC_GMAC_CFG_W2_CFG_TX_HDR_INFO_EN);
+	}
+
+	/* clear all interrupt */
+	ctcmac_regw(&priv->cpumac_reg->CpuMacInterruptFunc[1], 0xffffffff);
+	ctcmac_regw(&priv->cpumac_reg->CpuMacInterruptNormal[1], 0xffffffff);
+	/* mask all interrupt */
+	ctcmac_regw(&priv->cpumac_reg->CpuMacInterruptFunc[2], 0xffffffff);
+	ctcmac_regw(&priv->cpumac_reg->CpuMacInterruptNormal[2], 0xffffffff);
+
+	printk("ctcmac_hw_init 0x%x\n", priv->ndev->flags);
+    
+}
+
+/* update cpumac speed when phy linkup speed changed */
+static noinline void ctcmac_update_link_state(struct ctcmac_private *priv, struct phy_device *phydev)
+{
+	int timeout=2000;
+	u32 mon, cfg_rep, cfg_smp;
+	int speed = phydev->speed;
+
+	if (priv->interface != PHY_INTERFACE_MODE_SGMII)
+		return ;
+
+	if(netif_msg_link(priv)){
+		netdev_dbg(priv->ndev,"link up speed is %d\n", speed);
+	}
+
+	if (phydev->link) {
+		cfg_rep = readl(&priv->cpumac_reg->CpuMacSgmiiCfg[0]);
+		cfg_smp = readl(&priv->cpumac_reg->CpuMacSgmiiCfg[1]);
+		cfg_rep &= ~CSC_REP_MASK;
+		cfg_smp &= ~CSC_SMP_MASK;
+		if(speed == 1000){        
+			cfg_rep |= CSC_1000M;
+			cfg_smp |= CSC_1000M;
+		}
+		else if(speed == 100){
+			cfg_rep |= CSC_100M;
+			cfg_smp |= CSC_100M;
+		}
+		else if(speed == 10){
+			cfg_rep |= CSC_10M;
+			cfg_smp |= CSC_10M;
+		}
+		else{
+			return;
+		}
+		writel(cfg_rep, &priv->cpumac_reg->CpuMacSgmiiCfg[0]);
+		writel(cfg_smp, &priv->cpumac_reg->CpuMacSgmiiCfg[1]);
+
+		while(timeout--){
+			mon = readl(&priv->cpumac_reg->CpuMacSgmiiMon[0]);
+			if((mon & CSM_ANST_MASK) == 6){
+				break;
+			}
+
+			mdelay(1);
+		}
+
+		if((mon & CSM_ANST_MASK) != 6)
+		{
+			printk("Error! when phy link up, auto-neg status %d is not right.\n", mon);
+		}
+		if (!priv->oldlink)
+			priv->oldlink = 1;
+		
+	}else{
+		priv->oldlink = 0;
+		priv->oldspeed = 0;
+		priv->oldduplex = -1;
+	}
+
+	
+	return;
+}
+
+static void adjust_link(struct net_device *dev)
+{
+	struct ctcmac_private *priv = netdev_priv(dev);
+	struct phy_device *phydev = dev->phydev;
+
+	if (unlikely(phydev->link != priv->oldlink ||
+		     (phydev->link && (phydev->duplex != priv->oldduplex ||
+				       phydev->speed != priv->oldspeed))))
+		ctcmac_update_link_state(priv, phydev);
+}
+
+/* Initializes driver's PHY state, and attaches to the PHY.
+ * Returns 0 on success.
+ */
+static int ctcmac_init_phy(struct net_device *dev)
+{
+	struct ctcmac_private *priv = netdev_priv(dev);
+	phy_interface_t interface;
+	struct phy_device *phydev;
+
+	priv->oldlink = 0;
+	priv->oldspeed = 0;
+	priv->oldduplex = -1;
+
+	interface = priv->interface;
+
+	phydev = of_phy_connect(dev, priv->phy_node, &adjust_link, 0,
+				interface);
+	if (!phydev) {
+		dev_err(&dev->dev, "could not attach to PHY\n");
+		return -ENODEV;
+	}
+
+	/* Remove any features not supported by the controller */
+	phydev->supported = priv->supported;
+	phydev->advertising = phydev->supported;
+
+	return 0;
+}
+
+static irqreturn_t ctcmac_receive(int irq, struct ctcmac_private *priv)
+{
+	unsigned long flags;
+
+	if (likely(napi_schedule_prep(&priv->napi_rx))) {
+		/* disable interrupt */
+		spin_lock_irqsave(&priv->reglock, flags);
+		writel(CTCMAC_NOR_RX0_D|CTCMAC_NOR_RX1_D, &priv->cpumac_reg->CpuMacInterruptFunc[2]);
+		spin_unlock_irqrestore(&priv->reglock, flags);
+		__napi_schedule(&priv->napi_rx);
+	} else {
+		/* clear interrupt */
+		writel(CTCMAC_NOR_RX0_D|CTCMAC_NOR_RX1_D, &priv->cpumac_reg->CpuMacInterruptFunc[1]);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t ctcmac_transmit(int irq, struct ctcmac_private *priv)
+{
+	unsigned long flags;
+
+	if (likely(napi_schedule_prep(&priv->napi_tx))) {
+		/* disable interrupt */
+		spin_lock_irqsave(&priv->reglock, flags);
+		writel(CTCMAC_NOR_TX_D, &priv->cpumac_reg->CpuMacInterruptFunc[2]);
+		spin_unlock_irqrestore(&priv->reglock, flags);
+		__napi_schedule(&priv->napi_tx);
+
+	} else {
+		/* clear interrupt */
+		writel(CTCMAC_NOR_TX_D, &priv->cpumac_reg->CpuMacInterruptFunc[1]);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t ctcmac_func(int irq, void *data)
+{
+	u32 event, stat, mask;
+	struct ctcmac_private *priv = (struct ctcmac_private *)data;
+
+	stat = ctcmac_regr(&priv->cpumac_reg->CpuMacInterruptFunc[0]);
+	mask = ctcmac_regr(&priv->cpumac_reg->CpuMacInterruptFunc[2]);
+	event = stat & ~mask;
+
+	if((event & CTCMAC_NOR_RX0_D) || (event & CTCMAC_NOR_RX1_D)){
+		ctcmac_receive(irq, priv);
+	}
+
+	if(event & CTCMAC_NOR_TX_D){
+		ctcmac_transmit(irq, priv);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t ctcmac_unit(int irq, void *data)
+{
+	struct CpuMacUnit_mems *mems = (struct CpuMacUnit_mems *)(g_cpumacu_reg+0x400-CPUMACUNIT_REG_BASE);
+
+	ctcmac_regw(&g_cpumacu_reg->CpuMacUnitInterruptFunc[2], 1);
+	ctcmac_regw(&g_cpumacu_reg->CpuMacUnitInterruptFunc[1], 1);
+
+	while(ctcmac_regr(&g_cpumacu_reg->CpuMacUnitFifoStatus)){
+		printk(KERN_ERR "Tx Capture time stamp in fifo 0x%x 0x%x 0x%x\n",
+		ctcmac_regr(&mems->CpuMacUnitTxCaptureTs0[0]),
+		ctcmac_regr(&mems->CpuMacUnitTxCaptureTs0[1]),
+		ctcmac_regr(&mems->CpuMacUnitTxCaptureTs0[2]));
+	}
+	ctcmac_regw(&g_cpumacu_reg->CpuMacUnitInterruptFunc[3], 1);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t ctcmac_normal(int irq, void *grp_id) //TODO by liuht
+{
+	return IRQ_HANDLED;
+}
+
+static int ctcmac_request_irq(struct ctcmac_private *priv)
+{
+	int err = 0;
+
+	err = request_irq(priv->irqinfo[CTCMAC_NORMAL].irq, ctcmac_normal, 0,
+			  priv->irqinfo[CTCMAC_NORMAL].name, priv);
+	if (err < 0) {
+		free_irq(priv->irqinfo[CTCMAC_NORMAL].irq, priv);
+	}
+	enable_irq_wake(priv->irqinfo[CTCMAC_NORMAL].irq);
+
+	err = request_irq(priv->irqinfo[CTCMAC_FUNC].irq, ctcmac_func, 0,
+			  priv->irqinfo[CTCMAC_FUNC].name, priv);
+	if (err < 0) {
+		free_irq(priv->irqinfo[CTCMAC_FUNC].irq, priv);
+	}
+	enable_irq_wake(priv->irqinfo[CTCMAC_FUNC].irq);
+
+	spin_lock_irq(&global_reglock);   
+	if(priv->irqinfo[CTCMAC_UNIT].irq && !cpumac_unit_irq_installed){
+		err = request_irq(priv->irqinfo[CTCMAC_UNIT].irq, ctcmac_unit, 0,
+				  "cpumac_unit", NULL);
+		if (err < 0) {
+			free_irq(priv->irqinfo[CTCMAC_UNIT].irq, NULL);
+			return err;
+		}
+		enable_irq_wake(priv->irqinfo[CTCMAC_UNIT].irq);
+		cpumac_unit_irq_installed =1;
+	}
+	spin_unlock_irq(&global_reglock);   
+
+	return err;
+}
+
+static void ctcmac_free_irq(struct ctcmac_private *priv)
+{   
+	free_irq(priv->irqinfo[CTCMAC_NORMAL].irq, priv);
+	free_irq(priv->irqinfo[CTCMAC_FUNC].irq, priv);
+
+	spin_lock_irq(&global_reglock);   
+	if(cpumac_unit_irq_installed == 1){
+		free_irq(priv->irqinfo[CTCMAC_UNIT].irq, NULL);
+		cpumac_unit_irq_installed = 0;
+	}
+	spin_unlock_irq(&global_reglock);   
+}
+
+static bool ctcmac_new_page(struct ctcmac_priv_rx_q *rxq, struct ctcmac_rx_buff *rxb)
+{
+	struct page *page;
+	dma_addr_t addr;
+
+	page = dev_alloc_page();
+	if (unlikely(!page))
+		return false;
+
+	addr = dma_map_page(rxq->dev, page, 0, PAGE_SIZE, DMA_FROM_DEVICE);
+	if (unlikely(dma_mapping_error(rxq->dev, addr))) {
+		__free_page(page);
+
+		return false;
+	}
+
+	rxb->dma = addr;
+	rxb->page = page;
+	rxb->page_offset = 0;
+
+	return true;
+}
+
+static void ctcmac_fill_rxbd(struct ctcmac_private *priv, struct ctcmac_rx_buff *rxb, int qidx)
+{
+	u32 desc_cfg_low, desc_cfg_high;
+	dma_addr_t bufaddr = rxb->dma + rxb->page_offset;
+
+	desc_cfg_low = (bufaddr - CTC_DDR_BASE)& CPU_MAC_DESC_INTF_W0_DESC_ADDR_31_0_MASK;
+	/* CPU_MAC_DESC_INTF_W1_DESC_SIZE:bit(8) */
+	desc_cfg_high = (test_param[priv->index].payload_size<<8) | 
+	    (((bufaddr- CTC_DDR_BASE) >> 32) & CPU_MAC_DESC_INTF_W1_DESC_ADDR_39_32_MASK);
+
+	spin_lock_irq(&priv->reglock);
+	if(qidx){
+		ctcmac_regw(&priv->cpumac_mem->CpuMacDescIntf1[0], desc_cfg_low);
+		smp_mb__before_atomic();
+		ctcmac_regw(&priv->cpumac_mem->CpuMacDescIntf1[1], desc_cfg_high);
+
+	}else{
+		ctcmac_regw(&priv->cpumac_mem->CpuMacDescIntf0[0], desc_cfg_low);
+		smp_mb__before_atomic();
+		ctcmac_regw(&priv->cpumac_mem->CpuMacDescIntf0[1], desc_cfg_high);
+	}
+
+	spin_unlock_irq(&priv->reglock);
+}
+
+static void ctcmac_fill_txbd(struct ctcmac_private *priv, struct ctcmac_desc_cfg *txdesc)
+{
+	u32 desc_cfg_low, desc_cfg_high;
+
+	desc_cfg_low = txdesc->addr_low;
+	/* CPU_MAC_DESC_INTF_W1_DESC_SIZE:bit(8) */
+	/* CPU_MAC_DESC_INTF_W1_DESC_SOP:bit(22) */
+	/* CPU_MAC_DESC_INTF_W1_DESC_EOP:bit(23) */
+	desc_cfg_high = txdesc->addr_high | 
+	    (txdesc->size << 8) |
+	    (txdesc->sop << 22) | 
+	    (txdesc->eop << 23);
+
+	spin_lock_irq(&priv->reglock);
+	ctcmac_regw(&priv->cpumac_mem->CpuMacDescIntf2[0], desc_cfg_low);
+	smp_mb__before_atomic();
+	ctcmac_regw(&priv->cpumac_mem->CpuMacDescIntf2[1], desc_cfg_high);
+	spin_unlock_irq(&priv->reglock);
+}
+
+static void ctcmac_get_txbd(struct ctcmac_private *priv)
+{
+	u32 lstatus;
+
+	spin_lock_irq(&priv->reglock);
+	lstatus = ctcmac_regr(&priv->cpumac_mem->CpuMacDescIntf2[0]);
+	smp_mb__before_atomic();
+	lstatus = ctcmac_regr(&priv->cpumac_mem->CpuMacDescIntf2[1]);
+	
+	spin_unlock_irq(&priv->reglock);
+}
+
+static void ctcmac_get_rxbd(struct ctcmac_private *priv, u32 *lstatus, int qidx)
+{    
+	spin_lock_irq(&priv->reglock);
+	if(qidx){
+		ctcmac_regr(&priv->cpumac_mem->CpuMacDescIntf1[0]);
+		*lstatus = ctcmac_regr(&priv->cpumac_mem->CpuMacDescIntf1[1]);
+	}else{
+		ctcmac_regr(&priv->cpumac_mem->CpuMacDescIntf0[0]);
+		*lstatus = ctcmac_regr(&priv->cpumac_mem->CpuMacDescIntf0[1]);
+	}
+	smp_mb__before_atomic();
+
+	spin_unlock_irq(&priv->reglock);
+}
+
+static void ctcmac_alloc_rx_buffs(struct ctcmac_priv_rx_q *rx_queue,
+				int alloc_cnt)
+{
+	int i;
+	int qidx = rx_queue->qindex;
+	struct ctcmac_rx_buff *rxb;
+	struct net_device *ndev = rx_queue->ndev;
+	struct ctcmac_private *priv = netdev_priv(ndev);
+
+	i = rx_queue->next_to_use;
+	rxb = &rx_queue->rx_buff[i];
+
+	while (alloc_cnt--) {
+		/* try reuse page */
+		if (unlikely(!rxb->page)) {
+			if (unlikely(!ctcmac_new_page(rx_queue, rxb))) {
+				break;
+			}
+		}
+
+		ctcmac_fill_rxbd(priv, rxb, qidx);
+		rxb++;
+
+		if (unlikely(++i == rx_queue->rx_ring_size)) {
+			i = 0;
+			rxb = rx_queue->rx_buff;
+		}
+	}
+
+	rx_queue->next_to_use = i;
+	rx_queue->next_to_alloc = i;
+}
+
+static int ctcmac_clean_rx_ring(struct ctcmac_priv_rx_q *rx_queue, int rx_work_limit)
+{
+	struct net_device *ndev = rx_queue->ndev;
+	struct ctcmac_private *priv = netdev_priv(ndev);
+	int i, howmany = 0;
+	struct sk_buff *skb = rx_queue->skb;
+	int cleaned_cnt = ctcmac_rxbd_unused(rx_queue);
+	unsigned int total_bytes = 0, total_pkts = 0;
+	int qidx = rx_queue->qindex;
+
+	/* Get the first full descriptor */
+	i = rx_queue->next_to_clean;
+
+	while (rx_work_limit--) {
+		u32 lstatus;
+
+		if (cleaned_cnt >= test_param[priv->index].ring_size/2) {
+			ctcmac_alloc_rx_buffs(rx_queue, cleaned_cnt);
+			cleaned_cnt = 0;
+		}
+
+		if(ctcmac_rxbd_used_untreated(priv, qidx)<=0)
+			break;
+
+		if(qidx != 0){
+			printk(KERN_ERR "rx queue %d rx packet!\n", qidx);
+		}
+		ctcmac_get_rxbd(priv, &lstatus, qidx);
+
+		/* fetch next to clean buffer from the ring */
+		skb = ctcmac_get_next_rxbuff(rx_queue, lstatus, skb);       
+		if (unlikely(!skb))
+			break;
+
+		cleaned_cnt++;
+		howmany++;
+
+		if (unlikely(++i == rx_queue->rx_ring_size))
+			i = 0;
+
+		rx_queue->next_to_clean = i;
+
+		/* fetch next buffer if not the last in frame */
+		if (!(lstatus & CPU_MAC_DESC_INTF_W1_DESC_EOP))
+			continue;
+
+		if (unlikely(lstatus & CPU_MAC_DESC_INTF_W1_DESC_ERR)) {
+			if (!test_param[priv->index].rxts_en){
+				/* discard faulty buffer */
+				dev_kfree_skb(skb);
+				skb = NULL;
+				rx_queue->stats.rx_dropped++;
+				pr_err("%s: Error with rx desc status 0x%x\n", ndev->name, lstatus);
+				continue;
+			}else{
+				pr_err("%s: Error with rx desc status 0x%x\n", ndev->name, lstatus);
+			}
+		}
+
+		/* Increment the number of packets */
+		total_pkts++;
+		total_bytes += skb->len;
+
+		skb_record_rx_queue(skb, rx_queue->qindex);    
+		ctcmac_process_frame(ndev, skb);
+		/* Send the packet up the stack */
+		napi_gro_receive(&rx_queue->napi_rx, skb);
+
+		skb = NULL;
+	}
+
+	/* Store incomplete frames for completion */
+	rx_queue->skb = skb;
+
+	rx_queue->stats.rx_packets += total_pkts;
+	rx_queue->stats.rx_bytes += total_bytes;
+
+	if (cleaned_cnt)
+		ctcmac_alloc_rx_buffs(rx_queue, cleaned_cnt);
+
+	return howmany;
+}
+
+static void ctcmac_clean_tx_ring(struct ctcmac_priv_tx_q *tx_queue)
+{
+	u16 next_to_clean;
+	int tqi = tx_queue->qindex;
+	struct sk_buff *skb;
+	struct netdev_queue *txq;
+	struct	ctcmac_tx_buff *tx_buff;
+	struct net_device *dev = tx_queue->dev;
+	struct ctcmac_private *priv = netdev_priv(dev);
+
+	txq = netdev_get_tx_queue(dev, tqi);
+	next_to_clean = tx_queue->next_to_clean;
+	while (ctcmac_txbd_used_untreated(priv)) {
+	    
+		ctcmac_get_txbd(priv);
+
+		tx_buff = &tx_queue->tx_buff[next_to_clean];
+		//printk(KERN_ERR "ctcmac_clean_tx_ring eth%d 0x%x 0x%x\n", priv->index, next_to_clean, tx_buff->alloc);
+		skb = tx_queue->tx_skbuff[next_to_clean];
+		dev_kfree_skb_any(skb);
+		tx_queue->tx_skbuff[next_to_clean] = NULL;
+
+		        
+		dma_unmap_single(priv->dev, tx_buff->dma,
+		    				 tx_buff->len, DMA_TO_DEVICE);
+		if(tx_buff->alloc){
+		    kfree(tx_buff->vaddr);
+		}
+
+		if((next_to_clean + 1) >=tx_queue->tx_ring_size){
+		    next_to_clean = 0;
+		}else{
+		    next_to_clean++; 
+		}
+
+		spin_lock(&tx_queue->txlock);
+		tx_queue->num_txbdfree++;
+		spin_unlock(&tx_queue->txlock);
+	}
+
+	/* If we freed a buffer, we can restart transmission, if necessary */
+	if (tx_queue->num_txbdfree &&
+		netif_tx_queue_stopped(txq) &&
+		!(test_bit(CTCMAC_DOWN, &priv->state))){
+		netif_wake_subqueue(priv->ndev, tqi);
+	}
+
+	tx_queue->next_to_clean = next_to_clean;
+}
+
+static int ctcmac_poll_rx_sq(struct napi_struct *napi, int budget)
+{
+	int qidx;
+	int work_done = 0;
+	int rx_work_limit;
+	struct ctcmac_private *priv =
+		container_of(napi, struct ctcmac_private, napi_rx);
+	struct ctcmac_priv_rx_q *rx_queue = NULL;
+
+	/* clear interrupt */
+	writel(CTCMAC_NOR_RX0_D|CTCMAC_NOR_RX1_D, 
+	    &priv->cpumac_reg->CpuMacInterruptFunc[1]);
+
+	rx_work_limit = budget;
+	for(qidx=priv->num_rx_queues-1; qidx>=0; qidx--){
+		rx_queue = priv->rx_queue[qidx];
+		work_done += ctcmac_clean_rx_ring(rx_queue, rx_work_limit);
+		rx_work_limit -= work_done;
+	}
+
+	if (work_done < budget) {
+		napi_complete(napi);
+		/* enable interrupt */
+		spin_lock_irq(&priv->reglock);
+		writel(CTCMAC_NOR_RX0_D|CTCMAC_NOR_RX1_D, 
+		&priv->cpumac_reg->CpuMacInterruptFunc[3]);
+		spin_unlock_irq(&priv->reglock);
+	}
+
+	return work_done;
+}
+
+static int ctcmac_poll_tx_sq(struct napi_struct *napi, int budget) //TODO by liuht
+{
+	struct ctcmac_private *priv =
+		container_of(napi, struct ctcmac_private, napi_tx);
+	struct ctcmac_priv_tx_q *tx_queue = priv->tx_queue[0];
+
+	/* clear interrupt */
+	writel(CTCMAC_NOR_TX_D, &priv->cpumac_reg->CpuMacInterruptFunc[1]);
+
+	ctcmac_clean_tx_ring(tx_queue);
+
+	napi_complete(napi);
+	/* enable interrupt */
+	spin_lock_irq(&priv->reglock);
+	writel(CTCMAC_NOR_TX_D, 
+	    &priv->cpumac_reg->CpuMacInterruptFunc[3]);
+	spin_unlock_irq(&priv->reglock);
+
+	return 0;
+}
+
+static void ctcmac_free_rx_resources(struct ctcmac_private *priv)
+{
+	int i, j;
+	struct ctcmac_priv_rx_q *rx_queue = NULL;
+
+	for (i = 0; i < priv->num_rx_queues; i++) {
+		rx_queue = priv->rx_queue[i]; 
+		if (rx_queue->skb)
+			dev_kfree_skb(rx_queue->skb);
+
+		for (j = 0; j < rx_queue->rx_ring_size; j++){
+			struct	ctcmac_rx_buff *rxb = &rx_queue->rx_buff[j];
+			if(!rxb->page)
+				continue;
+			dma_unmap_single(rx_queue->dev, rxb->dma,
+					 PAGE_SIZE, DMA_TO_DEVICE);
+			__free_page(rxb->page);
+		}
+		if(rx_queue->rx_buff){
+			kfree(rx_queue->rx_buff);
+			rx_queue->rx_buff = NULL;
+		}
+	}
+}
+
+static int ctcmac_init_rx_resources(struct net_device *ndev)
+{
+	int i;
+	struct ctcmac_private *priv = netdev_priv(ndev);
+	struct device *dev = priv->dev;
+	struct ctcmac_priv_rx_q *rx_queue = NULL;
+
+	for (i = 0; i < priv->num_rx_queues; i++) {
+		rx_queue = priv->rx_queue[i]; 
+		rx_queue->ndev = ndev;
+		rx_queue->dev = dev;
+		rx_queue->next_to_clean = 0;
+		rx_queue->next_to_use = 0;
+		rx_queue->next_to_alloc = 0;
+		rx_queue->skb = NULL;
+		rx_queue->rx_buff = kcalloc(rx_queue->rx_ring_size,
+					    sizeof(*rx_queue->rx_buff),
+					    GFP_KERNEL);
+		if (!rx_queue->rx_buff)
+			goto cleanup;
+
+		ctcmac_alloc_rx_buffs(rx_queue, ctcmac_rxbd_unused(rx_queue));
+	}
+
+	return 0;
+
+cleanup:
+	ctcmac_free_rx_resources(priv);
+
+	return -1;
+}
+
+static void ctcmac_free_tx_resources(struct ctcmac_private *priv)
+{
+	int i;
+	struct ctcmac_priv_tx_q *tx_queue = NULL;
+
+	for (i = 0; i < priv->num_tx_queues; i++) {
+		struct netdev_queue *txq;
+
+		tx_queue = priv->tx_queue[i];
+		txq = netdev_get_tx_queue(tx_queue->dev, tx_queue->qindex);
+
+		if(tx_queue->tx_skbuff){
+			kfree(tx_queue->tx_skbuff);
+			tx_queue->tx_skbuff = NULL;
+		}        
+	}
+}
+
+static int ctcmac_init_tx_resources(struct net_device *ndev)
+{
+	int i;
+	struct ctcmac_private *priv = netdev_priv(ndev);
+	struct ctcmac_priv_tx_q *tx_queue = NULL;
+
+	for (i = 0; i < priv->num_tx_queues; i++) {
+		tx_queue = priv->tx_queue[i];
+		tx_queue->num_txbdfree = tx_queue->tx_ring_size;
+		tx_queue->next_to_clean = 0;
+		tx_queue->next_to_alloc = 0;
+		tx_queue->dev = ndev;
+		tx_queue->tx_skbuff =
+		kmalloc_array(tx_queue->tx_ring_size,
+		      sizeof(*tx_queue->tx_skbuff),
+		      GFP_KERNEL);
+
+		if (!tx_queue->tx_skbuff)
+			goto cleanup;
+	}
+
+	return 0;
+
+	cleanup:
+	ctcmac_free_tx_resources(priv);
+
+	return -1;
+}
+
+static int ctcmac_alloc_skb_resources(struct net_device *ndev)
+{    
+	if(ctcmac_init_rx_resources(ndev))
+		return -1;
+	if(ctcmac_init_tx_resources(ndev))
+		return -1;
+
+	return 0;
+}
+
+static int ctcmac_free_skb_resources(struct ctcmac_private *priv)
+{
+	ctcmac_free_rx_resources(priv);
+	ctcmac_free_tx_resources(priv);
+	ctcmac_free_tx_queues(priv);
+	ctcmac_free_rx_queues(priv);
+
+	return 0;
+}
+
+static void cpumac_start(struct ctcmac_private *priv)
+{    
+	/* 1. enable rx/tx interrupt */
+	writel(CTCMAC_NOR_TX_D|CTCMAC_NOR_RX0_D|CTCMAC_NOR_RX1_D, 
+	    &priv->cpumac_reg->CpuMacInterruptFunc[3]);
+	/* 2. enable rx/tx */
+	clrsetbits(&priv->cpumac_reg->CpuMacReset, CPU_MAC_RESET_W0_SOFT_RST_TX, 0);
+	clrsetbits(&priv->cpumac_reg->CpuMacReset, CPU_MAC_RESET_W0_SOFT_RST_RX, 0);
+
+	netif_trans_update(priv->ndev); /* prevent tx timeout */
+}
+
+static void cpumac_halt(struct ctcmac_private *priv)
+{    
+	/* 1. disable rx/tx interrupt */
+	ctcmac_regw(&priv->cpumac_reg->CpuMacInterruptFunc[2], 0xffffffff);
+	ctcmac_regw(&priv->cpumac_reg->CpuMacInterruptNormal[2], 0xffffffff);
+	/* 2. disable rx/tx */
+	clrsetbits(&priv->cpumac_reg->CpuMacReset, 0, CPU_MAC_RESET_W0_SOFT_RST_TX);
+	clrsetbits(&priv->cpumac_reg->CpuMacReset, 0, CPU_MAC_RESET_W0_SOFT_RST_RX);
+}
+
+static int ctcmac_enet_open(struct net_device *dev)
+{
+	struct ctcmac_private *priv = netdev_priv(dev);
+	int err;
+
+	err = ctcmac_init_phy(dev);
+	if(err){
+		return err;
+	}
+	err = ctcmac_request_irq(priv);
+	if (err){
+		return err;
+	}
+	err = startup_ctcmac(dev);
+	if (err){
+		return err;
+	}
+	return 0;
+}
+
+static struct	ctcmac_tx_buff * skb_to_txbuff(struct ctcmac_private *priv, struct sk_buff *skb)
+{
+	u64 addr, offset;
+	int frag_index, nr_frags, rq;
+	skb_frag_t *frag;
+	struct	ctcmac_tx_buff *tx_buff;
+	struct ctcmac_priv_tx_q *tx_queue = NULL;
+
+	nr_frags = skb_shinfo(skb)->nr_frags;
+	rq = skb->queue_mapping;
+	tx_queue = priv->tx_queue[rq];
+
+	tx_buff = &tx_queue->tx_buff[tx_queue->next_to_alloc];
+	addr = (u64)skb->data;
+	if((!test_param[priv->index].txts_en) && (!nr_frags) && 
+	    ((addr & PAGE_MASK) == ((addr+skb_headlen(skb)) & PAGE_MASK))){
+		tx_buff->alloc = 0;
+		tx_buff->vaddr = skb->data;
+		tx_buff->len = skb_headlen(skb);
+		tx_buff->dma = dma_map_single(priv->dev, skb->data, skb_headlen(skb),
+				 DMA_TO_DEVICE);
+		tx_buff->offset = 0;
+	    
+	}else{
+		int alloc_size;
+
+		if (test_param[priv->index].txts_en){
+			alloc_size = ALIGN(skb->len+16, BUF_ALIGNMENT);     
+			tx_buff->len = skb->len + 16;
+		}else{
+			alloc_size = ALIGN(skb->len, BUF_ALIGNMENT);
+			tx_buff->len = skb->len;
+
+		}
+		tx_buff->alloc = 1;
+		tx_buff->vaddr = kmalloc(alloc_size, GFP_KERNEL);        
+		offset = (BUF_ALIGNMENT - (((u64)tx_buff->vaddr)&(BUF_ALIGNMENT - 1)));
+		if(offset == BUF_ALIGNMENT){
+			offset = 0;
+		}
+
+		tx_buff->offset = offset;
+		if (test_param[priv->index].txts_en){
+			memcpy(tx_buff->vaddr + offset, &test_param[priv->index].ptp_info, 16);
+		}
+
+		offset += 16;
+		memcpy(tx_buff->vaddr + offset, skb->data, skb_headlen(skb));
+		offset += skb_headlen(skb);
+		for(frag_index = 0; frag_index <  nr_frags; frag_index++){
+			frag = &skb_shinfo(skb)->frags[frag_index];
+			memcpy(tx_buff->vaddr + offset, frag, skb_frag_size(frag));
+			offset += skb_frag_size(frag);
+		}
+
+		tx_buff->dma = dma_map_single(priv->dev, tx_buff->vaddr, tx_buff->len,
+				 DMA_TO_DEVICE);
+	}
+	return tx_buff;
+}
+
+static int ctcmac_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	int rq = 0;
+	unsigned int  bytes_sent;
+	struct netdev_queue *txq;
+	struct ctcmac_desc_cfg tx_desc;
+	struct	ctcmac_tx_buff *tx_buff;
+	struct ctcmac_priv_tx_q *tx_queue = NULL;
+	struct ctcmac_private *priv = netdev_priv(dev);
+
+	rq = skb->queue_mapping;
+	tx_queue = priv->tx_queue[rq];
+	txq = netdev_get_tx_queue(dev, rq);
+
+	/* check if there is space to queue this packet */
+	if (tx_queue->num_txbdfree <= 0) {
+		pr_err("%s: no space left before send pkt!\n", priv->ndev->name);
+		/* no space, stop the queue */
+		netif_tx_stop_queue(txq);
+		dev->stats.tx_fifo_errors++;
+		return NETDEV_TX_BUSY;
+	}
+
+	/* Update transmit stats */
+	bytes_sent = skb->len;
+	tx_queue->stats.tx_bytes += bytes_sent;
+	tx_queue->stats.tx_packets++;
+
+	tx_buff = skb_to_txbuff(priv, skb);
+	tx_desc.sop = 1;
+	tx_desc.eop = 1;
+	tx_desc.size = tx_buff->len;
+	tx_desc.addr_low = (tx_buff->dma+tx_buff->offset - CTC_DDR_BASE) 
+		& CPU_MAC_DESC_INTF_W0_DESC_ADDR_31_0_MASK;
+	tx_desc.addr_high = ((tx_buff->dma+tx_buff->offset - CTC_DDR_BASE) >> 32) 
+		& CPU_MAC_DESC_INTF_W1_DESC_ADDR_39_32_MASK;
+	ctcmac_fill_txbd(priv, &tx_desc);
+	tx_queue->tx_skbuff[tx_queue->next_to_alloc] = skb;
+
+	//printk(KERN_ERR "ctcmac_start_xmit next_to_alloc eth%d 0x%x 0x%x\n", priv->index, tx_queue->next_to_alloc, tx_buff->alloc);
+	
+	if(tx_queue->next_to_alloc >= tx_queue->tx_ring_size - 1){
+		tx_queue->next_to_alloc = 0;
+	}else{
+		tx_queue->next_to_alloc++;
+	}
+
+	/* We can work in parallel with 872(), except
+	 * when modifying num_txbdfree. Note that we didn't grab the lock
+	 * when we were reading the num_txbdfree and checking for available
+	 * space, that's because outside of this function it can only grow.
+	 */
+	spin_lock_bh(&tx_queue->txlock);
+	/* reduce TxBD free count */
+	tx_queue->num_txbdfree--;
+	spin_unlock_bh(&tx_queue->txlock);
+
+	/* If the next BD still needs to be cleaned up, then the bds
+	 * are full.  We need to tell the kernel to stop sending us stuff.
+	 */
+	if (!tx_queue->num_txbdfree) {
+		netif_tx_stop_queue(txq);
+		pr_err("%s: no space left after send pkt!\n", priv->ndev->name);
+		dev->stats.tx_fifo_errors++;
+	}
+
+	return NETDEV_TX_OK;
+}
+
+static int ctcmac_change_mtu(struct net_device *dev, int new_mtu)
+{
+	struct ctcmac_private *priv = netdev_priv(dev);
+	int frame_size = new_mtu + ETH_HLEN;
+
+	if ((frame_size < 64) || (frame_size > CTCMAC_JUMBO_FRAME_SIZE)) {
+		return -EINVAL;
+	}
+
+	while (test_and_set_bit_lock(CTCMAC_RESETTING, &priv->state))
+		cpu_relax();
+
+	if (dev->flags & IFF_UP)
+		stop_ctcmac(dev);
+
+	dev->mtu = new_mtu;
+
+	if (dev->flags & IFF_UP)
+		startup_ctcmac(dev);
+
+	clear_bit_unlock(CTCMAC_RESETTING, &priv->state);
+
+	return 0;
+}
+
+static int ctcmac_set_features(struct net_device *dev, netdev_features_t features)
+{
+	return 0;
+}
+
+/* Stops the kernel queue, and halts the controller */
+static int ctcmac_close(struct net_device *dev)
+{
+	struct ctcmac_private *priv = netdev_priv(dev);
+
+	cancel_work_sync(&priv->reset_task);
+	stop_ctcmac(dev);
+
+	/* Disconnect from the PHY */
+	phy_disconnect(dev->phydev);
+	ctcmac_free_irq(priv);
+	return 0;
+}
+
+static void ctcmac_set_multi(struct net_device *dev)
+{
+}
+
+static void ctcmac_timeout(struct net_device *dev)
+{
+	struct ctcmac_private *priv = netdev_priv(dev);
+
+	dev->stats.tx_errors++;
+	schedule_work(&priv->reset_task);
+}
+
+static int ctcmac_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	struct phy_device *phydev = dev->phydev;
+
+	if (!netif_running(dev))
+		return -EINVAL;
+
+	if (!phydev)
+		return -ENODEV;
+
+	return phy_mii_ioctl(phydev, rq, cmd);
+}
+
+static struct net_device_stats *ctcmac_get_stats(struct net_device *dev)
+{
+	int qidx;
+	unsigned long rx_packets = 0, rx_bytes = 0, rx_dropped = 0;
+	unsigned long tx_packets = 0, tx_bytes = 0;
+	struct ctcmac_private *priv = netdev_priv(dev);
+
+	for(qidx = 0; qidx < priv->num_rx_queues; qidx++){
+		if(!priv->rx_queue[qidx]){
+			return &dev->stats; 
+		}
+		rx_packets += priv->rx_queue[qidx]->stats.rx_packets;
+		rx_bytes += priv->rx_queue[qidx]->stats.rx_bytes;
+		rx_dropped += priv->rx_queue[qidx]->stats.rx_dropped;
+	}
+
+	if(!priv->tx_queue[0]){
+		return &dev->stats; 
+	}
+
+	tx_packets = priv->tx_queue[0]->stats.tx_packets;
+	tx_bytes = priv->tx_queue[0]->stats.tx_bytes;
+
+	dev->stats.rx_packets = rx_packets;
+	dev->stats.rx_bytes   = rx_bytes;
+	dev->stats.rx_dropped = rx_dropped;
+	dev->stats.tx_bytes   = tx_bytes;
+	dev->stats.tx_packets = tx_packets;
+
+	return &dev->stats;
+}
+
+static int ctcmac_set_mac_addr(struct net_device *dev, void *p)
+{
+	eth_mac_addr(dev, p);
+
+	return 0;
+}
+
+static const struct net_device_ops ctcmac_netdev_ops = {
+	.ndo_open = ctcmac_enet_open,
+	.ndo_start_xmit = ctcmac_start_xmit,
+	.ndo_stop = ctcmac_close,
+	.ndo_change_mtu = ctcmac_change_mtu,
+	.ndo_set_features = ctcmac_set_features,
+	.ndo_set_rx_mode = ctcmac_set_multi,
+	.ndo_tx_timeout = ctcmac_timeout,
+	.ndo_do_ioctl = ctcmac_ioctl,
+	.ndo_get_stats = ctcmac_get_stats,
+	.ndo_set_mac_address = ctcmac_set_mac_addr,
+	.ndo_validate_addr = eth_validate_addr,
+};
+
+static int ctcmac_probe(struct platform_device *ofdev)
+{
+	struct net_device *dev = NULL;
+	struct ctcmac_private *priv = NULL;
+	int err = 0;
+
+	regmap_base = syscon_regmap_lookup_by_phandle(ofdev->dev.of_node,"ctc,sysctrl");
+	if (IS_ERR(regmap_base))
+		return PTR_ERR(regmap_base);
+	
+	err = ctcmac_of_init(ofdev, &dev);
+	if(err){
+		return err;
+	}
+
+	priv = netdev_priv(dev);
+	SET_NETDEV_DEV(dev, &ofdev->dev);
+	INIT_WORK(&priv->reset_task, ctcmac_reset_task);
+	platform_set_drvdata(ofdev, priv);
+
+	dev->base_addr = (unsigned long)priv->iobase;
+	dev->watchdog_timeo = TX_TIMEOUT;
+	dev->mtu = CTCMAC_DEFAULT_MTU;
+	dev->netdev_ops = &ctcmac_netdev_ops;
+	dev->ethtool_ops = &ctcmac_ethtool_test_ops;
+
+	netif_napi_add(dev, &priv->napi_rx, ctcmac_poll_rx_sq, CTCMAC_NAIP_RX_WEIGHT);
+	netif_napi_add(dev, &priv->napi_tx, ctcmac_poll_tx_sq, CTCMAC_NAIP_TX_WEIGHT);
+
+	set_bit(CTCMAC_DOWN, &priv->state);
+
+	if(!g_reglock_init_done)
+		spin_lock_init(&global_reglock);
+
+	g_reglock_init_done = 1;
+
+	spin_lock_init(&priv->reglock);
+	/* Carrier starts down, phylib will bring it up */
+	netif_carrier_off(dev);
+	err = register_netdev(dev);
+	if (err) {
+		goto register_fail;
+	}
+
+	if(!g_mac_unit_init_done){
+		writel(0x07, &priv->cpumacu_reg->CpuMacUnitResetCtl);
+		writel(0x00, &priv->cpumacu_reg->CpuMacUnitResetCtl);
+		
+		clrsetbits(&priv->cpumacu_reg->CpuMacUnitTsCfg, 
+		            0, CPU_MAC_UNIT_TS_CFG_W0_CFG_FORCE_S_AND_NS_EN);
+		if (priv->interface == PHY_INTERFACE_MODE_SGMII){
+			clrsetbits(&priv->cpumacu_reg->CpuMacUnitRefPulseCfg[1], 
+			                        CPU_MAC_UNIT_REF_PULSE_CFG_W1_REF_LINK_PULSE_RST,0);
+
+			ctc_mac_serdes_init(priv);
+		}
+		g_mac_unit_init_done = 1;
+	}
+	
+	mdelay(10);
+	
+	sprintf(priv->irqinfo[CTCMAC_NORMAL].name, "%s%s",
+				dev->name, "_normal");
+	sprintf(priv->irqinfo[CTCMAC_FUNC].name, "%s%s",
+				dev->name, "_func");
+	sprintf(priv->irqinfo[CTCMAC_UNIT].name, "%s%s",
+				dev->name, "_unit");
+	test_param[priv->index].ring_size = 64;
+	test_param[priv->index].payload_size = 256;
+
+	return 0;
+
+	register_fail:
+	ctcmac_unmap_io_space(priv);
+	ctcmac_free_rx_queues(priv);
+	ctcmac_free_tx_queues(priv);
+	of_node_put(priv->phy_node);
+	ctcmac_free_dev(priv);
+
+	return err;
+}
+
+static int ctcmac_remove(struct platform_device *ofdev)
+{
+	struct ctcmac_private *priv = platform_get_drvdata(ofdev);
+
+	of_node_put(priv->phy_node);
+
+	unregister_netdev(priv->ndev);
+
+	ctcmac_unmap_io_space(priv);
+	ctcmac_free_rx_queues(priv);
+	ctcmac_free_tx_queues(priv);
+	ctcmac_free_dev(priv);
+
+	return 0;
+}
+
+static const struct of_device_id ctcmac_match[] =
+{
+	{
+		.type = "network",
+		.compatible = "ctc,mac-test",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, ctcmac_match);
+
+/* Structure for a device driver */
+static struct platform_driver ctcmac_driver = {
+	.driver = {
+		.name = "ctc-cpumac-test",
+		.of_match_table = ctcmac_match,
+	},
+	.probe = ctcmac_probe,
+	.remove = ctcmac_remove,
+};
+
+module_platform_driver(ctcmac_driver);
+MODULE_LICENSE("GPL");
